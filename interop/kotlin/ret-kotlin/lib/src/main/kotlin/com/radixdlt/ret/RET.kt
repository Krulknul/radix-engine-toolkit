// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package com.radixdlt.ret;

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the detils of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import com.sun.jna.Library
import com.sun.jna.IntegerType
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import com.sun.jna.Callback
import com.sun.jna.ptr.*
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.CharBuffer
import java.nio.charset.CodingErrorAction
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
    @JvmField var capacity: Int = 0
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue: RustBuffer(), Structure.ByValue
    class ByReference: RustBuffer(), Structure.ByReference

    companion object {
        internal fun alloc(size: Int = 0) = rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_radix_engine_toolkit_uniffi_rustbuffer_alloc(size, status).also {
                if(it.data == null) {
                   throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=${size})")
               }
            }
        }

        internal fun free(buf: RustBuffer.ByValue) = rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_radix_engine_toolkit_uniffi_rustbuffer_free(buf, status)
        }
    }

    @Suppress("TooGenericExceptionThrown")
    fun asByteBuffer() =
        this.data?.getByteBuffer(0, this.len.toLong())?.also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
}

/**
 * The equivalent of the `*mut RustBuffer` type.
 * Required for callbacks taking in an out pointer.
 *
 * Size is the sum of all values in the struct.
 */
class RustBufferByReference : ByReference(16) {
    /**
     * Set the pointed-to `RustBuffer` to the given value.
     */
    fun setValue(value: RustBuffer.ByValue) {
        // NOTE: The offsets are as they are in the C-like struct.
        val pointer = getPointer()
        pointer.setInt(0, value.capacity)
        pointer.setInt(4, value.len)
        pointer.setPointer(8, value.data)
    }

    /**
     * Get a `RustBuffer.ByValue` from this reference.
     */
    fun getValue(): RustBuffer.ByValue {
        val pointer = getPointer()
        val value = RustBuffer.ByValue()
        value.writeField("capacity", pointer.getInt(0))
        value.writeField("len", pointer.getInt(4))
        value.writeField("data", pointer.getPointer(8))

        return value
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
open class ForeignBytes : Structure() {
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue : ForeignBytes(), Structure.ByValue
}
// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
public interface FfiConverter<KotlinType, FfiType> {
    // Convert an FFI type to a Kotlin type
    fun lift(value: FfiType): KotlinType

    // Convert an Kotlin type to an FFI type
    fun lower(value: KotlinType): FfiType

    // Read a Kotlin type from a `ByteBuffer`
    fun read(buf: ByteBuffer): KotlinType

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    fun allocationSize(value: KotlinType): Int

    // Write a Kotlin type to a `ByteBuffer`
    fun write(value: KotlinType, buf: ByteBuffer)

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer.ByValue {
        val rbuf = RustBuffer.alloc(allocationSize(value))
        try {
            val bbuf = rbuf.data!!.getByteBuffer(0, rbuf.capacity.toLong()).also {
                it.order(ByteOrder.BIG_ENDIAN)
            }
            write(value, bbuf)
            rbuf.writeField("len", bbuf.position())
            return rbuf
        } catch (e: Throwable) {
            RustBuffer.free(rbuf)
            throw e
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    fun liftFromRustBuffer(rbuf: RustBuffer.ByValue): KotlinType {
        val byteBuf = rbuf.asByteBuffer()!!
        try {
           val item = read(byteBuf)
           if (byteBuf.hasRemaining()) {
               throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
           }
           return item
        } finally {
            RustBuffer.free(rbuf)
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
public interface FfiConverterRustBuffer<KotlinType>: FfiConverter<KotlinType, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue) = liftFromRustBuffer(value)
    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
@Structure.FieldOrder("code", "error_buf")
internal open class RustCallStatus : Structure() {
    @JvmField var code: Byte = 0
    @JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

    class ByValue: RustCallStatus(), Structure.ByValue

    fun isSuccess(): Boolean {
        return code == 0.toByte()
    }

    fun isError(): Boolean {
        return code == 1.toByte()
    }

    fun isPanic(): Boolean {
        return code == 2.toByte()
    }
}

class InternalException(message: String) : Exception(message)

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E> {
    fun lift(error_buf: RustBuffer.ByValue): E;
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E: Exception> rustCallWithError(errorHandler: CallStatusErrorHandler<E>, callback: (RustCallStatus) -> U): U {
    var status = RustCallStatus();
    val return_value = callback(status)
    checkCallStatus(errorHandler, status)
    return return_value
}

// Check RustCallStatus and throw an error if the call wasn't successful
private fun<E: Exception> checkCallStatus(errorHandler: CallStatusErrorHandler<E>, status: RustCallStatus) {
    if (status.isSuccess()) {
        return
    } else if (status.isError()) {
        throw errorHandler.lift(status.error_buf)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.error_buf.len > 0) {
            throw InternalException(FfiConverterString.lift(status.error_buf))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
object NullCallStatusErrorHandler: CallStatusErrorHandler<InternalException> {
    override fun lift(error_buf: RustBuffer.ByValue): InternalException {
        RustBuffer.free(error_buf)
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
private inline fun <U> rustCall(callback: (RustCallStatus) -> U): U {
    return rustCallWithError(NullCallStatusErrorHandler, callback);
}

// IntegerType that matches Rust's `usize` / C's `size_t`
public class USize(value: Long = 0) : IntegerType(Native.SIZE_T_SIZE, value, true) {
    // This is needed to fill in the gaps of IntegerType's implementation of Number for Kotlin.
    override fun toByte() = toInt().toByte()
    override fun toChar() = toInt().toChar()
    override fun toShort() = toInt().toShort()

    fun writeToBuffer(buf: ByteBuffer) {
        // Make sure we always write usize integers using native byte-order, since they may be
        // casted to pointer values
        buf.order(ByteOrder.nativeOrder())
        try {
            when (Native.SIZE_T_SIZE) {
                4 -> buf.putInt(toInt())
                8 -> buf.putLong(toLong())
                else -> throw RuntimeException("Invalid SIZE_T_SIZE: ${Native.SIZE_T_SIZE}")
            }
        } finally {
            buf.order(ByteOrder.BIG_ENDIAN)
        }
    }

    companion object {
        val size: Int
            get() = Native.SIZE_T_SIZE

        fun readFromBuffer(buf: ByteBuffer) : USize {
            // Make sure we always read usize integers using native byte-order, since they may be
            // casted from pointer values
            buf.order(ByteOrder.nativeOrder())
            try {
                return when (Native.SIZE_T_SIZE) {
                    4 -> USize(buf.getInt().toLong())
                    8 -> USize(buf.getLong())
                    else -> throw RuntimeException("Invalid SIZE_T_SIZE: ${Native.SIZE_T_SIZE}")
                }
            } finally {
                buf.order(ByteOrder.BIG_ENDIAN)
            }
        }
    }
}


// Map handles to objects
//
// This is used when the Rust code expects an opaque pointer to represent some foreign object.
// Normally we would pass a pointer to the object, but JNA doesn't support getting a pointer from an
// object reference , nor does it support leaking a reference to Rust.
//
// Instead, this class maps USize values to objects so that we can pass a pointer-sized type to
// Rust when it needs an opaque pointer.
//
// TODO: refactor callbacks to use this class
internal class UniFfiHandleMap<T: Any> {
    private val map = ConcurrentHashMap<USize, T>()
    // Use AtomicInteger for our counter, since we may be on a 32-bit system.  4 billion possible
    // values seems like enough. If somehow we generate 4 billion handles, then this will wrap
    // around back to zero and we can assume the first handle generated will have been dropped by
    // then.
    private val counter = java.util.concurrent.atomic.AtomicInteger(0)

    val size: Int
        get() = map.size

    fun insert(obj: T): USize {
        val handle = USize(counter.getAndAdd(1).toLong())
        map.put(handle, obj)
        return handle
    }

    fun get(handle: USize): T? {
        return map.get(handle)
    }

    fun remove(handle: USize) {
        map.remove(handle)
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
    val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
    if (libOverride != null) {
        return libOverride
    }
    return "uniffi_radix_engine_toolkit_uniffi"
}

private inline fun <reified Lib : Library> loadIndirect(
    componentName: String
): Lib {
    return Native.load<Lib>(findLibraryName(componentName), Lib::class.java)
}

// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.

internal interface _UniFFILib : Library {
    companion object {
        internal val INSTANCE: _UniFFILib by lazy {
            loadIndirect<_UniFFILib>(componentName = "radix_engine_toolkit_uniffi")
            .also { lib: _UniFFILib ->
                uniffiCheckContractApiVersion(lib)
                uniffiCheckApiChecksums(lib)
                FfiConverterTypeSigner.register(lib)
                }
        }
    }

    fun uniffi_radix_engine_toolkit_uniffi_fn_free_accessrule(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_allow_all(_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_deny_all(_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require(`resourceOrNonFungible`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_all_of(`resources`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_amount(`amount`: Pointer,`resource`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_any_of(`resources`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_count_of(`count`: Byte,`resources`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_virtual_signature(`publicKey`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_accessrule_and(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_accessrule_or(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_free_address(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_from_raw(`nodeIdBytes`: RustBuffer.ByValue,`networkId`: Byte,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_new(`address`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_resource_address_from_olympia_resource_address(`olympiaResourceAddress`: Pointer,`networkId`: Byte,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_account_address_from_olympia_address(`olympiaAccountAddress`: Pointer,`networkId`: Byte,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_account_address_from_public_key(`publicKey`: RustBuffer.ByValue,`networkId`: Byte,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_identity_address_from_public_key(`publicKey`: RustBuffer.ByValue,`networkId`: Byte,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_address_address_string(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_address_as_str(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_address_bytes(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_address_entity_type(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_component(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_consensus_manager(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_fungible_resource_manager(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_non_fungible_resource_manager(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_package(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_resource_manager(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_virtual(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_fungible_vault(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_kv_store(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_non_fungible_vault(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_vault(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_address_network_id(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_free_decimal(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_max(_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_min(_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_new(`value`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_one(_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_zero(_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_abs(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_add(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_as_str(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_cbrt(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_ceiling(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_div(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_equal(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_floor(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than_or_equal(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_negative(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_positive(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_zero(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than_or_equal(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_mantissa(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_mul(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_not_equal(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_nth_root(`ptr`: Pointer,`n`: Int,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_powi(`ptr`: Pointer,`exp`: Long,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_round(`ptr`: Pointer,`decimalPlaces`: Int,`roundingMode`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sqrt(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sub(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_free_hash(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_hex_string(`hash`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_unhashed_bytes(`bytes`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_new(`hash`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_hash_as_str(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_hash_bytes(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_free_instructions(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructions_from_instructions(`instructions`: RustBuffer.ByValue,`networkId`: Byte,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructions_from_string(`string`: RustBuffer.ByValue,`networkId`: Byte,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_as_str(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_instructions_list(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_network_id(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_free_intent(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_intent_decompile(`compiledIntent`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_intent_new(`header`: RustBuffer.ByValue,`manifest`: Pointer,`message`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_intent_compile(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_intent_hash(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_intent_header(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_intent_intent_hash(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_intent_manifest(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_intent_message(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_intent_statically_validate(`ptr`: Pointer,`validationConfig`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_free_manifestbuilder(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_manifestbuilder_new(_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_initiate_recovery(`ptr`: Pointer,`accessControllerAddress`: Pointer,`proposer`: RustBuffer.ByValue,`proposedPrimaryRole`: Pointer,`proposedRecoveryRole`: Pointer,`proposedConfirmationRole`: Pointer,`proposedTimedRecoveryDelayInMinutes`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_quick_confirm_recovery(`ptr`: Pointer,`accessControllerAddress`: Pointer,`proposer`: RustBuffer.ByValue,`proposedPrimaryRole`: Pointer,`proposedRecoveryRole`: Pointer,`proposedConfirmationRole`: Pointer,`proposedTimedRecoveryDelayInMinutes`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit(`ptr`: Pointer,`accountAddress`: Pointer,`bucket`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit_batch(`ptr`: Pointer,`accountAddress`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_batch_or_abort(`ptr`: Pointer,`accountAddress`: Pointer,`authorizedDepositorBadge`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_batch_or_refund(`ptr`: Pointer,`accountAddress`: Pointer,`authorizedDepositorBadge`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_or_abort(`ptr`: Pointer,`accountAddress`: Pointer,`authorizedDepositorBadge`: RustBuffer.ByValue,`bucket`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_or_refund(`ptr`: Pointer,`accountAddress`: Pointer,`authorizedDepositorBadge`: RustBuffer.ByValue,`bucket`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_allocate_global_address(`ptr`: Pointer,`packageAddress`: Pointer,`blueprintName`: RustBuffer.ByValue,`intoAddressReservation`: RustBuffer.ByValue,`intoNamedAddress`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains(`ptr`: Pointer,`resourceAddress`: Pointer,`amount`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains_any(`ptr`: Pointer,`resourceAddress`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains_non_fungibles(`ptr`: Pointer,`resourceAddress`: Pointer,`ids`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_build(`ptr`: Pointer,`networkId`: Byte,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_burn_resource(`ptr`: Pointer,`bucket`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_access_rules_method(`ptr`: Pointer,`address`: RustBuffer.ByValue,`methodName`: RustBuffer.ByValue,`args`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_direct_vault_method(`ptr`: Pointer,`address`: Pointer,`methodName`: RustBuffer.ByValue,`args`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_function(`ptr`: Pointer,`address`: RustBuffer.ByValue,`blueprintName`: RustBuffer.ByValue,`functionName`: RustBuffer.ByValue,`args`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_metadata_method(`ptr`: Pointer,`address`: RustBuffer.ByValue,`methodName`: RustBuffer.ByValue,`args`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_method(`ptr`: Pointer,`address`: RustBuffer.ByValue,`methodName`: RustBuffer.ByValue,`args`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_royalty_method(`ptr`: Pointer,`address`: RustBuffer.ByValue,`methodName`: RustBuffer.ByValue,`args`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_clone_proof(`ptr`: Pointer,`proof`: RustBuffer.ByValue,`intoProof`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_access_controller_with_securify_structure(`ptr`: Pointer,`controlledAsset`: RustBuffer.ByValue,`primaryRole`: RustBuffer.ByValue,`recoveryRole`: RustBuffer.ByValue,`confirmationRole`: RustBuffer.ByValue,`timedRecoveryDelayInMinutes`: RustBuffer.ByValue,`addressReservation`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_account_advanced(`ptr`: Pointer,`ownerRole`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_fungible_resource_manager(`ptr`: Pointer,`ownerRole`: RustBuffer.ByValue,`trackTotalSupply`: Byte,`divisibility`: Byte,`initialSupply`: RustBuffer.ByValue,`resourceRoles`: RustBuffer.ByValue,`metadata`: RustBuffer.ByValue,`addressReservation`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_all(`ptr`: Pointer,`resourceAddress`: Pointer,`intoProof`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_amount(`ptr`: Pointer,`resourceAddress`: Pointer,`amount`: Pointer,`intoProof`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_non_fungibles(`ptr`: Pointer,`resourceAddress`: Pointer,`ids`: RustBuffer.ByValue,`intoProof`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_all(`ptr`: Pointer,`bucket`: RustBuffer.ByValue,`intoProof`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_amount(`ptr`: Pointer,`amount`: Pointer,`bucket`: RustBuffer.ByValue,`intoProof`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_non_fungibles(`ptr`: Pointer,`ids`: RustBuffer.ByValue,`bucket`: RustBuffer.ByValue,`intoProof`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_signature_based_access_controller(`ptr`: Pointer,`controlledAsset`: RustBuffer.ByValue,`primaryRole`: RustBuffer.ByValue,`recoveryRole`: RustBuffer.ByValue,`confirmationRole`: RustBuffer.ByValue,`timedRecoveryDelayInMinutes`: RustBuffer.ByValue,`addressReservation`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_all_proofs(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_auth_zone_proofs(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_auth_zone_signature_proofs(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_proof(`ptr`: Pointer,`proof`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_faucet_free_xrd(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_faucet_lock_fee(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_mint_fungible(`ptr`: Pointer,`resourceAddress`: Pointer,`amount`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_pop_from_auth_zone(`ptr`: Pointer,`intoProof`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_publish_package(`ptr`: Pointer,`code`: RustBuffer.ByValue,`definition`: RustBuffer.ByValue,`metadata`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_push_to_auth_zone(`ptr`: Pointer,`proof`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_return_to_worktop(`ptr`: Pointer,`bucket`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_set_metadata(`ptr`: Pointer,`address`: Pointer,`key`: RustBuffer.ByValue,`value`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_set_role(`ptr`: Pointer,`address`: Pointer,`module`: RustBuffer.ByValue,`roleKey`: RustBuffer.ByValue,`rule`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_all_from_worktop(`ptr`: Pointer,`resourceAddress`: Pointer,`intoBucket`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_from_worktop(`ptr`: Pointer,`resourceAddress`: Pointer,`amount`: Pointer,`intoBucket`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_non_fungibles_from_worktop(`ptr`: Pointer,`resourceAddress`: Pointer,`ids`: RustBuffer.ByValue,`intoBucket`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_withdraw_from_account(`ptr`: Pointer,`accountAddress`: Pointer,`resourceAddress`: Pointer,`amount`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_withdraw_non_fungibles_from_account(`ptr`: Pointer,`accountAddress`: Pointer,`resourceAddress`: Pointer,`ids`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_free_messagevalidationconfig(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_messagevalidationconfig_default(_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_messagevalidationconfig_new(`maxPlaintextMessageLength`: Long,`maxEncryptedMessageLength`: Long,`maxMimeTypeLength`: Long,`maxDecryptors`: Long,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_decryptors(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Long
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_encrypted_message_length(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Long
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_mime_type_length(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Long
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_plaintext_message_length(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Long
    fun uniffi_radix_engine_toolkit_uniffi_fn_free_nonfungibleglobalid(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_from_parts(`resourceAddress`: Pointer,`nonFungibleLocalId`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_new(`nonFungibleGlobalId`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_virtual_signature_badge(`publicKey`: RustBuffer.ByValue,`networkId`: Byte,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_as_str(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_local_id(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_resource_address(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_free_notarizedtransaction(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransaction_decompile(`compiledNotarizedTransaction`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransaction_new(`signedIntent`: Pointer,`notarySignature`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_compile(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_hash(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_intent_hash(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_notarized_transaction_hash(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_notary_signature(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_signed_intent(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_signed_intent_hash(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_statically_validate(`ptr`: Pointer,`validationConfig`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_free_olympiaaddress(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_olympiaaddress_new(`address`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_as_str(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_public_key(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_free_precisedecimal(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_max(_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_min(_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_new(`value`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_one(_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_zero(_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_abs(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_add(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_as_str(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_cbrt(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_ceiling(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_div(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_equal(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_floor(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than_or_equal(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_negative(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_positive(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_zero(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than_or_equal(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_mantissa(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_mul(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_not_equal(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_nth_root(`ptr`: Pointer,`n`: Int,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_powi(`ptr`: Pointer,`exp`: Long,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_round(`ptr`: Pointer,`decimalPlaces`: Int,`roundingMode`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sqrt(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sub(`ptr`: Pointer,`other`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_free_privatekey(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new(`bytes`: RustBuffer.ByValue,`curve`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new_ed25519(`bytes`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new_secp256k1(`bytes`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_public_key(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign(`ptr`: Pointer,`hash`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign_to_signature(`ptr`: Pointer,`hash`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign_to_signature_with_public_key(`ptr`: Pointer,`hash`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_free_signedintent(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedintent_decompile(`compiledSignedIntent`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedintent_new(`intent`: Pointer,`intentSignatures`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_compile(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_hash(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent_hash(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent_signatures(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_signed_intent_hash(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_statically_validate(`ptr`: Pointer,`validationConfig`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilder(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionbuilder_new(_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilder_header(`ptr`: Pointer,`header`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilderheaderstep(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderheaderstep_manifest(`ptr`: Pointer,`manifest`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilderintentsignaturesstep(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_notarize_with_private_key(`ptr`: Pointer,`privateKey`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_notarize_with_signer(`ptr`: Pointer,`signer`: Long,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_sign_with_private_key(`ptr`: Pointer,`privateKey`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_sign_with_signer(`ptr`: Pointer,`signer`: Long,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuildermessagestep(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_message(`ptr`: Pointer,`message`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_sign_with_private_key(`ptr`: Pointer,`privateKey`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_sign_with_signer(`ptr`: Pointer,`signer`: Long,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_free_transactionhash(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionhash_from_str(`string`: RustBuffer.ByValue,`networkId`: Byte,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_hash(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_str(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_bytes(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_network_id(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_free_transactionmanifest(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionmanifest_decompile(`compiled`: RustBuffer.ByValue,`networkId`: Byte,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionmanifest_new(`instructions`: Pointer,`blobs`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_deposited_into(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_requiring_auth(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_withdrawn_from(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_analyze_execution(`ptr`: Pointer,`transactionReceipt`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_blobs(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_compile(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_extract_addresses(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_identities_requiring_auth(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_instructions(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_modify(`ptr`: Pointer,`modifications`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_parse_transfer_information(`ptr`: Pointer,`allowLockFeeInstructions`: Byte,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_statically_validate(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_free_validationconfig(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_validationconfig_default(`networkId`: Byte,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_constructor_validationconfig_new(`networkId`: Byte,`maxNotarizedPayloadSize`: Long,`minTipPercentage`: Short,`maxTipPercentage`: Short,`maxEpochRange`: Long,`messageValidation`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_epoch_range(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Long
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_notarized_payload_size(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Long
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_tip_percentage(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_message_validation(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_min_tip_percentage(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_network_id(`ptr`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): Byte
    fun uniffi_radix_engine_toolkit_uniffi_fn_init_callback_signer(`callbackStub`: ForeignCallback,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_build_information(_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_derive_olympia_account_address_from_public_key(`publicKey`: RustBuffer.ByValue,`olympiaNetwork`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_derive_public_key_from_olympia_account_address(`olympiaResourceAddress`: Pointer,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_derive_resource_address_from_olympia_resource_address(`olympiaResourceAddress`: Pointer,`networkId`: Byte,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_account_address_from_olympia_account_address(`olympiaAccountAddress`: Pointer,`networkId`: Byte,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_account_address_from_public_key(`publicKey`: RustBuffer.ByValue,`networkId`: Byte,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_identity_address_from_public_key(`publicKey`: RustBuffer.ByValue,`networkId`: Byte,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_signature_non_fungible_global_id_from_public_key(`publicKey`: RustBuffer.ByValue,`networkId`: Byte,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_hash(`data`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Pointer
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_known_addresses(`networkId`: Byte,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_manifest_sbor_decode_to_string_representation(`bytes`: RustBuffer.ByValue,`representation`: RustBuffer.ByValue,`networkId`: Byte,`schema`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_metadata_sbor_decode(`bytes`: RustBuffer.ByValue,`networkId`: Byte,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_metadata_sbor_encode(`value`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_as_str(`value`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_from_str(`string`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_sbor_decode(`bytes`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_sbor_encode(`value`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_string_representation(`bytes`: RustBuffer.ByValue,`representation`: RustBuffer.ByValue,`networkId`: Byte,`schema`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_typed_native_event(`eventTypeIdentifier`: RustBuffer.ByValue,`eventData`: RustBuffer.ByValue,`networkId`: Byte,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_scrypto_sbor_decode_to_string_representation(`bytes`: RustBuffer.ByValue,`representation`: RustBuffer.ByValue,`networkId`: Byte,`schema`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_scrypto_sbor_encode_string_representation(`representation`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_fn_func_test_panic(`message`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun ffi_radix_engine_toolkit_uniffi_rustbuffer_alloc(`size`: Int,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_radix_engine_toolkit_uniffi_rustbuffer_from_bytes(`bytes`: ForeignBytes.ByValue,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_radix_engine_toolkit_uniffi_rustbuffer_free(`buf`: RustBuffer.ByValue,_uniffi_out_err: RustCallStatus, 
    ): Unit
    fun ffi_radix_engine_toolkit_uniffi_rustbuffer_reserve(`buf`: RustBuffer.ByValue,`additional`: Int,_uniffi_out_err: RustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_build_information(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_olympia_account_address_from_public_key(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_public_key_from_olympia_account_address(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_resource_address_from_olympia_resource_address(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_account_address_from_olympia_account_address(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_account_address_from_public_key(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_identity_address_from_public_key(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_signature_non_fungible_global_id_from_public_key(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_hash(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_known_addresses(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_manifest_sbor_decode_to_string_representation(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_metadata_sbor_decode(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_metadata_sbor_encode(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_as_str(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_from_str(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_sbor_decode(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_sbor_encode(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_string_representation(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_typed_native_event(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_scrypto_sbor_decode_to_string_representation(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_scrypto_sbor_encode_string_representation(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_func_test_panic(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_accessrule_and(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_accessrule_or(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_address_address_string(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_address_as_str(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_address_bytes(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_address_entity_type(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_component(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_consensus_manager(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_fungible_resource_manager(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_non_fungible_resource_manager(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_package(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_resource_manager(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_virtual(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_fungible_vault(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_kv_store(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_non_fungible_vault(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_vault(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_address_network_id(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_abs(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_add(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_as_str(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_cbrt(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_ceiling(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_div(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_equal(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_floor(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than_or_equal(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_negative(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_positive(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_zero(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than_or_equal(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_mantissa(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_mul(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_not_equal(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_nth_root(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_powi(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_round(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sqrt(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sub(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_as_str(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_bytes(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_as_str(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_instructions_list(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_network_id(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_compile(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_hash(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_header(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_intent_hash(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_manifest(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_message(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_statically_validate(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_initiate_recovery(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_quick_confirm_recovery(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit_batch(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_batch_or_abort(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_batch_or_refund(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_or_abort(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_or_refund(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_allocate_global_address(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains_any(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains_non_fungibles(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_build(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_burn_resource(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_access_rules_method(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_direct_vault_method(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_function(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_metadata_method(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_method(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_royalty_method(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_clone_proof(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_access_controller_with_securify_structure(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_account_advanced(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_fungible_resource_manager(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_all(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_amount(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_non_fungibles(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_all(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_amount(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_non_fungibles(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_signature_based_access_controller(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_all_proofs(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_auth_zone_proofs(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_auth_zone_signature_proofs(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_proof(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_faucet_free_xrd(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_faucet_lock_fee(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_mint_fungible(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_pop_from_auth_zone(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_publish_package(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_push_to_auth_zone(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_return_to_worktop(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_set_metadata(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_set_role(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_all_from_worktop(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_from_worktop(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_non_fungibles_from_worktop(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_withdraw_from_account(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_withdraw_non_fungibles_from_account(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_decryptors(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_encrypted_message_length(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_mime_type_length(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_plaintext_message_length(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_as_str(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_local_id(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_resource_address(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_compile(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_hash(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_intent_hash(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_notarized_transaction_hash(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_notary_signature(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_signed_intent(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_signed_intent_hash(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_statically_validate(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_as_str(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_public_key(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_abs(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_add(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_as_str(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_cbrt(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_ceiling(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_div(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_equal(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_floor(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than_or_equal(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_negative(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_positive(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_zero(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than_or_equal(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_mantissa(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_mul(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_not_equal(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_nth_root(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_powi(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_round(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sqrt(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sub(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_public_key(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign_to_signature(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign_to_signature_with_public_key(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_compile(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_hash(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent_hash(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent_signatures(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_signed_intent_hash(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_statically_validate(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilder_header(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderheaderstep_manifest(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_notarize_with_private_key(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_notarize_with_signer(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_sign_with_private_key(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_sign_with_signer(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_message(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_sign_with_private_key(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_sign_with_signer(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_hash(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_str(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_bytes(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_network_id(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_deposited_into(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_requiring_auth(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_withdrawn_from(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_analyze_execution(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_blobs(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_compile(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_extract_addresses(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_identities_requiring_auth(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_instructions(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_modify(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_parse_transfer_information(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_statically_validate(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_epoch_range(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_notarized_payload_size(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_tip_percentage(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_message_validation(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_min_tip_percentage(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_network_id(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_allow_all(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_deny_all(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_all_of(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_amount(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_any_of(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_count_of(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_virtual_signature(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_from_raw(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_new(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_resource_address_from_olympia_resource_address(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_account_address_from_olympia_address(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_account_address_from_public_key(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_identity_address_from_public_key(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_max(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_min(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_new(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_one(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_zero(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_hex_string(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_unhashed_bytes(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_new(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructions_from_instructions(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructions_from_string(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intent_decompile(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intent_new(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_manifestbuilder_new(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_messagevalidationconfig_default(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_messagevalidationconfig_new(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_from_parts(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_new(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_virtual_signature_badge(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransaction_decompile(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransaction_new(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_olympiaaddress_new(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_max(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_min(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_new(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_one(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_zero(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new_ed25519(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new_secp256k1(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedintent_decompile(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedintent_new(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionbuilder_new(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionhash_from_str(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionmanifest_decompile(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionmanifest_new(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_validationconfig_default(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_constructor_validationconfig_new(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign_to_signature(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign_to_signature_with_public_key(
    ): Short
    fun uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_public_key(
    ): Short
    fun ffi_radix_engine_toolkit_uniffi_uniffi_contract_version(
    ): Int
    
}

private fun uniffiCheckContractApiVersion(lib: _UniFFILib) {
    // Get the bindings contract version from our ComponentInterface
    val bindings_contract_version = 22
    // Get the scaffolding contract version by calling the into the dylib
    val scaffolding_contract_version = lib.ffi_radix_engine_toolkit_uniffi_uniffi_contract_version()
    if (bindings_contract_version != scaffolding_contract_version) {
        throw RuntimeException("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    }
}

@Suppress("UNUSED_PARAMETER")
private fun uniffiCheckApiChecksums(lib: _UniFFILib) {
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_build_information() != 17662.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_olympia_account_address_from_public_key() != 19647.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_public_key_from_olympia_account_address() != 45205.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_resource_address_from_olympia_resource_address() != 11639.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_account_address_from_olympia_account_address() != 24509.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_account_address_from_public_key() != 36758.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_identity_address_from_public_key() != 11003.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_signature_non_fungible_global_id_from_public_key() != 61146.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_hash() != 16303.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_known_addresses() != 16813.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_manifest_sbor_decode_to_string_representation() != 19578.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_metadata_sbor_decode() != 54114.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_metadata_sbor_encode() != 11090.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_as_str() != 10663.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_from_str() != 27404.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_sbor_decode() != 5482.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_sbor_encode() != 44017.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_string_representation() != 11831.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_typed_native_event() != 43789.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_scrypto_sbor_decode_to_string_representation() != 50232.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_scrypto_sbor_encode_string_representation() != 24947.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_test_panic() != 25407.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_accessrule_and() != 5785.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_accessrule_or() != 27266.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_address_string() != 5709.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_as_str() != 38197.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_bytes() != 16699.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_entity_type() != 40172.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global() != 25808.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_component() != 58252.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_consensus_manager() != 48841.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_fungible_resource_manager() != 55847.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_non_fungible_resource_manager() != 16959.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_package() != 10761.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_resource_manager() != 34705.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_virtual() != 44552.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal() != 34745.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_fungible_vault() != 26605.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_kv_store() != 4366.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_non_fungible_vault() != 30524.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_vault() != 10507.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_network_id() != 20026.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_abs() != 31072.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_add() != 42883.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_as_str() != 18253.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_cbrt() != 18756.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_ceiling() != 62165.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_div() != 25038.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_equal() != 45597.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_floor() != 31716.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than() != 16609.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than_or_equal() != 3170.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_negative() != 27762.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_positive() != 15349.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_zero() != 27694.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than() != 30546.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than_or_equal() != 2387.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_mantissa() != 41794.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_mul() != 18912.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_not_equal() != 61801.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_nth_root() != 6178.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_powi() != 35861.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_round() != 31873.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sqrt() != 43295.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sub() != 26365.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_as_str() != 46597.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_bytes() != 57303.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_as_str() != 2403.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_instructions_list() != 45845.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_network_id() != 55489.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_compile() != 31325.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_hash() != 993.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_header() != 49719.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_intent_hash() != 63530.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_manifest() != 60823.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_message() != 49610.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_statically_validate() != 18502.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_initiate_recovery() != 9147.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_access_controller_quick_confirm_recovery() != 6850.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit() != 58477.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit_batch() != 3828.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_batch_or_abort() != 14294.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_batch_or_refund() != 51871.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_or_abort() != 44832.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_or_refund() != 50194.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_allocate_global_address() != 18604.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains() != 37738.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains_any() != 20665.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains_non_fungibles() != 58282.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_build() != 36705.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_burn_resource() != 52445.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_access_rules_method() != 19399.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_direct_vault_method() != 53674.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_function() != 38619.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_metadata_method() != 42239.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_method() != 39370.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_royalty_method() != 25488.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_clone_proof() != 52407.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_access_controller_with_securify_structure() != 21421.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_account_advanced() != 27856.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_fungible_resource_manager() != 45955.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_all() != 51538.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_amount() != 51265.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_non_fungibles() != 49166.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_all() != 46129.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_amount() != 20827.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_non_fungibles() != 25333.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_signature_based_access_controller() != 676.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_all_proofs() != 12341.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_auth_zone_proofs() != 63484.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_auth_zone_signature_proofs() != 2952.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_proof() != 29894.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_faucet_free_xrd() != 59721.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_faucet_lock_fee() != 5856.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_mint_fungible() != 41635.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_pop_from_auth_zone() != 54385.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_publish_package() != 13228.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_push_to_auth_zone() != 59668.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_return_to_worktop() != 48542.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_set_metadata() != 4065.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_set_role() != 58550.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_all_from_worktop() != 61948.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_from_worktop() != 7334.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_non_fungibles_from_worktop() != 49676.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_withdraw_from_account() != 4369.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_withdraw_non_fungibles_from_account() != 36610.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_decryptors() != 45350.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_encrypted_message_length() != 10753.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_mime_type_length() != 15824.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_plaintext_message_length() != 53437.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_as_str() != 12617.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_local_id() != 42729.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_resource_address() != 26038.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_compile() != 65183.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_hash() != 64270.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_intent_hash() != 51688.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_notarized_transaction_hash() != 17757.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_notary_signature() != 46873.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_signed_intent() != 11409.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_signed_intent_hash() != 60604.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_statically_validate() != 11188.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_as_str() != 211.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_public_key() != 33649.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_abs() != 753.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_add() != 50067.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_as_str() != 50135.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_cbrt() != 31353.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_ceiling() != 6632.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_div() != 47336.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_equal() != 35658.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_floor() != 6297.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than() != 21292.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than_or_equal() != 34931.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_negative() != 11588.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_positive() != 30868.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_zero() != 41566.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than() != 50862.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than_or_equal() != 33893.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_mantissa() != 2374.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_mul() != 35568.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_not_equal() != 17368.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_nth_root() != 60037.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_powi() != 57119.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_round() != 22122.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sqrt() != 18565.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sub() != 2969.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_public_key() != 49403.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign() != 21427.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign_to_signature() != 4246.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign_to_signature_with_public_key() != 41168.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_compile() != 26394.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_hash() != 60260.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent() != 19540.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent_hash() != 9462.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent_signatures() != 46037.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_signed_intent_hash() != 20757.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_statically_validate() != 27682.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilder_header() != 40383.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderheaderstep_manifest() != 8446.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_notarize_with_private_key() != 57025.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_notarize_with_signer() != 32547.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_sign_with_private_key() != 29671.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_sign_with_signer() != 17372.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_message() != 55782.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_sign_with_private_key() != 60073.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_sign_with_signer() != 21713.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_hash() != 1343.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_str() != 9829.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_bytes() != 40875.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_network_id() != 4187.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_deposited_into() != 33560.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_requiring_auth() != 31236.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_withdrawn_from() != 1186.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_analyze_execution() != 28095.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_blobs() != 55127.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_compile() != 11452.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_extract_addresses() != 5474.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_identities_requiring_auth() != 1239.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_instructions() != 3783.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_modify() != 4850.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_parse_transfer_information() != 59253.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_statically_validate() != 42656.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_epoch_range() != 31430.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_notarized_payload_size() != 39564.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_tip_percentage() != 28981.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_message_validation() != 52946.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_min_tip_percentage() != 2069.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_network_id() != 63098.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_allow_all() != 26074.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_deny_all() != 40312.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require() != 10110.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_all_of() != 11748.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_amount() != 34714.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_any_of() != 30352.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_count_of() != 59472.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_virtual_signature() != 41270.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_from_raw() != 43797.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_new() != 37549.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_resource_address_from_olympia_resource_address() != 64771.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_account_address_from_olympia_address() != 31070.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_account_address_from_public_key() != 738.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_identity_address_from_public_key() != 32432.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_max() != 38313.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_min() != 18079.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_new() != 15617.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_one() != 42470.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_zero() != 39451.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_hex_string() != 64410.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_unhashed_bytes() != 17030.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_new() != 17594.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructions_from_instructions() != 51039.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructions_from_string() != 47420.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intent_decompile() != 565.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intent_new() != 4284.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_manifestbuilder_new() != 30710.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_messagevalidationconfig_default() != 54905.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_messagevalidationconfig_new() != 60275.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_from_parts() != 36478.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_new() != 58056.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_virtual_signature_badge() != 22546.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransaction_decompile() != 58667.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransaction_new() != 56154.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_olympiaaddress_new() != 12724.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_max() != 49495.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_min() != 4453.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_new() != 34846.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_one() != 9121.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_zero() != 5648.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new() != 47612.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new_ed25519() != 4005.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new_secp256k1() != 20991.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedintent_decompile() != 12765.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedintent_new() != 36392.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionbuilder_new() != 46196.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionhash_from_str() != 37610.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionmanifest_decompile() != 51209.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionmanifest_new() != 62865.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_validationconfig_default() != 1435.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_validationconfig_new() != 36594.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign() != 46892.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign_to_signature() != 15804.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign_to_signature_with_public_key() != 9393.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_public_key() != 61195.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// Public interface members begin here.


public object FfiConverterUByte: FfiConverter<UByte, Byte> {
    override fun lift(value: Byte): UByte {
        return value.toUByte()
    }

    override fun read(buf: ByteBuffer): UByte {
        return lift(buf.get())
    }

    override fun lower(value: UByte): Byte {
        return value.toByte()
    }

    override fun allocationSize(value: UByte) = 1

    override fun write(value: UByte, buf: ByteBuffer) {
        buf.put(value.toByte())
    }
}

public object FfiConverterByte: FfiConverter<Byte, Byte> {
    override fun lift(value: Byte): Byte {
        return value
    }

    override fun read(buf: ByteBuffer): Byte {
        return buf.get()
    }

    override fun lower(value: Byte): Byte {
        return value
    }

    override fun allocationSize(value: Byte) = 1

    override fun write(value: Byte, buf: ByteBuffer) {
        buf.put(value)
    }
}

public object FfiConverterUShort: FfiConverter<UShort, Short> {
    override fun lift(value: Short): UShort {
        return value.toUShort()
    }

    override fun read(buf: ByteBuffer): UShort {
        return lift(buf.getShort())
    }

    override fun lower(value: UShort): Short {
        return value.toShort()
    }

    override fun allocationSize(value: UShort) = 2

    override fun write(value: UShort, buf: ByteBuffer) {
        buf.putShort(value.toShort())
    }
}

public object FfiConverterShort: FfiConverter<Short, Short> {
    override fun lift(value: Short): Short {
        return value
    }

    override fun read(buf: ByteBuffer): Short {
        return buf.getShort()
    }

    override fun lower(value: Short): Short {
        return value
    }

    override fun allocationSize(value: Short) = 2

    override fun write(value: Short, buf: ByteBuffer) {
        buf.putShort(value)
    }
}

public object FfiConverterUInt: FfiConverter<UInt, Int> {
    override fun lift(value: Int): UInt {
        return value.toUInt()
    }

    override fun read(buf: ByteBuffer): UInt {
        return lift(buf.getInt())
    }

    override fun lower(value: UInt): Int {
        return value.toInt()
    }

    override fun allocationSize(value: UInt) = 4

    override fun write(value: UInt, buf: ByteBuffer) {
        buf.putInt(value.toInt())
    }
}

public object FfiConverterInt: FfiConverter<Int, Int> {
    override fun lift(value: Int): Int {
        return value
    }

    override fun read(buf: ByteBuffer): Int {
        return buf.getInt()
    }

    override fun lower(value: Int): Int {
        return value
    }

    override fun allocationSize(value: Int) = 4

    override fun write(value: Int, buf: ByteBuffer) {
        buf.putInt(value)
    }
}

public object FfiConverterULong: FfiConverter<ULong, Long> {
    override fun lift(value: Long): ULong {
        return value.toULong()
    }

    override fun read(buf: ByteBuffer): ULong {
        return lift(buf.getLong())
    }

    override fun lower(value: ULong): Long {
        return value.toLong()
    }

    override fun allocationSize(value: ULong) = 8

    override fun write(value: ULong, buf: ByteBuffer) {
        buf.putLong(value.toLong())
    }
}

public object FfiConverterLong: FfiConverter<Long, Long> {
    override fun lift(value: Long): Long {
        return value
    }

    override fun read(buf: ByteBuffer): Long {
        return buf.getLong()
    }

    override fun lower(value: Long): Long {
        return value
    }

    override fun allocationSize(value: Long) = 8

    override fun write(value: Long, buf: ByteBuffer) {
        buf.putLong(value)
    }
}

public object FfiConverterBoolean: FfiConverter<Boolean, Byte> {
    override fun lift(value: Byte): Boolean {
        return value.toInt() != 0
    }

    override fun read(buf: ByteBuffer): Boolean {
        return lift(buf.get())
    }

    override fun lower(value: Boolean): Byte {
        return if (value) 1.toByte() else 0.toByte()
    }

    override fun allocationSize(value: Boolean) = 1

    override fun write(value: Boolean, buf: ByteBuffer) {
        buf.put(lower(value))
    }
}

public object FfiConverterString: FfiConverter<String, RustBuffer.ByValue> {
    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    override fun lift(value: RustBuffer.ByValue): String {
        try {
            val byteArr = ByteArray(value.len)
            value.asByteBuffer()!!.get(byteArr)
            return byteArr.toString(Charsets.UTF_8)
        } finally {
            RustBuffer.free(value)
        }
    }

    override fun read(buf: ByteBuffer): String {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr.toString(Charsets.UTF_8)
    }

    fun toUtf8(value: String): ByteBuffer {
        // Make sure we don't have invalid UTF-16, check for lone surrogates.
        return Charsets.UTF_8.newEncoder().run {
            onMalformedInput(CodingErrorAction.REPORT)
            encode(CharBuffer.wrap(value))
        }
    }

    override fun lower(value: String): RustBuffer.ByValue {
        val byteBuf = toUtf8(value)
        // Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
        // to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
        val rbuf = RustBuffer.alloc(byteBuf.limit())
        rbuf.asByteBuffer()!!.put(byteBuf)
        return rbuf
    }

    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per UTF-16 code unit which will always be
    // enough.
    override fun allocationSize(value: String): Int {
        val sizeForLength = 4
        val sizeForString = value.length * 3
        return sizeForLength + sizeForString
    }

    override fun write(value: String, buf: ByteBuffer) {
        val byteBuf = toUtf8(value)
        buf.putInt(byteBuf.limit())
        buf.put(byteBuf)
    }
}


// Interface implemented by anything that can contain an object reference.
//
// Such types expose a `destroy()` method that must be called to cleanly
// dispose of the contained objects. Failure to call this method may result
// in memory leaks.
//
// The easiest way to ensure this method is called is to use the `.use`
// helper method to execute a block and destroy the object at the end.
interface Disposable {
    fun destroy()
    companion object {
        fun destroy(vararg args: Any?) {
            args.filterIsInstance<Disposable>()
                .forEach(Disposable::destroy)
        }
    }
}

inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
    try {
        block(this)
    } finally {
        try {
            // N.B. our implementation is on the nullable type `Disposable?`.
            this?.destroy()
        } catch (e: Throwable) {
            // swallow
        }
    }

// The base class for all UniFFI Object types.
//
// This class provides core operations for working with the Rust `Arc<T>` pointer to
// the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// the Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each `FFIObject` instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an `FFIObject` is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an `FFIObject` instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so will
//     leak the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each `FFIObject` an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// In the future we may be able to replace some of this with automatic finalization logic, such as using
// the new "Cleaner" functionaility in Java 9. The above scheme has been designed to work even if `destroy` is
// invoked by garbage-collection machinery rather than by calling code (which by the way, it's apparently also
// possible for the JVM to finalize an object while there is an in-flight call to one of its methods [1],
// so there would still be some complexity here).
//
// Sigh...all of this for want of a robust finalization mechanism.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//
abstract class FFIObject(
    protected val pointer: Pointer
): Disposable, AutoCloseable {

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    open protected fun freeRustArcPtr() {
        // To be overridden in subclasses.
    }

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                this.freeRustArcPtr()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.pointer)
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                this.freeRustArcPtr()
            }
        }
    }
}

public interface AccessRuleInterface {
    
    fun `and`(`other`: AccessRule): AccessRule
    fun `or`(`other`: AccessRule): AccessRule
}

class AccessRule(
    pointer: Pointer
) : FFIObject(pointer), AccessRuleInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_accessrule(this.pointer, status)
        }
    }

    override fun `and`(`other`: AccessRule): AccessRule =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_accessrule_and(it,
        FfiConverterTypeAccessRule.lower(`other`),
        _status)
}
        }.let {
            FfiConverterTypeAccessRule.lift(it)
        }
    
    override fun `or`(`other`: AccessRule): AccessRule =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_accessrule_or(it,
        FfiConverterTypeAccessRule.lower(`other`),
        _status)
}
        }.let {
            FfiConverterTypeAccessRule.lift(it)
        }
    
    

    companion object {
        fun `allowAll`(): AccessRule =
            AccessRule(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_allow_all(_status)
})
        fun `denyAll`(): AccessRule =
            AccessRule(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_deny_all(_status)
})
        fun `require`(`resourceOrNonFungible`: ResourceOrNonFungible): AccessRule =
            AccessRule(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require(FfiConverterTypeResourceOrNonFungible.lower(`resourceOrNonFungible`),_status)
})
        fun `requireAllOf`(`resources`: List<ResourceOrNonFungible>): AccessRule =
            AccessRule(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_all_of(FfiConverterSequenceTypeResourceOrNonFungible.lower(`resources`),_status)
})
        fun `requireAmount`(`amount`: Decimal, `resource`: Address): AccessRule =
            AccessRule(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_amount(FfiConverterTypeDecimal.lower(`amount`),FfiConverterTypeAddress.lower(`resource`),_status)
})
        fun `requireAnyOf`(`resources`: List<ResourceOrNonFungible>): AccessRule =
            AccessRule(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_any_of(FfiConverterSequenceTypeResourceOrNonFungible.lower(`resources`),_status)
})
        fun `requireCountOf`(`count`: UByte, `resources`: List<ResourceOrNonFungible>): AccessRule =
            AccessRule(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_count_of(FfiConverterUByte.lower(`count`),FfiConverterSequenceTypeResourceOrNonFungible.lower(`resources`),_status)
})
        fun `requireVirtualSignature`(`publicKey`: PublicKey): AccessRule =
            AccessRule(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_virtual_signature(FfiConverterTypePublicKey.lower(`publicKey`),_status)
})
        
    }
    
}

public object FfiConverterTypeAccessRule: FfiConverter<AccessRule, Pointer> {
    override fun lower(value: AccessRule): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): AccessRule {
        return AccessRule(value)
    }

    override fun read(buf: ByteBuffer): AccessRule {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: AccessRule) = 8

    override fun write(value: AccessRule, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface AddressInterface {
    
    fun `addressString`(): String
    fun `asStr`(): String
    fun `bytes`(): List<UByte>
    fun `entityType`(): EntityType
    fun `isGlobal`(): Boolean
    fun `isGlobalComponent`(): Boolean
    fun `isGlobalConsensusManager`(): Boolean
    fun `isGlobalFungibleResourceManager`(): Boolean
    fun `isGlobalNonFungibleResourceManager`(): Boolean
    fun `isGlobalPackage`(): Boolean
    fun `isGlobalResourceManager`(): Boolean
    fun `isGlobalVirtual`(): Boolean
    fun `isInternal`(): Boolean
    fun `isInternalFungibleVault`(): Boolean
    fun `isInternalKvStore`(): Boolean
    fun `isInternalNonFungibleVault`(): Boolean
    fun `isInternalVault`(): Boolean
    fun `networkId`(): UByte
}

class Address(
    pointer: Pointer
) : FFIObject(pointer), AddressInterface {
    constructor(`address`: String) :
        this(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_new(FfiConverterString.lower(`address`),_status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_address(this.pointer, status)
        }
    }

    override fun `addressString`(): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_address_address_string(it,
        
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    override fun `asStr`(): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_address_as_str(it,
        
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    override fun `bytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_address_bytes(it,
        
        _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    
    override fun `entityType`(): EntityType =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_address_entity_type(it,
        
        _status)
}
        }.let {
            FfiConverterTypeEntityType.lift(it)
        }
    
    override fun `isGlobal`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `isGlobalComponent`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_component(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `isGlobalConsensusManager`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_consensus_manager(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `isGlobalFungibleResourceManager`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_fungible_resource_manager(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `isGlobalNonFungibleResourceManager`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_non_fungible_resource_manager(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `isGlobalPackage`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_package(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `isGlobalResourceManager`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_resource_manager(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `isGlobalVirtual`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_virtual(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `isInternal`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `isInternalFungibleVault`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_fungible_vault(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `isInternalKvStore`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_kv_store(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `isInternalNonFungibleVault`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_non_fungible_vault(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `isInternalVault`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_vault(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `networkId`(): UByte =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_address_network_id(it,
        
        _status)
}
        }.let {
            FfiConverterUByte.lift(it)
        }
    
    

    companion object {
        fun `fromRaw`(`nodeIdBytes`: List<UByte>, `networkId`: UByte): Address =
            Address(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_from_raw(FfiConverterSequenceUByte.lower(`nodeIdBytes`),FfiConverterUByte.lower(`networkId`),_status)
})
        fun `resourceAddressFromOlympiaResourceAddress`(`olympiaResourceAddress`: OlympiaAddress, `networkId`: UByte): Address =
            Address(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_resource_address_from_olympia_resource_address(FfiConverterTypeOlympiaAddress.lower(`olympiaResourceAddress`),FfiConverterUByte.lower(`networkId`),_status)
})
        fun `virtualAccountAddressFromOlympiaAddress`(`olympiaAccountAddress`: OlympiaAddress, `networkId`: UByte): Address =
            Address(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_account_address_from_olympia_address(FfiConverterTypeOlympiaAddress.lower(`olympiaAccountAddress`),FfiConverterUByte.lower(`networkId`),_status)
})
        fun `virtualAccountAddressFromPublicKey`(`publicKey`: PublicKey, `networkId`: UByte): Address =
            Address(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_account_address_from_public_key(FfiConverterTypePublicKey.lower(`publicKey`),FfiConverterUByte.lower(`networkId`),_status)
})
        fun `virtualIdentityAddressFromPublicKey`(`publicKey`: PublicKey, `networkId`: UByte): Address =
            Address(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_identity_address_from_public_key(FfiConverterTypePublicKey.lower(`publicKey`),FfiConverterUByte.lower(`networkId`),_status)
})
        
    }
    
}

public object FfiConverterTypeAddress: FfiConverter<Address, Pointer> {
    override fun lower(value: Address): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): Address {
        return Address(value)
    }

    override fun read(buf: ByteBuffer): Address {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Address) = 8

    override fun write(value: Address, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface DecimalInterface {
    @Throws(RadixEngineToolkitException::class)
    fun `abs`(): Decimal@Throws(RadixEngineToolkitException::class)
    fun `add`(`other`: Decimal): Decimal
    fun `asStr`(): String@Throws(RadixEngineToolkitException::class)
    fun `cbrt`(): Decimal@Throws(RadixEngineToolkitException::class)
    fun `ceiling`(): Decimal@Throws(RadixEngineToolkitException::class)
    fun `div`(`other`: Decimal): Decimal
    fun `equal`(`other`: Decimal): Boolean@Throws(RadixEngineToolkitException::class)
    fun `floor`(): Decimal
    fun `greaterThan`(`other`: Decimal): Boolean
    fun `greaterThanOrEqual`(`other`: Decimal): Boolean
    fun `isNegative`(): Boolean
    fun `isPositive`(): Boolean
    fun `isZero`(): Boolean
    fun `lessThan`(`other`: Decimal): Boolean
    fun `lessThanOrEqual`(`other`: Decimal): Boolean
    fun `mantissa`(): String@Throws(RadixEngineToolkitException::class)
    fun `mul`(`other`: Decimal): Decimal
    fun `notEqual`(`other`: Decimal): Boolean
    fun `nthRoot`(`n`: UInt): Decimal?@Throws(RadixEngineToolkitException::class)
    fun `powi`(`exp`: Long): Decimal@Throws(RadixEngineToolkitException::class)
    fun `round`(`decimalPlaces`: Int, `roundingMode`: RoundingMode): Decimal
    fun `sqrt`(): Decimal?@Throws(RadixEngineToolkitException::class)
    fun `sub`(`other`: Decimal): Decimal
}

class Decimal(
    pointer: Pointer
) : FFIObject(pointer), DecimalInterface {
    constructor(`value`: String) :
        this(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_new(FfiConverterString.lower(`value`),_status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_decimal(this.pointer, status)
        }
    }

    
    @Throws(RadixEngineToolkitException::class)override fun `abs`(): Decimal =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_abs(it,
        
        _status)
}
        }.let {
            FfiConverterTypeDecimal.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `add`(`other`: Decimal): Decimal =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_add(it,
        FfiConverterTypeDecimal.lower(`other`),
        _status)
}
        }.let {
            FfiConverterTypeDecimal.lift(it)
        }
    
    override fun `asStr`(): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_as_str(it,
        
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `cbrt`(): Decimal =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_cbrt(it,
        
        _status)
}
        }.let {
            FfiConverterTypeDecimal.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `ceiling`(): Decimal =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_ceiling(it,
        
        _status)
}
        }.let {
            FfiConverterTypeDecimal.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `div`(`other`: Decimal): Decimal =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_div(it,
        FfiConverterTypeDecimal.lower(`other`),
        _status)
}
        }.let {
            FfiConverterTypeDecimal.lift(it)
        }
    
    override fun `equal`(`other`: Decimal): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_equal(it,
        FfiConverterTypeDecimal.lower(`other`),
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `floor`(): Decimal =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_floor(it,
        
        _status)
}
        }.let {
            FfiConverterTypeDecimal.lift(it)
        }
    
    override fun `greaterThan`(`other`: Decimal): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than(it,
        FfiConverterTypeDecimal.lower(`other`),
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `greaterThanOrEqual`(`other`: Decimal): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than_or_equal(it,
        FfiConverterTypeDecimal.lower(`other`),
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `isNegative`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_negative(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `isPositive`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_positive(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `isZero`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_zero(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `lessThan`(`other`: Decimal): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than(it,
        FfiConverterTypeDecimal.lower(`other`),
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `lessThanOrEqual`(`other`: Decimal): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than_or_equal(it,
        FfiConverterTypeDecimal.lower(`other`),
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `mantissa`(): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_mantissa(it,
        
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `mul`(`other`: Decimal): Decimal =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_mul(it,
        FfiConverterTypeDecimal.lower(`other`),
        _status)
}
        }.let {
            FfiConverterTypeDecimal.lift(it)
        }
    
    override fun `notEqual`(`other`: Decimal): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_not_equal(it,
        FfiConverterTypeDecimal.lower(`other`),
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `nthRoot`(`n`: UInt): Decimal? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_nth_root(it,
        FfiConverterUInt.lower(`n`),
        _status)
}
        }.let {
            FfiConverterOptionalTypeDecimal.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `powi`(`exp`: Long): Decimal =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_powi(it,
        FfiConverterLong.lower(`exp`),
        _status)
}
        }.let {
            FfiConverterTypeDecimal.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `round`(`decimalPlaces`: Int, `roundingMode`: RoundingMode): Decimal =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_round(it,
        FfiConverterInt.lower(`decimalPlaces`),FfiConverterTypeRoundingMode.lower(`roundingMode`),
        _status)
}
        }.let {
            FfiConverterTypeDecimal.lift(it)
        }
    
    override fun `sqrt`(): Decimal? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sqrt(it,
        
        _status)
}
        }.let {
            FfiConverterOptionalTypeDecimal.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `sub`(`other`: Decimal): Decimal =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sub(it,
        FfiConverterTypeDecimal.lower(`other`),
        _status)
}
        }.let {
            FfiConverterTypeDecimal.lift(it)
        }
    
    

    companion object {
        fun `max`(): Decimal =
            Decimal(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_max(_status)
})
        fun `min`(): Decimal =
            Decimal(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_min(_status)
})
        fun `one`(): Decimal =
            Decimal(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_one(_status)
})
        fun `zero`(): Decimal =
            Decimal(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_zero(_status)
})
        
    }
    
}

public object FfiConverterTypeDecimal: FfiConverter<Decimal, Pointer> {
    override fun lower(value: Decimal): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): Decimal {
        return Decimal(value)
    }

    override fun read(buf: ByteBuffer): Decimal {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Decimal) = 8

    override fun write(value: Decimal, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface HashInterface {
    
    fun `asStr`(): String
    fun `bytes`(): List<UByte>
}

class Hash(
    pointer: Pointer
) : FFIObject(pointer), HashInterface {
    constructor(`hash`: List<UByte>) :
        this(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_new(FfiConverterSequenceUByte.lower(`hash`),_status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_hash(this.pointer, status)
        }
    }

    override fun `asStr`(): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_hash_as_str(it,
        
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    override fun `bytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_hash_bytes(it,
        
        _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    
    

    companion object {
        fun `fromHexString`(`hash`: String): Hash =
            Hash(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_hex_string(FfiConverterString.lower(`hash`),_status)
})
        fun `fromUnhashedBytes`(`bytes`: List<UByte>): Hash =
            Hash(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_unhashed_bytes(FfiConverterSequenceUByte.lower(`bytes`),_status)
})
        
    }
    
}

public object FfiConverterTypeHash: FfiConverter<Hash, Pointer> {
    override fun lower(value: Hash): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): Hash {
        return Hash(value)
    }

    override fun read(buf: ByteBuffer): Hash {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Hash) = 8

    override fun write(value: Hash, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface InstructionsInterface {
    @Throws(RadixEngineToolkitException::class)
    fun `asStr`(): String
    fun `instructionsList`(): List<Instruction>
    fun `networkId`(): UByte
}

class Instructions(
    pointer: Pointer
) : FFIObject(pointer), InstructionsInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_instructions(this.pointer, status)
        }
    }

    
    @Throws(RadixEngineToolkitException::class)override fun `asStr`(): String =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_as_str(it,
        
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    override fun `instructionsList`(): List<Instruction> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_instructions_list(it,
        
        _status)
}
        }.let {
            FfiConverterSequenceTypeInstruction.lift(it)
        }
    
    override fun `networkId`(): UByte =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_network_id(it,
        
        _status)
}
        }.let {
            FfiConverterUByte.lift(it)
        }
    
    

    companion object {
        fun `fromInstructions`(`instructions`: List<Instruction>, `networkId`: UByte): Instructions =
            Instructions(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructions_from_instructions(FfiConverterSequenceTypeInstruction.lower(`instructions`),FfiConverterUByte.lower(`networkId`),_status)
})
        fun `fromString`(`string`: String, `networkId`: UByte): Instructions =
            Instructions(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructions_from_string(FfiConverterString.lower(`string`),FfiConverterUByte.lower(`networkId`),_status)
})
        
    }
    
}

public object FfiConverterTypeInstructions: FfiConverter<Instructions, Pointer> {
    override fun lower(value: Instructions): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): Instructions {
        return Instructions(value)
    }

    override fun read(buf: ByteBuffer): Instructions {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Instructions) = 8

    override fun write(value: Instructions, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface IntentInterface {
    @Throws(RadixEngineToolkitException::class)
    fun `compile`(): List<UByte>@Throws(RadixEngineToolkitException::class)
    fun `hash`(): TransactionHash
    fun `header`(): TransactionHeader@Throws(RadixEngineToolkitException::class)
    fun `intentHash`(): TransactionHash
    fun `manifest`(): TransactionManifest
    fun `message`(): Message@Throws(RadixEngineToolkitException::class)
    fun `staticallyValidate`(`validationConfig`: ValidationConfig)
}

class Intent(
    pointer: Pointer
) : FFIObject(pointer), IntentInterface {
    constructor(`header`: TransactionHeader, `manifest`: TransactionManifest, `message`: Message) :
        this(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_intent_new(FfiConverterTypeTransactionHeader.lower(`header`),FfiConverterTypeTransactionManifest.lower(`manifest`),FfiConverterTypeMessage.lower(`message`),_status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_intent(this.pointer, status)
        }
    }

    
    @Throws(RadixEngineToolkitException::class)override fun `compile`(): List<UByte> =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_compile(it,
        
        _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `hash`(): TransactionHash =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_hash(it,
        
        _status)
}
        }.let {
            FfiConverterTypeTransactionHash.lift(it)
        }
    
    override fun `header`(): TransactionHeader =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_header(it,
        
        _status)
}
        }.let {
            FfiConverterTypeTransactionHeader.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `intentHash`(): TransactionHash =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_intent_hash(it,
        
        _status)
}
        }.let {
            FfiConverterTypeTransactionHash.lift(it)
        }
    
    override fun `manifest`(): TransactionManifest =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_manifest(it,
        
        _status)
}
        }.let {
            FfiConverterTypeTransactionManifest.lift(it)
        }
    
    override fun `message`(): Message =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_message(it,
        
        _status)
}
        }.let {
            FfiConverterTypeMessage.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `staticallyValidate`(`validationConfig`: ValidationConfig) =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_statically_validate(it,
        FfiConverterTypeValidationConfig.lower(`validationConfig`),
        _status)
}
        }
    
    
    

    companion object {
        fun `decompile`(`compiledIntent`: List<UByte>): Intent =
            Intent(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_intent_decompile(FfiConverterSequenceUByte.lower(`compiledIntent`),_status)
})
        
    }
    
}

public object FfiConverterTypeIntent: FfiConverter<Intent, Pointer> {
    override fun lower(value: Intent): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): Intent {
        return Intent(value)
    }

    override fun read(buf: ByteBuffer): Intent {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Intent) = 8

    override fun write(value: Intent, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ManifestBuilderInterface {
    @Throws(RadixEngineToolkitException::class)
    fun `accessControllerInitiateRecovery`(`accessControllerAddress`: Address, `proposer`: Proposer, `proposedPrimaryRole`: AccessRule, `proposedRecoveryRole`: AccessRule, `proposedConfirmationRole`: AccessRule, `proposedTimedRecoveryDelayInMinutes`: UInt?): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `accessControllerQuickConfirmRecovery`(`accessControllerAddress`: Address, `proposer`: Proposer, `proposedPrimaryRole`: AccessRule, `proposedRecoveryRole`: AccessRule, `proposedConfirmationRole`: AccessRule, `proposedTimedRecoveryDelayInMinutes`: UInt?): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `accountDeposit`(`accountAddress`: Address, `bucket`: ManifestBuilderBucket): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `accountDepositBatch`(`accountAddress`: Address): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `accountTryDepositBatchOrAbort`(`accountAddress`: Address, `authorizedDepositorBadge`: ResourceOrNonFungible?): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `accountTryDepositBatchOrRefund`(`accountAddress`: Address, `authorizedDepositorBadge`: ResourceOrNonFungible?): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `accountTryDepositOrAbort`(`accountAddress`: Address, `authorizedDepositorBadge`: ResourceOrNonFungible?, `bucket`: ManifestBuilderBucket): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `accountTryDepositOrRefund`(`accountAddress`: Address, `authorizedDepositorBadge`: ResourceOrNonFungible?, `bucket`: ManifestBuilderBucket): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `allocateGlobalAddress`(`packageAddress`: Address, `blueprintName`: String, `intoAddressReservation`: ManifestBuilderAddressReservation, `intoNamedAddress`: ManifestBuilderNamedAddress): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `assertWorktopContains`(`resourceAddress`: Address, `amount`: Decimal): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `assertWorktopContainsAny`(`resourceAddress`: Address): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `assertWorktopContainsNonFungibles`(`resourceAddress`: Address, `ids`: List<NonFungibleLocalId>): ManifestBuilder
    fun `build`(`networkId`: UByte): TransactionManifest@Throws(RadixEngineToolkitException::class)
    fun `burnResource`(`bucket`: ManifestBuilderBucket): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `callAccessRulesMethod`(`address`: ManifestBuilderAddress, `methodName`: String, `args`: List<ManifestBuilderValue>): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `callDirectVaultMethod`(`address`: Address, `methodName`: String, `args`: List<ManifestBuilderValue>): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `callFunction`(`address`: ManifestBuilderAddress, `blueprintName`: String, `functionName`: String, `args`: List<ManifestBuilderValue>): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `callMetadataMethod`(`address`: ManifestBuilderAddress, `methodName`: String, `args`: List<ManifestBuilderValue>): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `callMethod`(`address`: ManifestBuilderAddress, `methodName`: String, `args`: List<ManifestBuilderValue>): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `callRoyaltyMethod`(`address`: ManifestBuilderAddress, `methodName`: String, `args`: List<ManifestBuilderValue>): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `cloneProof`(`proof`: ManifestBuilderProof, `intoProof`: ManifestBuilderProof): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `createAccessControllerWithSecurifyStructure`(`controlledAsset`: ManifestBuilderBucket, `primaryRole`: SecurityStructureRole, `recoveryRole`: SecurityStructureRole, `confirmationRole`: SecurityStructureRole, `timedRecoveryDelayInMinutes`: UInt?, `addressReservation`: ManifestBuilderAddressReservation?): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `createAccountAdvanced`(`ownerRole`: OwnerRole): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `createFungibleResourceManager`(`ownerRole`: OwnerRole, `trackTotalSupply`: Boolean, `divisibility`: UByte, `initialSupply`: Decimal?, `resourceRoles`: FungibleResourceRoles, `metadata`: MetadataModuleConfig, `addressReservation`: ManifestBuilderAddressReservation?): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `createProofFromAuthZoneOfAll`(`resourceAddress`: Address, `intoProof`: ManifestBuilderProof): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `createProofFromAuthZoneOfAmount`(`resourceAddress`: Address, `amount`: Decimal, `intoProof`: ManifestBuilderProof): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `createProofFromAuthZoneOfNonFungibles`(`resourceAddress`: Address, `ids`: List<NonFungibleLocalId>, `intoProof`: ManifestBuilderProof): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `createProofFromBucketOfAll`(`bucket`: ManifestBuilderBucket, `intoProof`: ManifestBuilderProof): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `createProofFromBucketOfAmount`(`amount`: Decimal, `bucket`: ManifestBuilderBucket, `intoProof`: ManifestBuilderProof): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `createProofFromBucketOfNonFungibles`(`ids`: List<NonFungibleLocalId>, `bucket`: ManifestBuilderBucket, `intoProof`: ManifestBuilderProof): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `createSignatureBasedAccessController`(`controlledAsset`: ManifestBuilderBucket, `primaryRole`: PublicKey, `recoveryRole`: PublicKey, `confirmationRole`: PublicKey, `timedRecoveryDelayInMinutes`: UInt?, `addressReservation`: ManifestBuilderAddressReservation?): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `dropAllProofs`(): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `dropAuthZoneProofs`(): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `dropAuthZoneSignatureProofs`(): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `dropProof`(`proof`: ManifestBuilderProof): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `faucetFreeXrd`(): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `faucetLockFee`(): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `mintFungible`(`resourceAddress`: Address, `amount`: Decimal): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `popFromAuthZone`(`intoProof`: ManifestBuilderProof): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `publishPackage`(`code`: List<UByte>, `definition`: List<UByte>, `metadata`: Map<String, MetadataInitEntry>): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `pushToAuthZone`(`proof`: ManifestBuilderProof): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `returnToWorktop`(`bucket`: ManifestBuilderBucket): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `setMetadata`(`address`: Address, `key`: String, `value`: MetadataValue): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `setRole`(`address`: Address, `module`: ObjectModuleId, `roleKey`: String, `rule`: AccessRule): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `takeAllFromWorktop`(`resourceAddress`: Address, `intoBucket`: ManifestBuilderBucket): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `takeFromWorktop`(`resourceAddress`: Address, `amount`: Decimal, `intoBucket`: ManifestBuilderBucket): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `takeNonFungiblesFromWorktop`(`resourceAddress`: Address, `ids`: List<NonFungibleLocalId>, `intoBucket`: ManifestBuilderBucket): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `withdrawFromAccount`(`accountAddress`: Address, `resourceAddress`: Address, `amount`: Decimal): ManifestBuilder@Throws(RadixEngineToolkitException::class)
    fun `withdrawNonFungiblesFromAccount`(`accountAddress`: Address, `resourceAddress`: Address, `ids`: List<NonFungibleLocalId>): ManifestBuilder
}

class ManifestBuilder(
    pointer: Pointer
) : FFIObject(pointer), ManifestBuilderInterface {
    constructor() :
        this(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_manifestbuilder_new(_status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_manifestbuilder(this.pointer, status)
        }
    }

    
    @Throws(RadixEngineToolkitException::class)override fun `accessControllerInitiateRecovery`(`accessControllerAddress`: Address, `proposer`: Proposer, `proposedPrimaryRole`: AccessRule, `proposedRecoveryRole`: AccessRule, `proposedConfirmationRole`: AccessRule, `proposedTimedRecoveryDelayInMinutes`: UInt?): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_initiate_recovery(it,
        FfiConverterTypeAddress.lower(`accessControllerAddress`),FfiConverterTypeProposer.lower(`proposer`),FfiConverterTypeAccessRule.lower(`proposedPrimaryRole`),FfiConverterTypeAccessRule.lower(`proposedRecoveryRole`),FfiConverterTypeAccessRule.lower(`proposedConfirmationRole`),FfiConverterOptionalUInt.lower(`proposedTimedRecoveryDelayInMinutes`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `accessControllerQuickConfirmRecovery`(`accessControllerAddress`: Address, `proposer`: Proposer, `proposedPrimaryRole`: AccessRule, `proposedRecoveryRole`: AccessRule, `proposedConfirmationRole`: AccessRule, `proposedTimedRecoveryDelayInMinutes`: UInt?): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_access_controller_quick_confirm_recovery(it,
        FfiConverterTypeAddress.lower(`accessControllerAddress`),FfiConverterTypeProposer.lower(`proposer`),FfiConverterTypeAccessRule.lower(`proposedPrimaryRole`),FfiConverterTypeAccessRule.lower(`proposedRecoveryRole`),FfiConverterTypeAccessRule.lower(`proposedConfirmationRole`),FfiConverterOptionalUInt.lower(`proposedTimedRecoveryDelayInMinutes`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `accountDeposit`(`accountAddress`: Address, `bucket`: ManifestBuilderBucket): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit(it,
        FfiConverterTypeAddress.lower(`accountAddress`),FfiConverterTypeManifestBuilderBucket.lower(`bucket`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `accountDepositBatch`(`accountAddress`: Address): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit_batch(it,
        FfiConverterTypeAddress.lower(`accountAddress`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `accountTryDepositBatchOrAbort`(`accountAddress`: Address, `authorizedDepositorBadge`: ResourceOrNonFungible?): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_batch_or_abort(it,
        FfiConverterTypeAddress.lower(`accountAddress`),FfiConverterOptionalTypeResourceOrNonFungible.lower(`authorizedDepositorBadge`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `accountTryDepositBatchOrRefund`(`accountAddress`: Address, `authorizedDepositorBadge`: ResourceOrNonFungible?): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_batch_or_refund(it,
        FfiConverterTypeAddress.lower(`accountAddress`),FfiConverterOptionalTypeResourceOrNonFungible.lower(`authorizedDepositorBadge`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `accountTryDepositOrAbort`(`accountAddress`: Address, `authorizedDepositorBadge`: ResourceOrNonFungible?, `bucket`: ManifestBuilderBucket): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_or_abort(it,
        FfiConverterTypeAddress.lower(`accountAddress`),FfiConverterOptionalTypeResourceOrNonFungible.lower(`authorizedDepositorBadge`),FfiConverterTypeManifestBuilderBucket.lower(`bucket`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `accountTryDepositOrRefund`(`accountAddress`: Address, `authorizedDepositorBadge`: ResourceOrNonFungible?, `bucket`: ManifestBuilderBucket): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_or_refund(it,
        FfiConverterTypeAddress.lower(`accountAddress`),FfiConverterOptionalTypeResourceOrNonFungible.lower(`authorizedDepositorBadge`),FfiConverterTypeManifestBuilderBucket.lower(`bucket`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `allocateGlobalAddress`(`packageAddress`: Address, `blueprintName`: String, `intoAddressReservation`: ManifestBuilderAddressReservation, `intoNamedAddress`: ManifestBuilderNamedAddress): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_allocate_global_address(it,
        FfiConverterTypeAddress.lower(`packageAddress`),FfiConverterString.lower(`blueprintName`),FfiConverterTypeManifestBuilderAddressReservation.lower(`intoAddressReservation`),FfiConverterTypeManifestBuilderNamedAddress.lower(`intoNamedAddress`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `assertWorktopContains`(`resourceAddress`: Address, `amount`: Decimal): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains(it,
        FfiConverterTypeAddress.lower(`resourceAddress`),FfiConverterTypeDecimal.lower(`amount`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `assertWorktopContainsAny`(`resourceAddress`: Address): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains_any(it,
        FfiConverterTypeAddress.lower(`resourceAddress`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `assertWorktopContainsNonFungibles`(`resourceAddress`: Address, `ids`: List<NonFungibleLocalId>): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains_non_fungibles(it,
        FfiConverterTypeAddress.lower(`resourceAddress`),FfiConverterSequenceTypeNonFungibleLocalId.lower(`ids`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    override fun `build`(`networkId`: UByte): TransactionManifest =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_build(it,
        FfiConverterUByte.lower(`networkId`),
        _status)
}
        }.let {
            FfiConverterTypeTransactionManifest.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `burnResource`(`bucket`: ManifestBuilderBucket): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_burn_resource(it,
        FfiConverterTypeManifestBuilderBucket.lower(`bucket`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `callAccessRulesMethod`(`address`: ManifestBuilderAddress, `methodName`: String, `args`: List<ManifestBuilderValue>): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_access_rules_method(it,
        FfiConverterTypeManifestBuilderAddress.lower(`address`),FfiConverterString.lower(`methodName`),FfiConverterSequenceTypeManifestBuilderValue.lower(`args`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `callDirectVaultMethod`(`address`: Address, `methodName`: String, `args`: List<ManifestBuilderValue>): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_direct_vault_method(it,
        FfiConverterTypeAddress.lower(`address`),FfiConverterString.lower(`methodName`),FfiConverterSequenceTypeManifestBuilderValue.lower(`args`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `callFunction`(`address`: ManifestBuilderAddress, `blueprintName`: String, `functionName`: String, `args`: List<ManifestBuilderValue>): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_function(it,
        FfiConverterTypeManifestBuilderAddress.lower(`address`),FfiConverterString.lower(`blueprintName`),FfiConverterString.lower(`functionName`),FfiConverterSequenceTypeManifestBuilderValue.lower(`args`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `callMetadataMethod`(`address`: ManifestBuilderAddress, `methodName`: String, `args`: List<ManifestBuilderValue>): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_metadata_method(it,
        FfiConverterTypeManifestBuilderAddress.lower(`address`),FfiConverterString.lower(`methodName`),FfiConverterSequenceTypeManifestBuilderValue.lower(`args`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `callMethod`(`address`: ManifestBuilderAddress, `methodName`: String, `args`: List<ManifestBuilderValue>): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_method(it,
        FfiConverterTypeManifestBuilderAddress.lower(`address`),FfiConverterString.lower(`methodName`),FfiConverterSequenceTypeManifestBuilderValue.lower(`args`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `callRoyaltyMethod`(`address`: ManifestBuilderAddress, `methodName`: String, `args`: List<ManifestBuilderValue>): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_royalty_method(it,
        FfiConverterTypeManifestBuilderAddress.lower(`address`),FfiConverterString.lower(`methodName`),FfiConverterSequenceTypeManifestBuilderValue.lower(`args`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `cloneProof`(`proof`: ManifestBuilderProof, `intoProof`: ManifestBuilderProof): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_clone_proof(it,
        FfiConverterTypeManifestBuilderProof.lower(`proof`),FfiConverterTypeManifestBuilderProof.lower(`intoProof`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `createAccessControllerWithSecurifyStructure`(`controlledAsset`: ManifestBuilderBucket, `primaryRole`: SecurityStructureRole, `recoveryRole`: SecurityStructureRole, `confirmationRole`: SecurityStructureRole, `timedRecoveryDelayInMinutes`: UInt?, `addressReservation`: ManifestBuilderAddressReservation?): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_access_controller_with_securify_structure(it,
        FfiConverterTypeManifestBuilderBucket.lower(`controlledAsset`),FfiConverterTypeSecurityStructureRole.lower(`primaryRole`),FfiConverterTypeSecurityStructureRole.lower(`recoveryRole`),FfiConverterTypeSecurityStructureRole.lower(`confirmationRole`),FfiConverterOptionalUInt.lower(`timedRecoveryDelayInMinutes`),FfiConverterOptionalTypeManifestBuilderAddressReservation.lower(`addressReservation`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `createAccountAdvanced`(`ownerRole`: OwnerRole): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_account_advanced(it,
        FfiConverterTypeOwnerRole.lower(`ownerRole`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `createFungibleResourceManager`(`ownerRole`: OwnerRole, `trackTotalSupply`: Boolean, `divisibility`: UByte, `initialSupply`: Decimal?, `resourceRoles`: FungibleResourceRoles, `metadata`: MetadataModuleConfig, `addressReservation`: ManifestBuilderAddressReservation?): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_fungible_resource_manager(it,
        FfiConverterTypeOwnerRole.lower(`ownerRole`),FfiConverterBoolean.lower(`trackTotalSupply`),FfiConverterUByte.lower(`divisibility`),FfiConverterOptionalTypeDecimal.lower(`initialSupply`),FfiConverterTypeFungibleResourceRoles.lower(`resourceRoles`),FfiConverterTypeMetadataModuleConfig.lower(`metadata`),FfiConverterOptionalTypeManifestBuilderAddressReservation.lower(`addressReservation`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `createProofFromAuthZoneOfAll`(`resourceAddress`: Address, `intoProof`: ManifestBuilderProof): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_all(it,
        FfiConverterTypeAddress.lower(`resourceAddress`),FfiConverterTypeManifestBuilderProof.lower(`intoProof`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `createProofFromAuthZoneOfAmount`(`resourceAddress`: Address, `amount`: Decimal, `intoProof`: ManifestBuilderProof): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_amount(it,
        FfiConverterTypeAddress.lower(`resourceAddress`),FfiConverterTypeDecimal.lower(`amount`),FfiConverterTypeManifestBuilderProof.lower(`intoProof`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `createProofFromAuthZoneOfNonFungibles`(`resourceAddress`: Address, `ids`: List<NonFungibleLocalId>, `intoProof`: ManifestBuilderProof): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_non_fungibles(it,
        FfiConverterTypeAddress.lower(`resourceAddress`),FfiConverterSequenceTypeNonFungibleLocalId.lower(`ids`),FfiConverterTypeManifestBuilderProof.lower(`intoProof`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `createProofFromBucketOfAll`(`bucket`: ManifestBuilderBucket, `intoProof`: ManifestBuilderProof): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_all(it,
        FfiConverterTypeManifestBuilderBucket.lower(`bucket`),FfiConverterTypeManifestBuilderProof.lower(`intoProof`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `createProofFromBucketOfAmount`(`amount`: Decimal, `bucket`: ManifestBuilderBucket, `intoProof`: ManifestBuilderProof): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_amount(it,
        FfiConverterTypeDecimal.lower(`amount`),FfiConverterTypeManifestBuilderBucket.lower(`bucket`),FfiConverterTypeManifestBuilderProof.lower(`intoProof`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `createProofFromBucketOfNonFungibles`(`ids`: List<NonFungibleLocalId>, `bucket`: ManifestBuilderBucket, `intoProof`: ManifestBuilderProof): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_non_fungibles(it,
        FfiConverterSequenceTypeNonFungibleLocalId.lower(`ids`),FfiConverterTypeManifestBuilderBucket.lower(`bucket`),FfiConverterTypeManifestBuilderProof.lower(`intoProof`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `createSignatureBasedAccessController`(`controlledAsset`: ManifestBuilderBucket, `primaryRole`: PublicKey, `recoveryRole`: PublicKey, `confirmationRole`: PublicKey, `timedRecoveryDelayInMinutes`: UInt?, `addressReservation`: ManifestBuilderAddressReservation?): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_signature_based_access_controller(it,
        FfiConverterTypeManifestBuilderBucket.lower(`controlledAsset`),FfiConverterTypePublicKey.lower(`primaryRole`),FfiConverterTypePublicKey.lower(`recoveryRole`),FfiConverterTypePublicKey.lower(`confirmationRole`),FfiConverterOptionalUInt.lower(`timedRecoveryDelayInMinutes`),FfiConverterOptionalTypeManifestBuilderAddressReservation.lower(`addressReservation`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `dropAllProofs`(): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_all_proofs(it,
        
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `dropAuthZoneProofs`(): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_auth_zone_proofs(it,
        
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `dropAuthZoneSignatureProofs`(): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_auth_zone_signature_proofs(it,
        
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `dropProof`(`proof`: ManifestBuilderProof): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_proof(it,
        FfiConverterTypeManifestBuilderProof.lower(`proof`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `faucetFreeXrd`(): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_faucet_free_xrd(it,
        
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `faucetLockFee`(): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_faucet_lock_fee(it,
        
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `mintFungible`(`resourceAddress`: Address, `amount`: Decimal): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_mint_fungible(it,
        FfiConverterTypeAddress.lower(`resourceAddress`),FfiConverterTypeDecimal.lower(`amount`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `popFromAuthZone`(`intoProof`: ManifestBuilderProof): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_pop_from_auth_zone(it,
        FfiConverterTypeManifestBuilderProof.lower(`intoProof`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `publishPackage`(`code`: List<UByte>, `definition`: List<UByte>, `metadata`: Map<String, MetadataInitEntry>): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_publish_package(it,
        FfiConverterSequenceUByte.lower(`code`),FfiConverterSequenceUByte.lower(`definition`),FfiConverterMapStringTypeMetadataInitEntry.lower(`metadata`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `pushToAuthZone`(`proof`: ManifestBuilderProof): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_push_to_auth_zone(it,
        FfiConverterTypeManifestBuilderProof.lower(`proof`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `returnToWorktop`(`bucket`: ManifestBuilderBucket): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_return_to_worktop(it,
        FfiConverterTypeManifestBuilderBucket.lower(`bucket`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `setMetadata`(`address`: Address, `key`: String, `value`: MetadataValue): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_set_metadata(it,
        FfiConverterTypeAddress.lower(`address`),FfiConverterString.lower(`key`),FfiConverterTypeMetadataValue.lower(`value`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `setRole`(`address`: Address, `module`: ObjectModuleId, `roleKey`: String, `rule`: AccessRule): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_set_role(it,
        FfiConverterTypeAddress.lower(`address`),FfiConverterTypeObjectModuleId.lower(`module`),FfiConverterString.lower(`roleKey`),FfiConverterTypeAccessRule.lower(`rule`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `takeAllFromWorktop`(`resourceAddress`: Address, `intoBucket`: ManifestBuilderBucket): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_all_from_worktop(it,
        FfiConverterTypeAddress.lower(`resourceAddress`),FfiConverterTypeManifestBuilderBucket.lower(`intoBucket`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `takeFromWorktop`(`resourceAddress`: Address, `amount`: Decimal, `intoBucket`: ManifestBuilderBucket): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_from_worktop(it,
        FfiConverterTypeAddress.lower(`resourceAddress`),FfiConverterTypeDecimal.lower(`amount`),FfiConverterTypeManifestBuilderBucket.lower(`intoBucket`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `takeNonFungiblesFromWorktop`(`resourceAddress`: Address, `ids`: List<NonFungibleLocalId>, `intoBucket`: ManifestBuilderBucket): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_non_fungibles_from_worktop(it,
        FfiConverterTypeAddress.lower(`resourceAddress`),FfiConverterSequenceTypeNonFungibleLocalId.lower(`ids`),FfiConverterTypeManifestBuilderBucket.lower(`intoBucket`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `withdrawFromAccount`(`accountAddress`: Address, `resourceAddress`: Address, `amount`: Decimal): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_withdraw_from_account(it,
        FfiConverterTypeAddress.lower(`accountAddress`),FfiConverterTypeAddress.lower(`resourceAddress`),FfiConverterTypeDecimal.lower(`amount`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `withdrawNonFungiblesFromAccount`(`accountAddress`: Address, `resourceAddress`: Address, `ids`: List<NonFungibleLocalId>): ManifestBuilder =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_withdraw_non_fungibles_from_account(it,
        FfiConverterTypeAddress.lower(`accountAddress`),FfiConverterTypeAddress.lower(`resourceAddress`),FfiConverterSequenceTypeNonFungibleLocalId.lower(`ids`),
        _status)
}
        }.let {
            FfiConverterTypeManifestBuilder.lift(it)
        }
    
    

    
}

public object FfiConverterTypeManifestBuilder: FfiConverter<ManifestBuilder, Pointer> {
    override fun lower(value: ManifestBuilder): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ManifestBuilder {
        return ManifestBuilder(value)
    }

    override fun read(buf: ByteBuffer): ManifestBuilder {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ManifestBuilder) = 8

    override fun write(value: ManifestBuilder, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface MessageValidationConfigInterface {
    
    fun `maxDecryptors`(): ULong
    fun `maxEncryptedMessageLength`(): ULong
    fun `maxMimeTypeLength`(): ULong
    fun `maxPlaintextMessageLength`(): ULong
}

class MessageValidationConfig(
    pointer: Pointer
) : FFIObject(pointer), MessageValidationConfigInterface {
    constructor(`maxPlaintextMessageLength`: ULong, `maxEncryptedMessageLength`: ULong, `maxMimeTypeLength`: ULong, `maxDecryptors`: ULong) :
        this(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_messagevalidationconfig_new(FfiConverterULong.lower(`maxPlaintextMessageLength`),FfiConverterULong.lower(`maxEncryptedMessageLength`),FfiConverterULong.lower(`maxMimeTypeLength`),FfiConverterULong.lower(`maxDecryptors`),_status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_messagevalidationconfig(this.pointer, status)
        }
    }

    override fun `maxDecryptors`(): ULong =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_decryptors(it,
        
        _status)
}
        }.let {
            FfiConverterULong.lift(it)
        }
    
    override fun `maxEncryptedMessageLength`(): ULong =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_encrypted_message_length(it,
        
        _status)
}
        }.let {
            FfiConverterULong.lift(it)
        }
    
    override fun `maxMimeTypeLength`(): ULong =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_mime_type_length(it,
        
        _status)
}
        }.let {
            FfiConverterULong.lift(it)
        }
    
    override fun `maxPlaintextMessageLength`(): ULong =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_plaintext_message_length(it,
        
        _status)
}
        }.let {
            FfiConverterULong.lift(it)
        }
    
    

    companion object {
        fun `default`(): MessageValidationConfig =
            MessageValidationConfig(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_messagevalidationconfig_default(_status)
})
        
    }
    
}

public object FfiConverterTypeMessageValidationConfig: FfiConverter<MessageValidationConfig, Pointer> {
    override fun lower(value: MessageValidationConfig): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): MessageValidationConfig {
        return MessageValidationConfig(value)
    }

    override fun read(buf: ByteBuffer): MessageValidationConfig {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: MessageValidationConfig) = 8

    override fun write(value: MessageValidationConfig, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface NonFungibleGlobalIdInterface {
    
    fun `asStr`(): String
    fun `localId`(): NonFungibleLocalId
    fun `resourceAddress`(): Address
}

class NonFungibleGlobalId(
    pointer: Pointer
) : FFIObject(pointer), NonFungibleGlobalIdInterface {
    constructor(`nonFungibleGlobalId`: String) :
        this(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_new(FfiConverterString.lower(`nonFungibleGlobalId`),_status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_nonfungibleglobalid(this.pointer, status)
        }
    }

    override fun `asStr`(): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_as_str(it,
        
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    override fun `localId`(): NonFungibleLocalId =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_local_id(it,
        
        _status)
}
        }.let {
            FfiConverterTypeNonFungibleLocalId.lift(it)
        }
    
    override fun `resourceAddress`(): Address =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_resource_address(it,
        
        _status)
}
        }.let {
            FfiConverterTypeAddress.lift(it)
        }
    
    

    companion object {
        fun `fromParts`(`resourceAddress`: Address, `nonFungibleLocalId`: NonFungibleLocalId): NonFungibleGlobalId =
            NonFungibleGlobalId(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_from_parts(FfiConverterTypeAddress.lower(`resourceAddress`),FfiConverterTypeNonFungibleLocalId.lower(`nonFungibleLocalId`),_status)
})
        fun `virtualSignatureBadge`(`publicKey`: PublicKey, `networkId`: UByte): NonFungibleGlobalId =
            NonFungibleGlobalId(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_virtual_signature_badge(FfiConverterTypePublicKey.lower(`publicKey`),FfiConverterUByte.lower(`networkId`),_status)
})
        
    }
    
}

public object FfiConverterTypeNonFungibleGlobalId: FfiConverter<NonFungibleGlobalId, Pointer> {
    override fun lower(value: NonFungibleGlobalId): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): NonFungibleGlobalId {
        return NonFungibleGlobalId(value)
    }

    override fun read(buf: ByteBuffer): NonFungibleGlobalId {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: NonFungibleGlobalId) = 8

    override fun write(value: NonFungibleGlobalId, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface NotarizedTransactionInterface {
    @Throws(RadixEngineToolkitException::class)
    fun `compile`(): List<UByte>@Throws(RadixEngineToolkitException::class)
    fun `hash`(): TransactionHash@Throws(RadixEngineToolkitException::class)
    fun `intentHash`(): TransactionHash@Throws(RadixEngineToolkitException::class)
    fun `notarizedTransactionHash`(): TransactionHash
    fun `notarySignature`(): Signature
    fun `signedIntent`(): SignedIntent@Throws(RadixEngineToolkitException::class)
    fun `signedIntentHash`(): TransactionHash@Throws(RadixEngineToolkitException::class)
    fun `staticallyValidate`(`validationConfig`: ValidationConfig)
}

class NotarizedTransaction(
    pointer: Pointer
) : FFIObject(pointer), NotarizedTransactionInterface {
    constructor(`signedIntent`: SignedIntent, `notarySignature`: Signature) :
        this(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransaction_new(FfiConverterTypeSignedIntent.lower(`signedIntent`),FfiConverterTypeSignature.lower(`notarySignature`),_status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_notarizedtransaction(this.pointer, status)
        }
    }

    
    @Throws(RadixEngineToolkitException::class)override fun `compile`(): List<UByte> =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_compile(it,
        
        _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `hash`(): TransactionHash =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_hash(it,
        
        _status)
}
        }.let {
            FfiConverterTypeTransactionHash.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `intentHash`(): TransactionHash =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_intent_hash(it,
        
        _status)
}
        }.let {
            FfiConverterTypeTransactionHash.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `notarizedTransactionHash`(): TransactionHash =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_notarized_transaction_hash(it,
        
        _status)
}
        }.let {
            FfiConverterTypeTransactionHash.lift(it)
        }
    
    override fun `notarySignature`(): Signature =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_notary_signature(it,
        
        _status)
}
        }.let {
            FfiConverterTypeSignature.lift(it)
        }
    
    override fun `signedIntent`(): SignedIntent =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_signed_intent(it,
        
        _status)
}
        }.let {
            FfiConverterTypeSignedIntent.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `signedIntentHash`(): TransactionHash =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_signed_intent_hash(it,
        
        _status)
}
        }.let {
            FfiConverterTypeTransactionHash.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `staticallyValidate`(`validationConfig`: ValidationConfig) =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_statically_validate(it,
        FfiConverterTypeValidationConfig.lower(`validationConfig`),
        _status)
}
        }
    
    
    

    companion object {
        fun `decompile`(`compiledNotarizedTransaction`: List<UByte>): NotarizedTransaction =
            NotarizedTransaction(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransaction_decompile(FfiConverterSequenceUByte.lower(`compiledNotarizedTransaction`),_status)
})
        
    }
    
}

public object FfiConverterTypeNotarizedTransaction: FfiConverter<NotarizedTransaction, Pointer> {
    override fun lower(value: NotarizedTransaction): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): NotarizedTransaction {
        return NotarizedTransaction(value)
    }

    override fun read(buf: ByteBuffer): NotarizedTransaction {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: NotarizedTransaction) = 8

    override fun write(value: NotarizedTransaction, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface OlympiaAddressInterface {
    
    fun `asStr`(): String@Throws(RadixEngineToolkitException::class)
    fun `publicKey`(): PublicKey
}

class OlympiaAddress(
    pointer: Pointer
) : FFIObject(pointer), OlympiaAddressInterface {
    constructor(`address`: String) :
        this(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_olympiaaddress_new(FfiConverterString.lower(`address`),_status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_olympiaaddress(this.pointer, status)
        }
    }

    override fun `asStr`(): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_as_str(it,
        
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `publicKey`(): PublicKey =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_public_key(it,
        
        _status)
}
        }.let {
            FfiConverterTypePublicKey.lift(it)
        }
    
    

    
}

public object FfiConverterTypeOlympiaAddress: FfiConverter<OlympiaAddress, Pointer> {
    override fun lower(value: OlympiaAddress): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): OlympiaAddress {
        return OlympiaAddress(value)
    }

    override fun read(buf: ByteBuffer): OlympiaAddress {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: OlympiaAddress) = 8

    override fun write(value: OlympiaAddress, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface PreciseDecimalInterface {
    @Throws(RadixEngineToolkitException::class)
    fun `abs`(): PreciseDecimal@Throws(RadixEngineToolkitException::class)
    fun `add`(`other`: PreciseDecimal): PreciseDecimal
    fun `asStr`(): String@Throws(RadixEngineToolkitException::class)
    fun `cbrt`(): PreciseDecimal@Throws(RadixEngineToolkitException::class)
    fun `ceiling`(): PreciseDecimal@Throws(RadixEngineToolkitException::class)
    fun `div`(`other`: PreciseDecimal): PreciseDecimal
    fun `equal`(`other`: PreciseDecimal): Boolean@Throws(RadixEngineToolkitException::class)
    fun `floor`(): PreciseDecimal
    fun `greaterThan`(`other`: PreciseDecimal): Boolean
    fun `greaterThanOrEqual`(`other`: PreciseDecimal): Boolean
    fun `isNegative`(): Boolean
    fun `isPositive`(): Boolean
    fun `isZero`(): Boolean
    fun `lessThan`(`other`: PreciseDecimal): Boolean
    fun `lessThanOrEqual`(`other`: PreciseDecimal): Boolean
    fun `mantissa`(): String@Throws(RadixEngineToolkitException::class)
    fun `mul`(`other`: PreciseDecimal): PreciseDecimal
    fun `notEqual`(`other`: PreciseDecimal): Boolean
    fun `nthRoot`(`n`: UInt): PreciseDecimal?@Throws(RadixEngineToolkitException::class)
    fun `powi`(`exp`: Long): PreciseDecimal@Throws(RadixEngineToolkitException::class)
    fun `round`(`decimalPlaces`: Int, `roundingMode`: RoundingMode): PreciseDecimal
    fun `sqrt`(): PreciseDecimal?@Throws(RadixEngineToolkitException::class)
    fun `sub`(`other`: PreciseDecimal): PreciseDecimal
}

class PreciseDecimal(
    pointer: Pointer
) : FFIObject(pointer), PreciseDecimalInterface {
    constructor(`value`: String) :
        this(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_new(FfiConverterString.lower(`value`),_status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_precisedecimal(this.pointer, status)
        }
    }

    
    @Throws(RadixEngineToolkitException::class)override fun `abs`(): PreciseDecimal =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_abs(it,
        
        _status)
}
        }.let {
            FfiConverterTypePreciseDecimal.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `add`(`other`: PreciseDecimal): PreciseDecimal =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_add(it,
        FfiConverterTypePreciseDecimal.lower(`other`),
        _status)
}
        }.let {
            FfiConverterTypePreciseDecimal.lift(it)
        }
    
    override fun `asStr`(): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_as_str(it,
        
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `cbrt`(): PreciseDecimal =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_cbrt(it,
        
        _status)
}
        }.let {
            FfiConverterTypePreciseDecimal.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `ceiling`(): PreciseDecimal =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_ceiling(it,
        
        _status)
}
        }.let {
            FfiConverterTypePreciseDecimal.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `div`(`other`: PreciseDecimal): PreciseDecimal =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_div(it,
        FfiConverterTypePreciseDecimal.lower(`other`),
        _status)
}
        }.let {
            FfiConverterTypePreciseDecimal.lift(it)
        }
    
    override fun `equal`(`other`: PreciseDecimal): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_equal(it,
        FfiConverterTypePreciseDecimal.lower(`other`),
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `floor`(): PreciseDecimal =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_floor(it,
        
        _status)
}
        }.let {
            FfiConverterTypePreciseDecimal.lift(it)
        }
    
    override fun `greaterThan`(`other`: PreciseDecimal): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than(it,
        FfiConverterTypePreciseDecimal.lower(`other`),
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `greaterThanOrEqual`(`other`: PreciseDecimal): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than_or_equal(it,
        FfiConverterTypePreciseDecimal.lower(`other`),
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `isNegative`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_negative(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `isPositive`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_positive(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `isZero`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_zero(it,
        
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `lessThan`(`other`: PreciseDecimal): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than(it,
        FfiConverterTypePreciseDecimal.lower(`other`),
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `lessThanOrEqual`(`other`: PreciseDecimal): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than_or_equal(it,
        FfiConverterTypePreciseDecimal.lower(`other`),
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `mantissa`(): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_mantissa(it,
        
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `mul`(`other`: PreciseDecimal): PreciseDecimal =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_mul(it,
        FfiConverterTypePreciseDecimal.lower(`other`),
        _status)
}
        }.let {
            FfiConverterTypePreciseDecimal.lift(it)
        }
    
    override fun `notEqual`(`other`: PreciseDecimal): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_not_equal(it,
        FfiConverterTypePreciseDecimal.lower(`other`),
        _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    
    override fun `nthRoot`(`n`: UInt): PreciseDecimal? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_nth_root(it,
        FfiConverterUInt.lower(`n`),
        _status)
}
        }.let {
            FfiConverterOptionalTypePreciseDecimal.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `powi`(`exp`: Long): PreciseDecimal =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_powi(it,
        FfiConverterLong.lower(`exp`),
        _status)
}
        }.let {
            FfiConverterTypePreciseDecimal.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `round`(`decimalPlaces`: Int, `roundingMode`: RoundingMode): PreciseDecimal =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_round(it,
        FfiConverterInt.lower(`decimalPlaces`),FfiConverterTypeRoundingMode.lower(`roundingMode`),
        _status)
}
        }.let {
            FfiConverterTypePreciseDecimal.lift(it)
        }
    
    override fun `sqrt`(): PreciseDecimal? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sqrt(it,
        
        _status)
}
        }.let {
            FfiConverterOptionalTypePreciseDecimal.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `sub`(`other`: PreciseDecimal): PreciseDecimal =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sub(it,
        FfiConverterTypePreciseDecimal.lower(`other`),
        _status)
}
        }.let {
            FfiConverterTypePreciseDecimal.lift(it)
        }
    
    

    companion object {
        fun `max`(): PreciseDecimal =
            PreciseDecimal(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_max(_status)
})
        fun `min`(): PreciseDecimal =
            PreciseDecimal(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_min(_status)
})
        fun `one`(): PreciseDecimal =
            PreciseDecimal(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_one(_status)
})
        fun `zero`(): PreciseDecimal =
            PreciseDecimal(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_zero(_status)
})
        
    }
    
}

public object FfiConverterTypePreciseDecimal: FfiConverter<PreciseDecimal, Pointer> {
    override fun lower(value: PreciseDecimal): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): PreciseDecimal {
        return PreciseDecimal(value)
    }

    override fun read(buf: ByteBuffer): PreciseDecimal {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: PreciseDecimal) = 8

    override fun write(value: PreciseDecimal, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface PrivateKeyInterface {
    
    fun `publicKey`(): PublicKey
    fun `sign`(`hash`: Hash): List<UByte>
    fun `signToSignature`(`hash`: Hash): Signature
    fun `signToSignatureWithPublicKey`(`hash`: Hash): SignatureWithPublicKey
}

class PrivateKey(
    pointer: Pointer
) : FFIObject(pointer), PrivateKeyInterface {
    constructor(`bytes`: List<UByte>, `curve`: Curve) :
        this(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new(FfiConverterSequenceUByte.lower(`bytes`),FfiConverterTypeCurve.lower(`curve`),_status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_privatekey(this.pointer, status)
        }
    }

    override fun `publicKey`(): PublicKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_public_key(it,
        
        _status)
}
        }.let {
            FfiConverterTypePublicKey.lift(it)
        }
    
    override fun `sign`(`hash`: Hash): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign(it,
        FfiConverterTypeHash.lower(`hash`),
        _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    
    override fun `signToSignature`(`hash`: Hash): Signature =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign_to_signature(it,
        FfiConverterTypeHash.lower(`hash`),
        _status)
}
        }.let {
            FfiConverterTypeSignature.lift(it)
        }
    
    override fun `signToSignatureWithPublicKey`(`hash`: Hash): SignatureWithPublicKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign_to_signature_with_public_key(it,
        FfiConverterTypeHash.lower(`hash`),
        _status)
}
        }.let {
            FfiConverterTypeSignatureWithPublicKey.lift(it)
        }
    
    

    companion object {
        fun `newEd25519`(`bytes`: List<UByte>): PrivateKey =
            PrivateKey(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new_ed25519(FfiConverterSequenceUByte.lower(`bytes`),_status)
})
        fun `newSecp256k1`(`bytes`: List<UByte>): PrivateKey =
            PrivateKey(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new_secp256k1(FfiConverterSequenceUByte.lower(`bytes`),_status)
})
        
    }
    
}

public object FfiConverterTypePrivateKey: FfiConverter<PrivateKey, Pointer> {
    override fun lower(value: PrivateKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): PrivateKey {
        return PrivateKey(value)
    }

    override fun read(buf: ByteBuffer): PrivateKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: PrivateKey) = 8

    override fun write(value: PrivateKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface SignedIntentInterface {
    @Throws(RadixEngineToolkitException::class)
    fun `compile`(): List<UByte>@Throws(RadixEngineToolkitException::class)
    fun `hash`(): TransactionHash
    fun `intent`(): Intent@Throws(RadixEngineToolkitException::class)
    fun `intentHash`(): TransactionHash
    fun `intentSignatures`(): List<SignatureWithPublicKey>@Throws(RadixEngineToolkitException::class)
    fun `signedIntentHash`(): TransactionHash@Throws(RadixEngineToolkitException::class)
    fun `staticallyValidate`(`validationConfig`: ValidationConfig)
}

class SignedIntent(
    pointer: Pointer
) : FFIObject(pointer), SignedIntentInterface {
    constructor(`intent`: Intent, `intentSignatures`: List<SignatureWithPublicKey>) :
        this(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedintent_new(FfiConverterTypeIntent.lower(`intent`),FfiConverterSequenceTypeSignatureWithPublicKey.lower(`intentSignatures`),_status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_signedintent(this.pointer, status)
        }
    }

    
    @Throws(RadixEngineToolkitException::class)override fun `compile`(): List<UByte> =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_compile(it,
        
        _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `hash`(): TransactionHash =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_hash(it,
        
        _status)
}
        }.let {
            FfiConverterTypeTransactionHash.lift(it)
        }
    
    override fun `intent`(): Intent =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent(it,
        
        _status)
}
        }.let {
            FfiConverterTypeIntent.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `intentHash`(): TransactionHash =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent_hash(it,
        
        _status)
}
        }.let {
            FfiConverterTypeTransactionHash.lift(it)
        }
    
    override fun `intentSignatures`(): List<SignatureWithPublicKey> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent_signatures(it,
        
        _status)
}
        }.let {
            FfiConverterSequenceTypeSignatureWithPublicKey.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `signedIntentHash`(): TransactionHash =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_signed_intent_hash(it,
        
        _status)
}
        }.let {
            FfiConverterTypeTransactionHash.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `staticallyValidate`(`validationConfig`: ValidationConfig) =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_statically_validate(it,
        FfiConverterTypeValidationConfig.lower(`validationConfig`),
        _status)
}
        }
    
    
    

    companion object {
        fun `decompile`(`compiledSignedIntent`: List<UByte>): SignedIntent =
            SignedIntent(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedintent_decompile(FfiConverterSequenceUByte.lower(`compiledSignedIntent`),_status)
})
        
    }
    
}

public object FfiConverterTypeSignedIntent: FfiConverter<SignedIntent, Pointer> {
    override fun lower(value: SignedIntent): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): SignedIntent {
        return SignedIntent(value)
    }

    override fun read(buf: ByteBuffer): SignedIntent {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SignedIntent) = 8

    override fun write(value: SignedIntent, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface TransactionBuilderInterface {
    
    fun `header`(`header`: TransactionHeader): TransactionBuilderHeaderStep
}

class TransactionBuilder(
    pointer: Pointer
) : FFIObject(pointer), TransactionBuilderInterface {
    constructor() :
        this(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionbuilder_new(_status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilder(this.pointer, status)
        }
    }

    override fun `header`(`header`: TransactionHeader): TransactionBuilderHeaderStep =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilder_header(it,
        FfiConverterTypeTransactionHeader.lower(`header`),
        _status)
}
        }.let {
            FfiConverterTypeTransactionBuilderHeaderStep.lift(it)
        }
    
    

    
}

public object FfiConverterTypeTransactionBuilder: FfiConverter<TransactionBuilder, Pointer> {
    override fun lower(value: TransactionBuilder): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): TransactionBuilder {
        return TransactionBuilder(value)
    }

    override fun read(buf: ByteBuffer): TransactionBuilder {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: TransactionBuilder) = 8

    override fun write(value: TransactionBuilder, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface TransactionBuilderHeaderStepInterface {
    
    fun `manifest`(`manifest`: TransactionManifest): TransactionBuilderMessageStep
}

class TransactionBuilderHeaderStep(
    pointer: Pointer
) : FFIObject(pointer), TransactionBuilderHeaderStepInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilderheaderstep(this.pointer, status)
        }
    }

    override fun `manifest`(`manifest`: TransactionManifest): TransactionBuilderMessageStep =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderheaderstep_manifest(it,
        FfiConverterTypeTransactionManifest.lower(`manifest`),
        _status)
}
        }.let {
            FfiConverterTypeTransactionBuilderMessageStep.lift(it)
        }
    
    

    
}

public object FfiConverterTypeTransactionBuilderHeaderStep: FfiConverter<TransactionBuilderHeaderStep, Pointer> {
    override fun lower(value: TransactionBuilderHeaderStep): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): TransactionBuilderHeaderStep {
        return TransactionBuilderHeaderStep(value)
    }

    override fun read(buf: ByteBuffer): TransactionBuilderHeaderStep {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: TransactionBuilderHeaderStep) = 8

    override fun write(value: TransactionBuilderHeaderStep, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface TransactionBuilderIntentSignaturesStepInterface {
    @Throws(RadixEngineToolkitException::class)
    fun `notarizeWithPrivateKey`(`privateKey`: PrivateKey): NotarizedTransaction@Throws(RadixEngineToolkitException::class)
    fun `notarizeWithSigner`(`signer`: Signer): NotarizedTransaction
    fun `signWithPrivateKey`(`privateKey`: PrivateKey): TransactionBuilderIntentSignaturesStep
    fun `signWithSigner`(`signer`: Signer): TransactionBuilderIntentSignaturesStep
}

class TransactionBuilderIntentSignaturesStep(
    pointer: Pointer
) : FFIObject(pointer), TransactionBuilderIntentSignaturesStepInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilderintentsignaturesstep(this.pointer, status)
        }
    }

    
    @Throws(RadixEngineToolkitException::class)override fun `notarizeWithPrivateKey`(`privateKey`: PrivateKey): NotarizedTransaction =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_notarize_with_private_key(it,
        FfiConverterTypePrivateKey.lower(`privateKey`),
        _status)
}
        }.let {
            FfiConverterTypeNotarizedTransaction.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `notarizeWithSigner`(`signer`: Signer): NotarizedTransaction =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_notarize_with_signer(it,
        FfiConverterTypeSigner.lower(`signer`),
        _status)
}
        }.let {
            FfiConverterTypeNotarizedTransaction.lift(it)
        }
    
    override fun `signWithPrivateKey`(`privateKey`: PrivateKey): TransactionBuilderIntentSignaturesStep =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_sign_with_private_key(it,
        FfiConverterTypePrivateKey.lower(`privateKey`),
        _status)
}
        }.let {
            FfiConverterTypeTransactionBuilderIntentSignaturesStep.lift(it)
        }
    
    override fun `signWithSigner`(`signer`: Signer): TransactionBuilderIntentSignaturesStep =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_sign_with_signer(it,
        FfiConverterTypeSigner.lower(`signer`),
        _status)
}
        }.let {
            FfiConverterTypeTransactionBuilderIntentSignaturesStep.lift(it)
        }
    
    

    
}

public object FfiConverterTypeTransactionBuilderIntentSignaturesStep: FfiConverter<TransactionBuilderIntentSignaturesStep, Pointer> {
    override fun lower(value: TransactionBuilderIntentSignaturesStep): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): TransactionBuilderIntentSignaturesStep {
        return TransactionBuilderIntentSignaturesStep(value)
    }

    override fun read(buf: ByteBuffer): TransactionBuilderIntentSignaturesStep {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: TransactionBuilderIntentSignaturesStep) = 8

    override fun write(value: TransactionBuilderIntentSignaturesStep, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface TransactionBuilderMessageStepInterface {
    
    fun `message`(`message`: Message): TransactionBuilderIntentSignaturesStep
    fun `signWithPrivateKey`(`privateKey`: PrivateKey): TransactionBuilderIntentSignaturesStep
    fun `signWithSigner`(`signer`: Signer): TransactionBuilderIntentSignaturesStep
}

class TransactionBuilderMessageStep(
    pointer: Pointer
) : FFIObject(pointer), TransactionBuilderMessageStepInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuildermessagestep(this.pointer, status)
        }
    }

    override fun `message`(`message`: Message): TransactionBuilderIntentSignaturesStep =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_message(it,
        FfiConverterTypeMessage.lower(`message`),
        _status)
}
        }.let {
            FfiConverterTypeTransactionBuilderIntentSignaturesStep.lift(it)
        }
    
    override fun `signWithPrivateKey`(`privateKey`: PrivateKey): TransactionBuilderIntentSignaturesStep =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_sign_with_private_key(it,
        FfiConverterTypePrivateKey.lower(`privateKey`),
        _status)
}
        }.let {
            FfiConverterTypeTransactionBuilderIntentSignaturesStep.lift(it)
        }
    
    override fun `signWithSigner`(`signer`: Signer): TransactionBuilderIntentSignaturesStep =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_sign_with_signer(it,
        FfiConverterTypeSigner.lower(`signer`),
        _status)
}
        }.let {
            FfiConverterTypeTransactionBuilderIntentSignaturesStep.lift(it)
        }
    
    

    
}

public object FfiConverterTypeTransactionBuilderMessageStep: FfiConverter<TransactionBuilderMessageStep, Pointer> {
    override fun lower(value: TransactionBuilderMessageStep): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): TransactionBuilderMessageStep {
        return TransactionBuilderMessageStep(value)
    }

    override fun read(buf: ByteBuffer): TransactionBuilderMessageStep {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: TransactionBuilderMessageStep) = 8

    override fun write(value: TransactionBuilderMessageStep, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface TransactionHashInterface {
    
    fun `asHash`(): Hash
    fun `asStr`(): String
    fun `bytes`(): List<UByte>
    fun `networkId`(): UByte
}

class TransactionHash(
    pointer: Pointer
) : FFIObject(pointer), TransactionHashInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionhash(this.pointer, status)
        }
    }

    override fun `asHash`(): Hash =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_hash(it,
        
        _status)
}
        }.let {
            FfiConverterTypeHash.lift(it)
        }
    
    override fun `asStr`(): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_str(it,
        
        _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    
    override fun `bytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_bytes(it,
        
        _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    
    override fun `networkId`(): UByte =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_network_id(it,
        
        _status)
}
        }.let {
            FfiConverterUByte.lift(it)
        }
    
    

    companion object {
        fun `fromStr`(`string`: String, `networkId`: UByte): TransactionHash =
            TransactionHash(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionhash_from_str(FfiConverterString.lower(`string`),FfiConverterUByte.lower(`networkId`),_status)
})
        
    }
    
}

public object FfiConverterTypeTransactionHash: FfiConverter<TransactionHash, Pointer> {
    override fun lower(value: TransactionHash): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): TransactionHash {
        return TransactionHash(value)
    }

    override fun read(buf: ByteBuffer): TransactionHash {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: TransactionHash) = 8

    override fun write(value: TransactionHash, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface TransactionManifestInterface {
    
    fun `accountsDepositedInto`(): List<Address>
    fun `accountsRequiringAuth`(): List<Address>
    fun `accountsWithdrawnFrom`(): List<Address>@Throws(RadixEngineToolkitException::class)
    fun `analyzeExecution`(`transactionReceipt`: List<UByte>): ExecutionAnalysis
    fun `blobs`(): List<List<UByte>>@Throws(RadixEngineToolkitException::class)
    fun `compile`(): List<UByte>
    fun `extractAddresses`(): Map<EntityType, List<Address>>
    fun `identitiesRequiringAuth`(): List<Address>
    fun `instructions`(): Instructions@Throws(RadixEngineToolkitException::class)
    fun `modify`(`modifications`: TransactionManifestModifications): TransactionManifest@Throws(RadixEngineToolkitException::class)
    fun `parseTransferInformation`(`allowLockFeeInstructions`: Boolean): TransferTransactionType?@Throws(RadixEngineToolkitException::class)
    fun `staticallyValidate`()
}

class TransactionManifest(
    pointer: Pointer
) : FFIObject(pointer), TransactionManifestInterface {
    constructor(`instructions`: Instructions, `blobs`: List<List<UByte>>) :
        this(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionmanifest_new(FfiConverterTypeInstructions.lower(`instructions`),FfiConverterSequenceSequenceUByte.lower(`blobs`),_status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionmanifest(this.pointer, status)
        }
    }

    override fun `accountsDepositedInto`(): List<Address> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_deposited_into(it,
        
        _status)
}
        }.let {
            FfiConverterSequenceTypeAddress.lift(it)
        }
    
    override fun `accountsRequiringAuth`(): List<Address> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_requiring_auth(it,
        
        _status)
}
        }.let {
            FfiConverterSequenceTypeAddress.lift(it)
        }
    
    override fun `accountsWithdrawnFrom`(): List<Address> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_withdrawn_from(it,
        
        _status)
}
        }.let {
            FfiConverterSequenceTypeAddress.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `analyzeExecution`(`transactionReceipt`: List<UByte>): ExecutionAnalysis =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_analyze_execution(it,
        FfiConverterSequenceUByte.lower(`transactionReceipt`),
        _status)
}
        }.let {
            FfiConverterTypeExecutionAnalysis.lift(it)
        }
    
    override fun `blobs`(): List<List<UByte>> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_blobs(it,
        
        _status)
}
        }.let {
            FfiConverterSequenceSequenceUByte.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `compile`(): List<UByte> =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_compile(it,
        
        _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    
    override fun `extractAddresses`(): Map<EntityType, List<Address>> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_extract_addresses(it,
        
        _status)
}
        }.let {
            FfiConverterMapTypeEntityTypeSequenceTypeAddress.lift(it)
        }
    
    override fun `identitiesRequiringAuth`(): List<Address> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_identities_requiring_auth(it,
        
        _status)
}
        }.let {
            FfiConverterSequenceTypeAddress.lift(it)
        }
    
    override fun `instructions`(): Instructions =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_instructions(it,
        
        _status)
}
        }.let {
            FfiConverterTypeInstructions.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `modify`(`modifications`: TransactionManifestModifications): TransactionManifest =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_modify(it,
        FfiConverterTypeTransactionManifestModifications.lower(`modifications`),
        _status)
}
        }.let {
            FfiConverterTypeTransactionManifest.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `parseTransferInformation`(`allowLockFeeInstructions`: Boolean): TransferTransactionType? =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_parse_transfer_information(it,
        FfiConverterBoolean.lower(`allowLockFeeInstructions`),
        _status)
}
        }.let {
            FfiConverterOptionalTypeTransferTransactionType.lift(it)
        }
    
    
    @Throws(RadixEngineToolkitException::class)override fun `staticallyValidate`() =
        callWithPointer {
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_statically_validate(it,
        
        _status)
}
        }
    
    
    

    companion object {
        fun `decompile`(`compiled`: List<UByte>, `networkId`: UByte): TransactionManifest =
            TransactionManifest(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionmanifest_decompile(FfiConverterSequenceUByte.lower(`compiled`),FfiConverterUByte.lower(`networkId`),_status)
})
        
    }
    
}

public object FfiConverterTypeTransactionManifest: FfiConverter<TransactionManifest, Pointer> {
    override fun lower(value: TransactionManifest): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): TransactionManifest {
        return TransactionManifest(value)
    }

    override fun read(buf: ByteBuffer): TransactionManifest {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: TransactionManifest) = 8

    override fun write(value: TransactionManifest, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ValidationConfigInterface {
    
    fun `maxEpochRange`(): ULong
    fun `maxNotarizedPayloadSize`(): ULong
    fun `maxTipPercentage`(): UShort
    fun `messageValidation`(): MessageValidationConfig
    fun `minTipPercentage`(): UShort
    fun `networkId`(): UByte
}

class ValidationConfig(
    pointer: Pointer
) : FFIObject(pointer), ValidationConfigInterface {
    constructor(`networkId`: UByte, `maxNotarizedPayloadSize`: ULong, `minTipPercentage`: UShort, `maxTipPercentage`: UShort, `maxEpochRange`: ULong, `messageValidation`: MessageValidationConfig) :
        this(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_validationconfig_new(FfiConverterUByte.lower(`networkId`),FfiConverterULong.lower(`maxNotarizedPayloadSize`),FfiConverterUShort.lower(`minTipPercentage`),FfiConverterUShort.lower(`maxTipPercentage`),FfiConverterULong.lower(`maxEpochRange`),FfiConverterTypeMessageValidationConfig.lower(`messageValidation`),_status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_free_validationconfig(this.pointer, status)
        }
    }

    override fun `maxEpochRange`(): ULong =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_epoch_range(it,
        
        _status)
}
        }.let {
            FfiConverterULong.lift(it)
        }
    
    override fun `maxNotarizedPayloadSize`(): ULong =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_notarized_payload_size(it,
        
        _status)
}
        }.let {
            FfiConverterULong.lift(it)
        }
    
    override fun `maxTipPercentage`(): UShort =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_tip_percentage(it,
        
        _status)
}
        }.let {
            FfiConverterUShort.lift(it)
        }
    
    override fun `messageValidation`(): MessageValidationConfig =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_message_validation(it,
        
        _status)
}
        }.let {
            FfiConverterTypeMessageValidationConfig.lift(it)
        }
    
    override fun `minTipPercentage`(): UShort =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_min_tip_percentage(it,
        
        _status)
}
        }.let {
            FfiConverterUShort.lift(it)
        }
    
    override fun `networkId`(): UByte =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_network_id(it,
        
        _status)
}
        }.let {
            FfiConverterUByte.lift(it)
        }
    
    

    companion object {
        fun `default`(`networkId`: UByte): ValidationConfig =
            ValidationConfig(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_constructor_validationconfig_default(FfiConverterUByte.lower(`networkId`),_status)
})
        
    }
    
}

public object FfiConverterTypeValidationConfig: FfiConverter<ValidationConfig, Pointer> {
    override fun lower(value: ValidationConfig): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ValidationConfig {
        return ValidationConfig(value)
    }

    override fun read(buf: ByteBuffer): ValidationConfig {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ValidationConfig) = 8

    override fun write(value: ValidationConfig, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




data class AccountAddAuthorizedDepositorEvent (
    var `authorizedDepositorBadge`: ResourceOrNonFungible
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`authorizedDepositorBadge`)
    }
    
}

public object FfiConverterTypeAccountAddAuthorizedDepositorEvent: FfiConverterRustBuffer<AccountAddAuthorizedDepositorEvent> {
    override fun read(buf: ByteBuffer): AccountAddAuthorizedDepositorEvent {
        return AccountAddAuthorizedDepositorEvent(
            FfiConverterTypeResourceOrNonFungible.read(buf),
        )
    }

    override fun allocationSize(value: AccountAddAuthorizedDepositorEvent) = (
            FfiConverterTypeResourceOrNonFungible.allocationSize(value.`authorizedDepositorBadge`)
    )

    override fun write(value: AccountAddAuthorizedDepositorEvent, buf: ByteBuffer) {
            FfiConverterTypeResourceOrNonFungible.write(value.`authorizedDepositorBadge`, buf)
    }
}




data class AccountRemoveAuthorizedDepositorEvent (
    var `authorizedDepositorBadge`: ResourceOrNonFungible
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`authorizedDepositorBadge`)
    }
    
}

public object FfiConverterTypeAccountRemoveAuthorizedDepositorEvent: FfiConverterRustBuffer<AccountRemoveAuthorizedDepositorEvent> {
    override fun read(buf: ByteBuffer): AccountRemoveAuthorizedDepositorEvent {
        return AccountRemoveAuthorizedDepositorEvent(
            FfiConverterTypeResourceOrNonFungible.read(buf),
        )
    }

    override fun allocationSize(value: AccountRemoveAuthorizedDepositorEvent) = (
            FfiConverterTypeResourceOrNonFungible.allocationSize(value.`authorizedDepositorBadge`)
    )

    override fun write(value: AccountRemoveAuthorizedDepositorEvent, buf: ByteBuffer) {
            FfiConverterTypeResourceOrNonFungible.write(value.`authorizedDepositorBadge`, buf)
    }
}




data class AccountRemoveResourcePreferenceEvent (
    var `resourceAddress`: Address
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`resourceAddress`)
    }
    
}

public object FfiConverterTypeAccountRemoveResourcePreferenceEvent: FfiConverterRustBuffer<AccountRemoveResourcePreferenceEvent> {
    override fun read(buf: ByteBuffer): AccountRemoveResourcePreferenceEvent {
        return AccountRemoveResourcePreferenceEvent(
            FfiConverterTypeAddress.read(buf),
        )
    }

    override fun allocationSize(value: AccountRemoveResourcePreferenceEvent) = (
            FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
    )

    override fun write(value: AccountRemoveResourcePreferenceEvent, buf: ByteBuffer) {
            FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
    }
}




data class AccountSetDefaultDepositRuleEvent (
    var `defaultDepositRule`: AccountDefaultDepositRule
) {
    
}

public object FfiConverterTypeAccountSetDefaultDepositRuleEvent: FfiConverterRustBuffer<AccountSetDefaultDepositRuleEvent> {
    override fun read(buf: ByteBuffer): AccountSetDefaultDepositRuleEvent {
        return AccountSetDefaultDepositRuleEvent(
            FfiConverterTypeAccountDefaultDepositRule.read(buf),
        )
    }

    override fun allocationSize(value: AccountSetDefaultDepositRuleEvent) = (
            FfiConverterTypeAccountDefaultDepositRule.allocationSize(value.`defaultDepositRule`)
    )

    override fun write(value: AccountSetDefaultDepositRuleEvent, buf: ByteBuffer) {
            FfiConverterTypeAccountDefaultDepositRule.write(value.`defaultDepositRule`, buf)
    }
}




data class AccountSetResourcePreferenceEvent (
    var `resourceAddress`: Address, 
    var `preference`: ResourcePreference
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`preference`)
    }
    
}

public object FfiConverterTypeAccountSetResourcePreferenceEvent: FfiConverterRustBuffer<AccountSetResourcePreferenceEvent> {
    override fun read(buf: ByteBuffer): AccountSetResourcePreferenceEvent {
        return AccountSetResourcePreferenceEvent(
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeResourcePreference.read(buf),
        )
    }

    override fun allocationSize(value: AccountSetResourcePreferenceEvent) = (
            FfiConverterTypeAddress.allocationSize(value.`resourceAddress`) +
            FfiConverterTypeResourcePreference.allocationSize(value.`preference`)
    )

    override fun write(value: AccountSetResourcePreferenceEvent, buf: ByteBuffer) {
            FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
            FfiConverterTypeResourcePreference.write(value.`preference`, buf)
    }
}




data class AuthorizedDepositorsChanges (
    var `added`: List<ResourceOrNonFungible>, 
    var `removed`: List<ResourceOrNonFungible>
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`added`, 
        this.`removed`)
    }
    
}

public object FfiConverterTypeAuthorizedDepositorsChanges: FfiConverterRustBuffer<AuthorizedDepositorsChanges> {
    override fun read(buf: ByteBuffer): AuthorizedDepositorsChanges {
        return AuthorizedDepositorsChanges(
            FfiConverterSequenceTypeResourceOrNonFungible.read(buf),
            FfiConverterSequenceTypeResourceOrNonFungible.read(buf),
        )
    }

    override fun allocationSize(value: AuthorizedDepositorsChanges) = (
            FfiConverterSequenceTypeResourceOrNonFungible.allocationSize(value.`added`) +
            FfiConverterSequenceTypeResourceOrNonFungible.allocationSize(value.`removed`)
    )

    override fun write(value: AuthorizedDepositorsChanges, buf: ByteBuffer) {
            FfiConverterSequenceTypeResourceOrNonFungible.write(value.`added`, buf)
            FfiConverterSequenceTypeResourceOrNonFungible.write(value.`removed`, buf)
    }
}




data class BadgeWithdrawEvent (
    var `proposer`: Proposer
) {
    
}

public object FfiConverterTypeBadgeWithdrawEvent: FfiConverterRustBuffer<BadgeWithdrawEvent> {
    override fun read(buf: ByteBuffer): BadgeWithdrawEvent {
        return BadgeWithdrawEvent(
            FfiConverterTypeProposer.read(buf),
        )
    }

    override fun allocationSize(value: BadgeWithdrawEvent) = (
            FfiConverterTypeProposer.allocationSize(value.`proposer`)
    )

    override fun write(value: BadgeWithdrawEvent, buf: ByteBuffer) {
            FfiConverterTypeProposer.write(value.`proposer`, buf)
    }
}




data class BuildInformation (
    var `version`: String, 
    var `scryptoDependency`: DependencyInformation
) {
    
}

public object FfiConverterTypeBuildInformation: FfiConverterRustBuffer<BuildInformation> {
    override fun read(buf: ByteBuffer): BuildInformation {
        return BuildInformation(
            FfiConverterString.read(buf),
            FfiConverterTypeDependencyInformation.read(buf),
        )
    }

    override fun allocationSize(value: BuildInformation) = (
            FfiConverterString.allocationSize(value.`version`) +
            FfiConverterTypeDependencyInformation.allocationSize(value.`scryptoDependency`)
    )

    override fun write(value: BuildInformation, buf: ByteBuffer) {
            FfiConverterString.write(value.`version`, buf)
            FfiConverterTypeDependencyInformation.write(value.`scryptoDependency`, buf)
    }
}




data class BurnFungibleResourceEvent (
    var `amount`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`amount`)
    }
    
}

public object FfiConverterTypeBurnFungibleResourceEvent: FfiConverterRustBuffer<BurnFungibleResourceEvent> {
    override fun read(buf: ByteBuffer): BurnFungibleResourceEvent {
        return BurnFungibleResourceEvent(
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: BurnFungibleResourceEvent) = (
            FfiConverterTypeDecimal.allocationSize(value.`amount`)
    )

    override fun write(value: BurnFungibleResourceEvent, buf: ByteBuffer) {
            FfiConverterTypeDecimal.write(value.`amount`, buf)
    }
}




data class BurnNonFungibleResourceEvent (
    var `ids`: List<NonFungibleLocalId>
) {
    
}

public object FfiConverterTypeBurnNonFungibleResourceEvent: FfiConverterRustBuffer<BurnNonFungibleResourceEvent> {
    override fun read(buf: ByteBuffer): BurnNonFungibleResourceEvent {
        return BurnNonFungibleResourceEvent(
            FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
        )
    }

    override fun allocationSize(value: BurnNonFungibleResourceEvent) = (
            FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`ids`)
    )

    override fun write(value: BurnNonFungibleResourceEvent, buf: ByteBuffer) {
            FfiConverterSequenceTypeNonFungibleLocalId.write(value.`ids`, buf)
    }
}




data class CancelBadgeWithdrawAttemptEvent (
    var `proposer`: Proposer
) {
    
}

public object FfiConverterTypeCancelBadgeWithdrawAttemptEvent: FfiConverterRustBuffer<CancelBadgeWithdrawAttemptEvent> {
    override fun read(buf: ByteBuffer): CancelBadgeWithdrawAttemptEvent {
        return CancelBadgeWithdrawAttemptEvent(
            FfiConverterTypeProposer.read(buf),
        )
    }

    override fun allocationSize(value: CancelBadgeWithdrawAttemptEvent) = (
            FfiConverterTypeProposer.allocationSize(value.`proposer`)
    )

    override fun write(value: CancelBadgeWithdrawAttemptEvent, buf: ByteBuffer) {
            FfiConverterTypeProposer.write(value.`proposer`, buf)
    }
}




data class CancelRecoveryProposalEvent (
    var `proposer`: Proposer
) {
    
}

public object FfiConverterTypeCancelRecoveryProposalEvent: FfiConverterRustBuffer<CancelRecoveryProposalEvent> {
    override fun read(buf: ByteBuffer): CancelRecoveryProposalEvent {
        return CancelRecoveryProposalEvent(
            FfiConverterTypeProposer.read(buf),
        )
    }

    override fun allocationSize(value: CancelRecoveryProposalEvent) = (
            FfiConverterTypeProposer.allocationSize(value.`proposer`)
    )

    override fun write(value: CancelRecoveryProposalEvent, buf: ByteBuffer) {
            FfiConverterTypeProposer.write(value.`proposer`, buf)
    }
}




data class ClaimStakeInformation (
    var `fromAccount`: Address, 
    var `validatorAddress`: Address, 
    var `claimNftResource`: Address, 
    var `claimNftLocalIds`: List<NonFungibleLocalId>, 
    var `claimedXrd`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`fromAccount`, 
        this.`validatorAddress`, 
        this.`claimNftResource`, 
        this.`claimNftLocalIds`, 
        this.`claimedXrd`)
    }
    
}

public object FfiConverterTypeClaimStakeInformation: FfiConverterRustBuffer<ClaimStakeInformation> {
    override fun read(buf: ByteBuffer): ClaimStakeInformation {
        return ClaimStakeInformation(
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: ClaimStakeInformation) = (
            FfiConverterTypeAddress.allocationSize(value.`fromAccount`) +
            FfiConverterTypeAddress.allocationSize(value.`validatorAddress`) +
            FfiConverterTypeAddress.allocationSize(value.`claimNftResource`) +
            FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`claimNftLocalIds`) +
            FfiConverterTypeDecimal.allocationSize(value.`claimedXrd`)
    )

    override fun write(value: ClaimStakeInformation, buf: ByteBuffer) {
            FfiConverterTypeAddress.write(value.`fromAccount`, buf)
            FfiConverterTypeAddress.write(value.`validatorAddress`, buf)
            FfiConverterTypeAddress.write(value.`claimNftResource`, buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(value.`claimNftLocalIds`, buf)
            FfiConverterTypeDecimal.write(value.`claimedXrd`, buf)
    }
}




data class ClaimXrdEvent (
    var `claimedXrd`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`claimedXrd`)
    }
    
}

public object FfiConverterTypeClaimXrdEvent: FfiConverterRustBuffer<ClaimXrdEvent> {
    override fun read(buf: ByteBuffer): ClaimXrdEvent {
        return ClaimXrdEvent(
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: ClaimXrdEvent) = (
            FfiConverterTypeDecimal.allocationSize(value.`claimedXrd`)
    )

    override fun write(value: ClaimXrdEvent, buf: ByteBuffer) {
            FfiConverterTypeDecimal.write(value.`claimedXrd`, buf)
    }
}




data class ComponentAddresses (
    var `consensusManager`: Address, 
    var `genesisHelper`: Address, 
    var `faucet`: Address
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`consensusManager`, 
        this.`genesisHelper`, 
        this.`faucet`)
    }
    
}

public object FfiConverterTypeComponentAddresses: FfiConverterRustBuffer<ComponentAddresses> {
    override fun read(buf: ByteBuffer): ComponentAddresses {
        return ComponentAddresses(
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
        )
    }

    override fun allocationSize(value: ComponentAddresses) = (
            FfiConverterTypeAddress.allocationSize(value.`consensusManager`) +
            FfiConverterTypeAddress.allocationSize(value.`genesisHelper`) +
            FfiConverterTypeAddress.allocationSize(value.`faucet`)
    )

    override fun write(value: ComponentAddresses, buf: ByteBuffer) {
            FfiConverterTypeAddress.write(value.`consensusManager`, buf)
            FfiConverterTypeAddress.write(value.`genesisHelper`, buf)
            FfiConverterTypeAddress.write(value.`faucet`, buf)
    }
}




data class Ed25519PublicKey (
    var `value`: List<UByte>
) {
    
}

public object FfiConverterTypeEd25519PublicKey: FfiConverterRustBuffer<Ed25519PublicKey> {
    override fun read(buf: ByteBuffer): Ed25519PublicKey {
        return Ed25519PublicKey(
            FfiConverterSequenceUByte.read(buf),
        )
    }

    override fun allocationSize(value: Ed25519PublicKey) = (
            FfiConverterSequenceUByte.allocationSize(value.`value`)
    )

    override fun write(value: Ed25519PublicKey, buf: ByteBuffer) {
            FfiConverterSequenceUByte.write(value.`value`, buf)
    }
}




data class EncryptedMessage (
    var `encrypted`: List<UByte>, 
    var `decryptorsByCurve`: Map<CurveType, DecryptorsByCurve>
) {
    
}

public object FfiConverterTypeEncryptedMessage: FfiConverterRustBuffer<EncryptedMessage> {
    override fun read(buf: ByteBuffer): EncryptedMessage {
        return EncryptedMessage(
            FfiConverterSequenceUByte.read(buf),
            FfiConverterMapTypeCurveTypeTypeDecryptorsByCurve.read(buf),
        )
    }

    override fun allocationSize(value: EncryptedMessage) = (
            FfiConverterSequenceUByte.allocationSize(value.`encrypted`) +
            FfiConverterMapTypeCurveTypeTypeDecryptorsByCurve.allocationSize(value.`decryptorsByCurve`)
    )

    override fun write(value: EncryptedMessage, buf: ByteBuffer) {
            FfiConverterSequenceUByte.write(value.`encrypted`, buf)
            FfiConverterMapTypeCurveTypeTypeDecryptorsByCurve.write(value.`decryptorsByCurve`, buf)
    }
}




data class EpochChangeEvent (
    var `epoch`: ULong, 
    var `validatorSet`: Map<String, ValidatorInfo>
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`epoch`, 
        this.`validatorSet`)
    }
    
}

public object FfiConverterTypeEpochChangeEvent: FfiConverterRustBuffer<EpochChangeEvent> {
    override fun read(buf: ByteBuffer): EpochChangeEvent {
        return EpochChangeEvent(
            FfiConverterULong.read(buf),
            FfiConverterMapStringTypeValidatorInfo.read(buf),
        )
    }

    override fun allocationSize(value: EpochChangeEvent) = (
            FfiConverterULong.allocationSize(value.`epoch`) +
            FfiConverterMapStringTypeValidatorInfo.allocationSize(value.`validatorSet`)
    )

    override fun write(value: EpochChangeEvent, buf: ByteBuffer) {
            FfiConverterULong.write(value.`epoch`, buf)
            FfiConverterMapStringTypeValidatorInfo.write(value.`validatorSet`, buf)
    }
}




data class EventTypeIdentifier (
    var `emitter`: Emitter, 
    var `eventName`: String
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`emitter`, 
        this.`eventName`)
    }
    
}

public object FfiConverterTypeEventTypeIdentifier: FfiConverterRustBuffer<EventTypeIdentifier> {
    override fun read(buf: ByteBuffer): EventTypeIdentifier {
        return EventTypeIdentifier(
            FfiConverterTypeEmitter.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: EventTypeIdentifier) = (
            FfiConverterTypeEmitter.allocationSize(value.`emitter`) +
            FfiConverterString.allocationSize(value.`eventName`)
    )

    override fun write(value: EventTypeIdentifier, buf: ByteBuffer) {
            FfiConverterTypeEmitter.write(value.`emitter`, buf)
            FfiConverterString.write(value.`eventName`, buf)
    }
}




data class ExecutionAnalysis (
    var `feeLocks`: FeeLocks, 
    var `feeSummary`: FeeSummary, 
    var `transactionTypes`: List<TransactionType>, 
    var `reservedInstructions`: List<ReservedInstruction>
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`feeLocks`, 
        this.`feeSummary`, 
        this.`transactionTypes`, 
        this.`reservedInstructions`)
    }
    
}

public object FfiConverterTypeExecutionAnalysis: FfiConverterRustBuffer<ExecutionAnalysis> {
    override fun read(buf: ByteBuffer): ExecutionAnalysis {
        return ExecutionAnalysis(
            FfiConverterTypeFeeLocks.read(buf),
            FfiConverterTypeFeeSummary.read(buf),
            FfiConverterSequenceTypeTransactionType.read(buf),
            FfiConverterSequenceTypeReservedInstruction.read(buf),
        )
    }

    override fun allocationSize(value: ExecutionAnalysis) = (
            FfiConverterTypeFeeLocks.allocationSize(value.`feeLocks`) +
            FfiConverterTypeFeeSummary.allocationSize(value.`feeSummary`) +
            FfiConverterSequenceTypeTransactionType.allocationSize(value.`transactionTypes`) +
            FfiConverterSequenceTypeReservedInstruction.allocationSize(value.`reservedInstructions`)
    )

    override fun write(value: ExecutionAnalysis, buf: ByteBuffer) {
            FfiConverterTypeFeeLocks.write(value.`feeLocks`, buf)
            FfiConverterTypeFeeSummary.write(value.`feeSummary`, buf)
            FfiConverterSequenceTypeTransactionType.write(value.`transactionTypes`, buf)
            FfiConverterSequenceTypeReservedInstruction.write(value.`reservedInstructions`, buf)
    }
}




data class FeeLocks (
    var `lock`: Decimal, 
    var `contingentLock`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`lock`, 
        this.`contingentLock`)
    }
    
}

public object FfiConverterTypeFeeLocks: FfiConverterRustBuffer<FeeLocks> {
    override fun read(buf: ByteBuffer): FeeLocks {
        return FeeLocks(
            FfiConverterTypeDecimal.read(buf),
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: FeeLocks) = (
            FfiConverterTypeDecimal.allocationSize(value.`lock`) +
            FfiConverterTypeDecimal.allocationSize(value.`contingentLock`)
    )

    override fun write(value: FeeLocks, buf: ByteBuffer) {
            FfiConverterTypeDecimal.write(value.`lock`, buf)
            FfiConverterTypeDecimal.write(value.`contingentLock`, buf)
    }
}




data class FeeSummary (
    var `executionCost`: Decimal, 
    var `finalizationCost`: Decimal, 
    var `storageExpansionCost`: Decimal, 
    var `royaltyCost`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`executionCost`, 
        this.`finalizationCost`, 
        this.`storageExpansionCost`, 
        this.`royaltyCost`)
    }
    
}

public object FfiConverterTypeFeeSummary: FfiConverterRustBuffer<FeeSummary> {
    override fun read(buf: ByteBuffer): FeeSummary {
        return FeeSummary(
            FfiConverterTypeDecimal.read(buf),
            FfiConverterTypeDecimal.read(buf),
            FfiConverterTypeDecimal.read(buf),
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: FeeSummary) = (
            FfiConverterTypeDecimal.allocationSize(value.`executionCost`) +
            FfiConverterTypeDecimal.allocationSize(value.`finalizationCost`) +
            FfiConverterTypeDecimal.allocationSize(value.`storageExpansionCost`) +
            FfiConverterTypeDecimal.allocationSize(value.`royaltyCost`)
    )

    override fun write(value: FeeSummary, buf: ByteBuffer) {
            FfiConverterTypeDecimal.write(value.`executionCost`, buf)
            FfiConverterTypeDecimal.write(value.`finalizationCost`, buf)
            FfiConverterTypeDecimal.write(value.`storageExpansionCost`, buf)
            FfiConverterTypeDecimal.write(value.`royaltyCost`, buf)
    }
}




data class FungibleResourceRoles (
    var `mintRoles`: ResourceManagerRole?, 
    var `burnRoles`: ResourceManagerRole?, 
    var `freezeRoles`: ResourceManagerRole?, 
    var `recallRoles`: ResourceManagerRole?, 
    var `withdrawRoles`: ResourceManagerRole?, 
    var `depositRoles`: ResourceManagerRole?
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`mintRoles`, 
        this.`burnRoles`, 
        this.`freezeRoles`, 
        this.`recallRoles`, 
        this.`withdrawRoles`, 
        this.`depositRoles`)
    }
    
}

public object FfiConverterTypeFungibleResourceRoles: FfiConverterRustBuffer<FungibleResourceRoles> {
    override fun read(buf: ByteBuffer): FungibleResourceRoles {
        return FungibleResourceRoles(
            FfiConverterOptionalTypeResourceManagerRole.read(buf),
            FfiConverterOptionalTypeResourceManagerRole.read(buf),
            FfiConverterOptionalTypeResourceManagerRole.read(buf),
            FfiConverterOptionalTypeResourceManagerRole.read(buf),
            FfiConverterOptionalTypeResourceManagerRole.read(buf),
            FfiConverterOptionalTypeResourceManagerRole.read(buf),
        )
    }

    override fun allocationSize(value: FungibleResourceRoles) = (
            FfiConverterOptionalTypeResourceManagerRole.allocationSize(value.`mintRoles`) +
            FfiConverterOptionalTypeResourceManagerRole.allocationSize(value.`burnRoles`) +
            FfiConverterOptionalTypeResourceManagerRole.allocationSize(value.`freezeRoles`) +
            FfiConverterOptionalTypeResourceManagerRole.allocationSize(value.`recallRoles`) +
            FfiConverterOptionalTypeResourceManagerRole.allocationSize(value.`withdrawRoles`) +
            FfiConverterOptionalTypeResourceManagerRole.allocationSize(value.`depositRoles`)
    )

    override fun write(value: FungibleResourceRoles, buf: ByteBuffer) {
            FfiConverterOptionalTypeResourceManagerRole.write(value.`mintRoles`, buf)
            FfiConverterOptionalTypeResourceManagerRole.write(value.`burnRoles`, buf)
            FfiConverterOptionalTypeResourceManagerRole.write(value.`freezeRoles`, buf)
            FfiConverterOptionalTypeResourceManagerRole.write(value.`recallRoles`, buf)
            FfiConverterOptionalTypeResourceManagerRole.write(value.`withdrawRoles`, buf)
            FfiConverterOptionalTypeResourceManagerRole.write(value.`depositRoles`, buf)
    }
}




data class FungibleVaultDepositEvent (
    var `amount`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`amount`)
    }
    
}

public object FfiConverterTypeFungibleVaultDepositEvent: FfiConverterRustBuffer<FungibleVaultDepositEvent> {
    override fun read(buf: ByteBuffer): FungibleVaultDepositEvent {
        return FungibleVaultDepositEvent(
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: FungibleVaultDepositEvent) = (
            FfiConverterTypeDecimal.allocationSize(value.`amount`)
    )

    override fun write(value: FungibleVaultDepositEvent, buf: ByteBuffer) {
            FfiConverterTypeDecimal.write(value.`amount`, buf)
    }
}




data class FungibleVaultLockFeeEvent (
    var `amount`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`amount`)
    }
    
}

public object FfiConverterTypeFungibleVaultLockFeeEvent: FfiConverterRustBuffer<FungibleVaultLockFeeEvent> {
    override fun read(buf: ByteBuffer): FungibleVaultLockFeeEvent {
        return FungibleVaultLockFeeEvent(
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: FungibleVaultLockFeeEvent) = (
            FfiConverterTypeDecimal.allocationSize(value.`amount`)
    )

    override fun write(value: FungibleVaultLockFeeEvent, buf: ByteBuffer) {
            FfiConverterTypeDecimal.write(value.`amount`, buf)
    }
}




data class FungibleVaultPayFeeEvent (
    var `amount`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`amount`)
    }
    
}

public object FfiConverterTypeFungibleVaultPayFeeEvent: FfiConverterRustBuffer<FungibleVaultPayFeeEvent> {
    override fun read(buf: ByteBuffer): FungibleVaultPayFeeEvent {
        return FungibleVaultPayFeeEvent(
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: FungibleVaultPayFeeEvent) = (
            FfiConverterTypeDecimal.allocationSize(value.`amount`)
    )

    override fun write(value: FungibleVaultPayFeeEvent, buf: ByteBuffer) {
            FfiConverterTypeDecimal.write(value.`amount`, buf)
    }
}




data class FungibleVaultRecallEvent (
    var `amount`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`amount`)
    }
    
}

public object FfiConverterTypeFungibleVaultRecallEvent: FfiConverterRustBuffer<FungibleVaultRecallEvent> {
    override fun read(buf: ByteBuffer): FungibleVaultRecallEvent {
        return FungibleVaultRecallEvent(
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: FungibleVaultRecallEvent) = (
            FfiConverterTypeDecimal.allocationSize(value.`amount`)
    )

    override fun write(value: FungibleVaultRecallEvent, buf: ByteBuffer) {
            FfiConverterTypeDecimal.write(value.`amount`, buf)
    }
}




data class FungibleVaultWithdrawEvent (
    var `amount`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`amount`)
    }
    
}

public object FfiConverterTypeFungibleVaultWithdrawEvent: FfiConverterRustBuffer<FungibleVaultWithdrawEvent> {
    override fun read(buf: ByteBuffer): FungibleVaultWithdrawEvent {
        return FungibleVaultWithdrawEvent(
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: FungibleVaultWithdrawEvent) = (
            FfiConverterTypeDecimal.allocationSize(value.`amount`)
    )

    override fun write(value: FungibleVaultWithdrawEvent, buf: ByteBuffer) {
            FfiConverterTypeDecimal.write(value.`amount`, buf)
    }
}




data class IndexedAssertion (
    var `index`: ULong, 
    var `assertion`: Assertion
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`index`, 
        this.`assertion`)
    }
    
}

public object FfiConverterTypeIndexedAssertion: FfiConverterRustBuffer<IndexedAssertion> {
    override fun read(buf: ByteBuffer): IndexedAssertion {
        return IndexedAssertion(
            FfiConverterULong.read(buf),
            FfiConverterTypeAssertion.read(buf),
        )
    }

    override fun allocationSize(value: IndexedAssertion) = (
            FfiConverterULong.allocationSize(value.`index`) +
            FfiConverterTypeAssertion.allocationSize(value.`assertion`)
    )

    override fun write(value: IndexedAssertion, buf: ByteBuffer) {
            FfiConverterULong.write(value.`index`, buf)
            FfiConverterTypeAssertion.write(value.`assertion`, buf)
    }
}




data class InitiateBadgeWithdrawAttemptEvent (
    var `proposer`: Proposer
) {
    
}

public object FfiConverterTypeInitiateBadgeWithdrawAttemptEvent: FfiConverterRustBuffer<InitiateBadgeWithdrawAttemptEvent> {
    override fun read(buf: ByteBuffer): InitiateBadgeWithdrawAttemptEvent {
        return InitiateBadgeWithdrawAttemptEvent(
            FfiConverterTypeProposer.read(buf),
        )
    }

    override fun allocationSize(value: InitiateBadgeWithdrawAttemptEvent) = (
            FfiConverterTypeProposer.allocationSize(value.`proposer`)
    )

    override fun write(value: InitiateBadgeWithdrawAttemptEvent, buf: ByteBuffer) {
            FfiConverterTypeProposer.write(value.`proposer`, buf)
    }
}




data class InitiateRecoveryEvent (
    var `proposer`: Proposer, 
    var `proposal`: RecoveryProposal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`proposer`, 
        this.`proposal`)
    }
    
}

public object FfiConverterTypeInitiateRecoveryEvent: FfiConverterRustBuffer<InitiateRecoveryEvent> {
    override fun read(buf: ByteBuffer): InitiateRecoveryEvent {
        return InitiateRecoveryEvent(
            FfiConverterTypeProposer.read(buf),
            FfiConverterTypeRecoveryProposal.read(buf),
        )
    }

    override fun allocationSize(value: InitiateRecoveryEvent) = (
            FfiConverterTypeProposer.allocationSize(value.`proposer`) +
            FfiConverterTypeRecoveryProposal.allocationSize(value.`proposal`)
    )

    override fun write(value: InitiateRecoveryEvent, buf: ByteBuffer) {
            FfiConverterTypeProposer.write(value.`proposer`, buf)
            FfiConverterTypeRecoveryProposal.write(value.`proposal`, buf)
    }
}




data class KnownAddresses (
    var `resourceAddresses`: ResourceAddresses, 
    var `packageAddresses`: PackageAddresses, 
    var `componentAddresses`: ComponentAddresses
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`resourceAddresses`, 
        this.`packageAddresses`, 
        this.`componentAddresses`)
    }
    
}

public object FfiConverterTypeKnownAddresses: FfiConverterRustBuffer<KnownAddresses> {
    override fun read(buf: ByteBuffer): KnownAddresses {
        return KnownAddresses(
            FfiConverterTypeResourceAddresses.read(buf),
            FfiConverterTypePackageAddresses.read(buf),
            FfiConverterTypeComponentAddresses.read(buf),
        )
    }

    override fun allocationSize(value: KnownAddresses) = (
            FfiConverterTypeResourceAddresses.allocationSize(value.`resourceAddresses`) +
            FfiConverterTypePackageAddresses.allocationSize(value.`packageAddresses`) +
            FfiConverterTypeComponentAddresses.allocationSize(value.`componentAddresses`)
    )

    override fun write(value: KnownAddresses, buf: ByteBuffer) {
            FfiConverterTypeResourceAddresses.write(value.`resourceAddresses`, buf)
            FfiConverterTypePackageAddresses.write(value.`packageAddresses`, buf)
            FfiConverterTypeComponentAddresses.write(value.`componentAddresses`, buf)
    }
}




data class LockFeeEvent (
    var `amount`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`amount`)
    }
    
}

public object FfiConverterTypeLockFeeEvent: FfiConverterRustBuffer<LockFeeEvent> {
    override fun read(buf: ByteBuffer): LockFeeEvent {
        return LockFeeEvent(
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: LockFeeEvent) = (
            FfiConverterTypeDecimal.allocationSize(value.`amount`)
    )

    override fun write(value: LockFeeEvent, buf: ByteBuffer) {
            FfiConverterTypeDecimal.write(value.`amount`, buf)
    }
}




data class LockFeeModification (
    var `accountAddress`: Address, 
    var `amount`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`accountAddress`, 
        this.`amount`)
    }
    
}

public object FfiConverterTypeLockFeeModification: FfiConverterRustBuffer<LockFeeModification> {
    override fun read(buf: ByteBuffer): LockFeeModification {
        return LockFeeModification(
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: LockFeeModification) = (
            FfiConverterTypeAddress.allocationSize(value.`accountAddress`) +
            FfiConverterTypeDecimal.allocationSize(value.`amount`)
    )

    override fun write(value: LockFeeModification, buf: ByteBuffer) {
            FfiConverterTypeAddress.write(value.`accountAddress`, buf)
            FfiConverterTypeDecimal.write(value.`amount`, buf)
    }
}




data class LockOwnerRoleEvent (
    var `placeholderField`: Boolean
) {
    
}

public object FfiConverterTypeLockOwnerRoleEvent: FfiConverterRustBuffer<LockOwnerRoleEvent> {
    override fun read(buf: ByteBuffer): LockOwnerRoleEvent {
        return LockOwnerRoleEvent(
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: LockOwnerRoleEvent) = (
            FfiConverterBoolean.allocationSize(value.`placeholderField`)
    )

    override fun write(value: LockOwnerRoleEvent, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`placeholderField`, buf)
    }
}




data class LockPrimaryRoleEvent (
    var `placeholderField`: Boolean
) {
    
}

public object FfiConverterTypeLockPrimaryRoleEvent: FfiConverterRustBuffer<LockPrimaryRoleEvent> {
    override fun read(buf: ByteBuffer): LockPrimaryRoleEvent {
        return LockPrimaryRoleEvent(
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: LockPrimaryRoleEvent) = (
            FfiConverterBoolean.allocationSize(value.`placeholderField`)
    )

    override fun write(value: LockPrimaryRoleEvent, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`placeholderField`, buf)
    }
}




data class LockRoleEvent (
    var `roleKey`: String
) {
    
}

public object FfiConverterTypeLockRoleEvent: FfiConverterRustBuffer<LockRoleEvent> {
    override fun read(buf: ByteBuffer): LockRoleEvent {
        return LockRoleEvent(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: LockRoleEvent) = (
            FfiConverterString.allocationSize(value.`roleKey`)
    )

    override fun write(value: LockRoleEvent, buf: ByteBuffer) {
            FfiConverterString.write(value.`roleKey`, buf)
    }
}




data class ManifestAddressReservation (
    var `value`: UInt
) {
    
}

public object FfiConverterTypeManifestAddressReservation: FfiConverterRustBuffer<ManifestAddressReservation> {
    override fun read(buf: ByteBuffer): ManifestAddressReservation {
        return ManifestAddressReservation(
            FfiConverterUInt.read(buf),
        )
    }

    override fun allocationSize(value: ManifestAddressReservation) = (
            FfiConverterUInt.allocationSize(value.`value`)
    )

    override fun write(value: ManifestAddressReservation, buf: ByteBuffer) {
            FfiConverterUInt.write(value.`value`, buf)
    }
}




data class ManifestBlobRef (
    var `value`: Hash
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`value`)
    }
    
}

public object FfiConverterTypeManifestBlobRef: FfiConverterRustBuffer<ManifestBlobRef> {
    override fun read(buf: ByteBuffer): ManifestBlobRef {
        return ManifestBlobRef(
            FfiConverterTypeHash.read(buf),
        )
    }

    override fun allocationSize(value: ManifestBlobRef) = (
            FfiConverterTypeHash.allocationSize(value.`value`)
    )

    override fun write(value: ManifestBlobRef, buf: ByteBuffer) {
            FfiConverterTypeHash.write(value.`value`, buf)
    }
}




data class ManifestBucket (
    var `value`: UInt
) {
    
}

public object FfiConverterTypeManifestBucket: FfiConverterRustBuffer<ManifestBucket> {
    override fun read(buf: ByteBuffer): ManifestBucket {
        return ManifestBucket(
            FfiConverterUInt.read(buf),
        )
    }

    override fun allocationSize(value: ManifestBucket) = (
            FfiConverterUInt.allocationSize(value.`value`)
    )

    override fun write(value: ManifestBucket, buf: ByteBuffer) {
            FfiConverterUInt.write(value.`value`, buf)
    }
}




data class ManifestBuilderAddressReservation (
    var `name`: String
) {
    
}

public object FfiConverterTypeManifestBuilderAddressReservation: FfiConverterRustBuffer<ManifestBuilderAddressReservation> {
    override fun read(buf: ByteBuffer): ManifestBuilderAddressReservation {
        return ManifestBuilderAddressReservation(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ManifestBuilderAddressReservation) = (
            FfiConverterString.allocationSize(value.`name`)
    )

    override fun write(value: ManifestBuilderAddressReservation, buf: ByteBuffer) {
            FfiConverterString.write(value.`name`, buf)
    }
}




data class ManifestBuilderBucket (
    var `name`: String
) {
    
}

public object FfiConverterTypeManifestBuilderBucket: FfiConverterRustBuffer<ManifestBuilderBucket> {
    override fun read(buf: ByteBuffer): ManifestBuilderBucket {
        return ManifestBuilderBucket(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ManifestBuilderBucket) = (
            FfiConverterString.allocationSize(value.`name`)
    )

    override fun write(value: ManifestBuilderBucket, buf: ByteBuffer) {
            FfiConverterString.write(value.`name`, buf)
    }
}




data class ManifestBuilderMapEntry (
    var `key`: ManifestBuilderValue, 
    var `value`: ManifestBuilderValue
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`key`, 
        this.`value`)
    }
    
}

public object FfiConverterTypeManifestBuilderMapEntry: FfiConverterRustBuffer<ManifestBuilderMapEntry> {
    override fun read(buf: ByteBuffer): ManifestBuilderMapEntry {
        return ManifestBuilderMapEntry(
            FfiConverterTypeManifestBuilderValue.read(buf),
            FfiConverterTypeManifestBuilderValue.read(buf),
        )
    }

    override fun allocationSize(value: ManifestBuilderMapEntry) = (
            FfiConverterTypeManifestBuilderValue.allocationSize(value.`key`) +
            FfiConverterTypeManifestBuilderValue.allocationSize(value.`value`)
    )

    override fun write(value: ManifestBuilderMapEntry, buf: ByteBuffer) {
            FfiConverterTypeManifestBuilderValue.write(value.`key`, buf)
            FfiConverterTypeManifestBuilderValue.write(value.`value`, buf)
    }
}




data class ManifestBuilderNamedAddress (
    var `name`: String
) {
    
}

public object FfiConverterTypeManifestBuilderNamedAddress: FfiConverterRustBuffer<ManifestBuilderNamedAddress> {
    override fun read(buf: ByteBuffer): ManifestBuilderNamedAddress {
        return ManifestBuilderNamedAddress(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ManifestBuilderNamedAddress) = (
            FfiConverterString.allocationSize(value.`name`)
    )

    override fun write(value: ManifestBuilderNamedAddress, buf: ByteBuffer) {
            FfiConverterString.write(value.`name`, buf)
    }
}




data class ManifestBuilderProof (
    var `name`: String
) {
    
}

public object FfiConverterTypeManifestBuilderProof: FfiConverterRustBuffer<ManifestBuilderProof> {
    override fun read(buf: ByteBuffer): ManifestBuilderProof {
        return ManifestBuilderProof(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ManifestBuilderProof) = (
            FfiConverterString.allocationSize(value.`name`)
    )

    override fun write(value: ManifestBuilderProof, buf: ByteBuffer) {
            FfiConverterString.write(value.`name`, buf)
    }
}




data class ManifestProof (
    var `value`: UInt
) {
    
}

public object FfiConverterTypeManifestProof: FfiConverterRustBuffer<ManifestProof> {
    override fun read(buf: ByteBuffer): ManifestProof {
        return ManifestProof(
            FfiConverterUInt.read(buf),
        )
    }

    override fun allocationSize(value: ManifestProof) = (
            FfiConverterUInt.allocationSize(value.`value`)
    )

    override fun write(value: ManifestProof, buf: ByteBuffer) {
            FfiConverterUInt.write(value.`value`, buf)
    }
}




data class MapEntry (
    var `key`: ManifestValue, 
    var `value`: ManifestValue
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`key`, 
        this.`value`)
    }
    
}

public object FfiConverterTypeMapEntry: FfiConverterRustBuffer<MapEntry> {
    override fun read(buf: ByteBuffer): MapEntry {
        return MapEntry(
            FfiConverterTypeManifestValue.read(buf),
            FfiConverterTypeManifestValue.read(buf),
        )
    }

    override fun allocationSize(value: MapEntry) = (
            FfiConverterTypeManifestValue.allocationSize(value.`key`) +
            FfiConverterTypeManifestValue.allocationSize(value.`value`)
    )

    override fun write(value: MapEntry, buf: ByteBuffer) {
            FfiConverterTypeManifestValue.write(value.`key`, buf)
            FfiConverterTypeManifestValue.write(value.`value`, buf)
    }
}




data class MetadataInitEntry (
    var `value`: MetadataValue?, 
    var `lock`: Boolean
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`value`, 
        this.`lock`)
    }
    
}

public object FfiConverterTypeMetadataInitEntry: FfiConverterRustBuffer<MetadataInitEntry> {
    override fun read(buf: ByteBuffer): MetadataInitEntry {
        return MetadataInitEntry(
            FfiConverterOptionalTypeMetadataValue.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: MetadataInitEntry) = (
            FfiConverterOptionalTypeMetadataValue.allocationSize(value.`value`) +
            FfiConverterBoolean.allocationSize(value.`lock`)
    )

    override fun write(value: MetadataInitEntry, buf: ByteBuffer) {
            FfiConverterOptionalTypeMetadataValue.write(value.`value`, buf)
            FfiConverterBoolean.write(value.`lock`, buf)
    }
}




data class MetadataModuleConfig (
    var `init`: Map<String, MetadataInitEntry>, 
    var `roles`: Map<String, AccessRule?>
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`init`, 
        this.`roles`)
    }
    
}

public object FfiConverterTypeMetadataModuleConfig: FfiConverterRustBuffer<MetadataModuleConfig> {
    override fun read(buf: ByteBuffer): MetadataModuleConfig {
        return MetadataModuleConfig(
            FfiConverterMapStringTypeMetadataInitEntry.read(buf),
            FfiConverterMapStringOptionalTypeAccessRule.read(buf),
        )
    }

    override fun allocationSize(value: MetadataModuleConfig) = (
            FfiConverterMapStringTypeMetadataInitEntry.allocationSize(value.`init`) +
            FfiConverterMapStringOptionalTypeAccessRule.allocationSize(value.`roles`)
    )

    override fun write(value: MetadataModuleConfig, buf: ByteBuffer) {
            FfiConverterMapStringTypeMetadataInitEntry.write(value.`init`, buf)
            FfiConverterMapStringOptionalTypeAccessRule.write(value.`roles`, buf)
    }
}




data class MintFungibleResourceEvent (
    var `amount`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`amount`)
    }
    
}

public object FfiConverterTypeMintFungibleResourceEvent: FfiConverterRustBuffer<MintFungibleResourceEvent> {
    override fun read(buf: ByteBuffer): MintFungibleResourceEvent {
        return MintFungibleResourceEvent(
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: MintFungibleResourceEvent) = (
            FfiConverterTypeDecimal.allocationSize(value.`amount`)
    )

    override fun write(value: MintFungibleResourceEvent, buf: ByteBuffer) {
            FfiConverterTypeDecimal.write(value.`amount`, buf)
    }
}




data class MintNonFungibleResourceEvent (
    var `ids`: List<NonFungibleLocalId>
) {
    
}

public object FfiConverterTypeMintNonFungibleResourceEvent: FfiConverterRustBuffer<MintNonFungibleResourceEvent> {
    override fun read(buf: ByteBuffer): MintNonFungibleResourceEvent {
        return MintNonFungibleResourceEvent(
            FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
        )
    }

    override fun allocationSize(value: MintNonFungibleResourceEvent) = (
            FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`ids`)
    )

    override fun write(value: MintNonFungibleResourceEvent, buf: ByteBuffer) {
            FfiConverterSequenceTypeNonFungibleLocalId.write(value.`ids`, buf)
    }
}




data class MultiResourcePoolContributionEvent (
    var `contributedResources`: Map<String, Decimal>, 
    var `poolUnitsMinted`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`contributedResources`, 
        this.`poolUnitsMinted`)
    }
    
}

public object FfiConverterTypeMultiResourcePoolContributionEvent: FfiConverterRustBuffer<MultiResourcePoolContributionEvent> {
    override fun read(buf: ByteBuffer): MultiResourcePoolContributionEvent {
        return MultiResourcePoolContributionEvent(
            FfiConverterMapStringTypeDecimal.read(buf),
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: MultiResourcePoolContributionEvent) = (
            FfiConverterMapStringTypeDecimal.allocationSize(value.`contributedResources`) +
            FfiConverterTypeDecimal.allocationSize(value.`poolUnitsMinted`)
    )

    override fun write(value: MultiResourcePoolContributionEvent, buf: ByteBuffer) {
            FfiConverterMapStringTypeDecimal.write(value.`contributedResources`, buf)
            FfiConverterTypeDecimal.write(value.`poolUnitsMinted`, buf)
    }
}




data class MultiResourcePoolDepositEvent (
    var `resourceAddress`: Address, 
    var `amount`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`amount`)
    }
    
}

public object FfiConverterTypeMultiResourcePoolDepositEvent: FfiConverterRustBuffer<MultiResourcePoolDepositEvent> {
    override fun read(buf: ByteBuffer): MultiResourcePoolDepositEvent {
        return MultiResourcePoolDepositEvent(
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: MultiResourcePoolDepositEvent) = (
            FfiConverterTypeAddress.allocationSize(value.`resourceAddress`) +
            FfiConverterTypeDecimal.allocationSize(value.`amount`)
    )

    override fun write(value: MultiResourcePoolDepositEvent, buf: ByteBuffer) {
            FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
            FfiConverterTypeDecimal.write(value.`amount`, buf)
    }
}




data class MultiResourcePoolRedemptionEvent (
    var `poolUnitTokensRedeemed`: Decimal, 
    var `redeemedResources`: Map<String, Decimal>
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`poolUnitTokensRedeemed`, 
        this.`redeemedResources`)
    }
    
}

public object FfiConverterTypeMultiResourcePoolRedemptionEvent: FfiConverterRustBuffer<MultiResourcePoolRedemptionEvent> {
    override fun read(buf: ByteBuffer): MultiResourcePoolRedemptionEvent {
        return MultiResourcePoolRedemptionEvent(
            FfiConverterTypeDecimal.read(buf),
            FfiConverterMapStringTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: MultiResourcePoolRedemptionEvent) = (
            FfiConverterTypeDecimal.allocationSize(value.`poolUnitTokensRedeemed`) +
            FfiConverterMapStringTypeDecimal.allocationSize(value.`redeemedResources`)
    )

    override fun write(value: MultiResourcePoolRedemptionEvent, buf: ByteBuffer) {
            FfiConverterTypeDecimal.write(value.`poolUnitTokensRedeemed`, buf)
            FfiConverterMapStringTypeDecimal.write(value.`redeemedResources`, buf)
    }
}




data class MultiResourcePoolWithdrawEvent (
    var `resourceAddress`: Address, 
    var `amount`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`amount`)
    }
    
}

public object FfiConverterTypeMultiResourcePoolWithdrawEvent: FfiConverterRustBuffer<MultiResourcePoolWithdrawEvent> {
    override fun read(buf: ByteBuffer): MultiResourcePoolWithdrawEvent {
        return MultiResourcePoolWithdrawEvent(
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: MultiResourcePoolWithdrawEvent) = (
            FfiConverterTypeAddress.allocationSize(value.`resourceAddress`) +
            FfiConverterTypeDecimal.allocationSize(value.`amount`)
    )

    override fun write(value: MultiResourcePoolWithdrawEvent, buf: ByteBuffer) {
            FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
            FfiConverterTypeDecimal.write(value.`amount`, buf)
    }
}




data class NonFungibleVaultDepositEvent (
    var `ids`: List<NonFungibleLocalId>
) {
    
}

public object FfiConverterTypeNonFungibleVaultDepositEvent: FfiConverterRustBuffer<NonFungibleVaultDepositEvent> {
    override fun read(buf: ByteBuffer): NonFungibleVaultDepositEvent {
        return NonFungibleVaultDepositEvent(
            FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
        )
    }

    override fun allocationSize(value: NonFungibleVaultDepositEvent) = (
            FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`ids`)
    )

    override fun write(value: NonFungibleVaultDepositEvent, buf: ByteBuffer) {
            FfiConverterSequenceTypeNonFungibleLocalId.write(value.`ids`, buf)
    }
}




data class NonFungibleVaultRecallEvent (
    var `ids`: List<NonFungibleLocalId>
) {
    
}

public object FfiConverterTypeNonFungibleVaultRecallEvent: FfiConverterRustBuffer<NonFungibleVaultRecallEvent> {
    override fun read(buf: ByteBuffer): NonFungibleVaultRecallEvent {
        return NonFungibleVaultRecallEvent(
            FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
        )
    }

    override fun allocationSize(value: NonFungibleVaultRecallEvent) = (
            FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`ids`)
    )

    override fun write(value: NonFungibleVaultRecallEvent, buf: ByteBuffer) {
            FfiConverterSequenceTypeNonFungibleLocalId.write(value.`ids`, buf)
    }
}




data class NonFungibleVaultWithdrawEvent (
    var `ids`: List<NonFungibleLocalId>
) {
    
}

public object FfiConverterTypeNonFungibleVaultWithdrawEvent: FfiConverterRustBuffer<NonFungibleVaultWithdrawEvent> {
    override fun read(buf: ByteBuffer): NonFungibleVaultWithdrawEvent {
        return NonFungibleVaultWithdrawEvent(
            FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
        )
    }

    override fun allocationSize(value: NonFungibleVaultWithdrawEvent) = (
            FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`ids`)
    )

    override fun write(value: NonFungibleVaultWithdrawEvent, buf: ByteBuffer) {
            FfiConverterSequenceTypeNonFungibleLocalId.write(value.`ids`, buf)
    }
}




data class OneResourcePoolContributionEvent (
    var `amountOfResourcesContributed`: Decimal, 
    var `poolUnitsMinted`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`amountOfResourcesContributed`, 
        this.`poolUnitsMinted`)
    }
    
}

public object FfiConverterTypeOneResourcePoolContributionEvent: FfiConverterRustBuffer<OneResourcePoolContributionEvent> {
    override fun read(buf: ByteBuffer): OneResourcePoolContributionEvent {
        return OneResourcePoolContributionEvent(
            FfiConverterTypeDecimal.read(buf),
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: OneResourcePoolContributionEvent) = (
            FfiConverterTypeDecimal.allocationSize(value.`amountOfResourcesContributed`) +
            FfiConverterTypeDecimal.allocationSize(value.`poolUnitsMinted`)
    )

    override fun write(value: OneResourcePoolContributionEvent, buf: ByteBuffer) {
            FfiConverterTypeDecimal.write(value.`amountOfResourcesContributed`, buf)
            FfiConverterTypeDecimal.write(value.`poolUnitsMinted`, buf)
    }
}




data class OneResourcePoolDepositEvent (
    var `amount`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`amount`)
    }
    
}

public object FfiConverterTypeOneResourcePoolDepositEvent: FfiConverterRustBuffer<OneResourcePoolDepositEvent> {
    override fun read(buf: ByteBuffer): OneResourcePoolDepositEvent {
        return OneResourcePoolDepositEvent(
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: OneResourcePoolDepositEvent) = (
            FfiConverterTypeDecimal.allocationSize(value.`amount`)
    )

    override fun write(value: OneResourcePoolDepositEvent, buf: ByteBuffer) {
            FfiConverterTypeDecimal.write(value.`amount`, buf)
    }
}




data class OneResourcePoolRedemptionEvent (
    var `poolUnitTokensRedeemed`: Decimal, 
    var `redeemedAmount`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`poolUnitTokensRedeemed`, 
        this.`redeemedAmount`)
    }
    
}

public object FfiConverterTypeOneResourcePoolRedemptionEvent: FfiConverterRustBuffer<OneResourcePoolRedemptionEvent> {
    override fun read(buf: ByteBuffer): OneResourcePoolRedemptionEvent {
        return OneResourcePoolRedemptionEvent(
            FfiConverterTypeDecimal.read(buf),
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: OneResourcePoolRedemptionEvent) = (
            FfiConverterTypeDecimal.allocationSize(value.`poolUnitTokensRedeemed`) +
            FfiConverterTypeDecimal.allocationSize(value.`redeemedAmount`)
    )

    override fun write(value: OneResourcePoolRedemptionEvent, buf: ByteBuffer) {
            FfiConverterTypeDecimal.write(value.`poolUnitTokensRedeemed`, buf)
            FfiConverterTypeDecimal.write(value.`redeemedAmount`, buf)
    }
}




data class OneResourcePoolWithdrawEvent (
    var `amount`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`amount`)
    }
    
}

public object FfiConverterTypeOneResourcePoolWithdrawEvent: FfiConverterRustBuffer<OneResourcePoolWithdrawEvent> {
    override fun read(buf: ByteBuffer): OneResourcePoolWithdrawEvent {
        return OneResourcePoolWithdrawEvent(
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: OneResourcePoolWithdrawEvent) = (
            FfiConverterTypeDecimal.allocationSize(value.`amount`)
    )

    override fun write(value: OneResourcePoolWithdrawEvent, buf: ByteBuffer) {
            FfiConverterTypeDecimal.write(value.`amount`, buf)
    }
}




data class PackageAddresses (
    var `packagePackage`: Address, 
    var `resourcePackage`: Address, 
    var `accountPackage`: Address, 
    var `identityPackage`: Address, 
    var `consensusManagerPackage`: Address, 
    var `accessControllerPackage`: Address, 
    var `poolPackage`: Address, 
    var `transactionProcessorPackage`: Address, 
    var `metadataModulePackage`: Address, 
    var `royaltyModulePackage`: Address, 
    var `roleAssignmentModulePackage`: Address, 
    var `genesisHelperPackage`: Address, 
    var `faucetPackage`: Address
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`packagePackage`, 
        this.`resourcePackage`, 
        this.`accountPackage`, 
        this.`identityPackage`, 
        this.`consensusManagerPackage`, 
        this.`accessControllerPackage`, 
        this.`poolPackage`, 
        this.`transactionProcessorPackage`, 
        this.`metadataModulePackage`, 
        this.`royaltyModulePackage`, 
        this.`roleAssignmentModulePackage`, 
        this.`genesisHelperPackage`, 
        this.`faucetPackage`)
    }
    
}

public object FfiConverterTypePackageAddresses: FfiConverterRustBuffer<PackageAddresses> {
    override fun read(buf: ByteBuffer): PackageAddresses {
        return PackageAddresses(
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
        )
    }

    override fun allocationSize(value: PackageAddresses) = (
            FfiConverterTypeAddress.allocationSize(value.`packagePackage`) +
            FfiConverterTypeAddress.allocationSize(value.`resourcePackage`) +
            FfiConverterTypeAddress.allocationSize(value.`accountPackage`) +
            FfiConverterTypeAddress.allocationSize(value.`identityPackage`) +
            FfiConverterTypeAddress.allocationSize(value.`consensusManagerPackage`) +
            FfiConverterTypeAddress.allocationSize(value.`accessControllerPackage`) +
            FfiConverterTypeAddress.allocationSize(value.`poolPackage`) +
            FfiConverterTypeAddress.allocationSize(value.`transactionProcessorPackage`) +
            FfiConverterTypeAddress.allocationSize(value.`metadataModulePackage`) +
            FfiConverterTypeAddress.allocationSize(value.`royaltyModulePackage`) +
            FfiConverterTypeAddress.allocationSize(value.`roleAssignmentModulePackage`) +
            FfiConverterTypeAddress.allocationSize(value.`genesisHelperPackage`) +
            FfiConverterTypeAddress.allocationSize(value.`faucetPackage`)
    )

    override fun write(value: PackageAddresses, buf: ByteBuffer) {
            FfiConverterTypeAddress.write(value.`packagePackage`, buf)
            FfiConverterTypeAddress.write(value.`resourcePackage`, buf)
            FfiConverterTypeAddress.write(value.`accountPackage`, buf)
            FfiConverterTypeAddress.write(value.`identityPackage`, buf)
            FfiConverterTypeAddress.write(value.`consensusManagerPackage`, buf)
            FfiConverterTypeAddress.write(value.`accessControllerPackage`, buf)
            FfiConverterTypeAddress.write(value.`poolPackage`, buf)
            FfiConverterTypeAddress.write(value.`transactionProcessorPackage`, buf)
            FfiConverterTypeAddress.write(value.`metadataModulePackage`, buf)
            FfiConverterTypeAddress.write(value.`royaltyModulePackage`, buf)
            FfiConverterTypeAddress.write(value.`roleAssignmentModulePackage`, buf)
            FfiConverterTypeAddress.write(value.`genesisHelperPackage`, buf)
            FfiConverterTypeAddress.write(value.`faucetPackage`, buf)
    }
}




data class PlainTextMessage (
    var `mimeType`: String, 
    var `message`: MessageContent
) {
    
}

public object FfiConverterTypePlainTextMessage: FfiConverterRustBuffer<PlainTextMessage> {
    override fun read(buf: ByteBuffer): PlainTextMessage {
        return PlainTextMessage(
            FfiConverterString.read(buf),
            FfiConverterTypeMessageContent.read(buf),
        )
    }

    override fun allocationSize(value: PlainTextMessage) = (
            FfiConverterString.allocationSize(value.`mimeType`) +
            FfiConverterTypeMessageContent.allocationSize(value.`message`)
    )

    override fun write(value: PlainTextMessage, buf: ByteBuffer) {
            FfiConverterString.write(value.`mimeType`, buf)
            FfiConverterTypeMessageContent.write(value.`message`, buf)
    }
}




data class ProtocolUpdateReadinessSignalEvent (
    var `protocolVersionName`: String
) {
    
}

public object FfiConverterTypeProtocolUpdateReadinessSignalEvent: FfiConverterRustBuffer<ProtocolUpdateReadinessSignalEvent> {
    override fun read(buf: ByteBuffer): ProtocolUpdateReadinessSignalEvent {
        return ProtocolUpdateReadinessSignalEvent(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ProtocolUpdateReadinessSignalEvent) = (
            FfiConverterString.allocationSize(value.`protocolVersionName`)
    )

    override fun write(value: ProtocolUpdateReadinessSignalEvent, buf: ByteBuffer) {
            FfiConverterString.write(value.`protocolVersionName`, buf)
    }
}




data class RecoveryProposal (
    var `ruleSet`: RuleSet, 
    var `timedRecoveryDelayInMinutes`: UInt?
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`ruleSet`, 
        this.`timedRecoveryDelayInMinutes`)
    }
    
}

public object FfiConverterTypeRecoveryProposal: FfiConverterRustBuffer<RecoveryProposal> {
    override fun read(buf: ByteBuffer): RecoveryProposal {
        return RecoveryProposal(
            FfiConverterTypeRuleSet.read(buf),
            FfiConverterOptionalUInt.read(buf),
        )
    }

    override fun allocationSize(value: RecoveryProposal) = (
            FfiConverterTypeRuleSet.allocationSize(value.`ruleSet`) +
            FfiConverterOptionalUInt.allocationSize(value.`timedRecoveryDelayInMinutes`)
    )

    override fun write(value: RecoveryProposal, buf: ByteBuffer) {
            FfiConverterTypeRuleSet.write(value.`ruleSet`, buf)
            FfiConverterOptionalUInt.write(value.`timedRecoveryDelayInMinutes`, buf)
    }
}




data class RegisterValidatorEvent (
    var `placeholderField`: Boolean
) {
    
}

public object FfiConverterTypeRegisterValidatorEvent: FfiConverterRustBuffer<RegisterValidatorEvent> {
    override fun read(buf: ByteBuffer): RegisterValidatorEvent {
        return RegisterValidatorEvent(
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: RegisterValidatorEvent) = (
            FfiConverterBoolean.allocationSize(value.`placeholderField`)
    )

    override fun write(value: RegisterValidatorEvent, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`placeholderField`, buf)
    }
}




data class RemoveMetadataEvent (
    var `key`: String
) {
    
}

public object FfiConverterTypeRemoveMetadataEvent: FfiConverterRustBuffer<RemoveMetadataEvent> {
    override fun read(buf: ByteBuffer): RemoveMetadataEvent {
        return RemoveMetadataEvent(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: RemoveMetadataEvent) = (
            FfiConverterString.allocationSize(value.`key`)
    )

    override fun write(value: RemoveMetadataEvent, buf: ByteBuffer) {
            FfiConverterString.write(value.`key`, buf)
    }
}




data class ResourceAddresses (
    var `xrd`: Address, 
    var `secp256k1SignatureVirtualBadge`: Address, 
    var `ed25519SignatureVirtualBadge`: Address, 
    var `packageOfDirectCallerVirtualBadge`: Address, 
    var `globalCallerVirtualBadge`: Address, 
    var `systemTransactionBadge`: Address, 
    var `packageOwnerBadge`: Address, 
    var `validatorOwnerBadge`: Address, 
    var `accountOwnerBadge`: Address, 
    var `identityOwnerBadge`: Address
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`xrd`, 
        this.`secp256k1SignatureVirtualBadge`, 
        this.`ed25519SignatureVirtualBadge`, 
        this.`packageOfDirectCallerVirtualBadge`, 
        this.`globalCallerVirtualBadge`, 
        this.`systemTransactionBadge`, 
        this.`packageOwnerBadge`, 
        this.`validatorOwnerBadge`, 
        this.`accountOwnerBadge`, 
        this.`identityOwnerBadge`)
    }
    
}

public object FfiConverterTypeResourceAddresses: FfiConverterRustBuffer<ResourceAddresses> {
    override fun read(buf: ByteBuffer): ResourceAddresses {
        return ResourceAddresses(
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
        )
    }

    override fun allocationSize(value: ResourceAddresses) = (
            FfiConverterTypeAddress.allocationSize(value.`xrd`) +
            FfiConverterTypeAddress.allocationSize(value.`secp256k1SignatureVirtualBadge`) +
            FfiConverterTypeAddress.allocationSize(value.`ed25519SignatureVirtualBadge`) +
            FfiConverterTypeAddress.allocationSize(value.`packageOfDirectCallerVirtualBadge`) +
            FfiConverterTypeAddress.allocationSize(value.`globalCallerVirtualBadge`) +
            FfiConverterTypeAddress.allocationSize(value.`systemTransactionBadge`) +
            FfiConverterTypeAddress.allocationSize(value.`packageOwnerBadge`) +
            FfiConverterTypeAddress.allocationSize(value.`validatorOwnerBadge`) +
            FfiConverterTypeAddress.allocationSize(value.`accountOwnerBadge`) +
            FfiConverterTypeAddress.allocationSize(value.`identityOwnerBadge`)
    )

    override fun write(value: ResourceAddresses, buf: ByteBuffer) {
            FfiConverterTypeAddress.write(value.`xrd`, buf)
            FfiConverterTypeAddress.write(value.`secp256k1SignatureVirtualBadge`, buf)
            FfiConverterTypeAddress.write(value.`ed25519SignatureVirtualBadge`, buf)
            FfiConverterTypeAddress.write(value.`packageOfDirectCallerVirtualBadge`, buf)
            FfiConverterTypeAddress.write(value.`globalCallerVirtualBadge`, buf)
            FfiConverterTypeAddress.write(value.`systemTransactionBadge`, buf)
            FfiConverterTypeAddress.write(value.`packageOwnerBadge`, buf)
            FfiConverterTypeAddress.write(value.`validatorOwnerBadge`, buf)
            FfiConverterTypeAddress.write(value.`accountOwnerBadge`, buf)
            FfiConverterTypeAddress.write(value.`identityOwnerBadge`, buf)
    }
}




data class ResourceManagerRole (
    var `role`: AccessRule?, 
    var `roleUpdater`: AccessRule?
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`role`, 
        this.`roleUpdater`)
    }
    
}

public object FfiConverterTypeResourceManagerRole: FfiConverterRustBuffer<ResourceManagerRole> {
    override fun read(buf: ByteBuffer): ResourceManagerRole {
        return ResourceManagerRole(
            FfiConverterOptionalTypeAccessRule.read(buf),
            FfiConverterOptionalTypeAccessRule.read(buf),
        )
    }

    override fun allocationSize(value: ResourceManagerRole) = (
            FfiConverterOptionalTypeAccessRule.allocationSize(value.`role`) +
            FfiConverterOptionalTypeAccessRule.allocationSize(value.`roleUpdater`)
    )

    override fun write(value: ResourceManagerRole, buf: ByteBuffer) {
            FfiConverterOptionalTypeAccessRule.write(value.`role`, buf)
            FfiConverterOptionalTypeAccessRule.write(value.`roleUpdater`, buf)
    }
}




data class RoundChangeEvent (
    var `round`: ULong
) {
    
}

public object FfiConverterTypeRoundChangeEvent: FfiConverterRustBuffer<RoundChangeEvent> {
    override fun read(buf: ByteBuffer): RoundChangeEvent {
        return RoundChangeEvent(
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: RoundChangeEvent) = (
            FfiConverterULong.allocationSize(value.`round`)
    )

    override fun write(value: RoundChangeEvent, buf: ByteBuffer) {
            FfiConverterULong.write(value.`round`, buf)
    }
}




data class RuleSet (
    var `primaryRole`: AccessRule, 
    var `recoveryRole`: AccessRule, 
    var `confirmationRole`: AccessRule
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`primaryRole`, 
        this.`recoveryRole`, 
        this.`confirmationRole`)
    }
    
}

public object FfiConverterTypeRuleSet: FfiConverterRustBuffer<RuleSet> {
    override fun read(buf: ByteBuffer): RuleSet {
        return RuleSet(
            FfiConverterTypeAccessRule.read(buf),
            FfiConverterTypeAccessRule.read(buf),
            FfiConverterTypeAccessRule.read(buf),
        )
    }

    override fun allocationSize(value: RuleSet) = (
            FfiConverterTypeAccessRule.allocationSize(value.`primaryRole`) +
            FfiConverterTypeAccessRule.allocationSize(value.`recoveryRole`) +
            FfiConverterTypeAccessRule.allocationSize(value.`confirmationRole`)
    )

    override fun write(value: RuleSet, buf: ByteBuffer) {
            FfiConverterTypeAccessRule.write(value.`primaryRole`, buf)
            FfiConverterTypeAccessRule.write(value.`recoveryRole`, buf)
            FfiConverterTypeAccessRule.write(value.`confirmationRole`, buf)
    }
}




data class RuleSetUpdateEvent (
    var `proposer`: Proposer, 
    var `proposal`: RecoveryProposal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`proposer`, 
        this.`proposal`)
    }
    
}

public object FfiConverterTypeRuleSetUpdateEvent: FfiConverterRustBuffer<RuleSetUpdateEvent> {
    override fun read(buf: ByteBuffer): RuleSetUpdateEvent {
        return RuleSetUpdateEvent(
            FfiConverterTypeProposer.read(buf),
            FfiConverterTypeRecoveryProposal.read(buf),
        )
    }

    override fun allocationSize(value: RuleSetUpdateEvent) = (
            FfiConverterTypeProposer.allocationSize(value.`proposer`) +
            FfiConverterTypeRecoveryProposal.allocationSize(value.`proposal`)
    )

    override fun write(value: RuleSetUpdateEvent, buf: ByteBuffer) {
            FfiConverterTypeProposer.write(value.`proposer`, buf)
            FfiConverterTypeRecoveryProposal.write(value.`proposal`, buf)
    }
}




data class Schema (
    var `localTypeId`: LocalTypeId, 
    var `schema`: List<UByte>
) {
    
}

public object FfiConverterTypeSchema: FfiConverterRustBuffer<Schema> {
    override fun read(buf: ByteBuffer): Schema {
        return Schema(
            FfiConverterTypeLocalTypeId.read(buf),
            FfiConverterSequenceUByte.read(buf),
        )
    }

    override fun allocationSize(value: Schema) = (
            FfiConverterTypeLocalTypeId.allocationSize(value.`localTypeId`) +
            FfiConverterSequenceUByte.allocationSize(value.`schema`)
    )

    override fun write(value: Schema, buf: ByteBuffer) {
            FfiConverterTypeLocalTypeId.write(value.`localTypeId`, buf)
            FfiConverterSequenceUByte.write(value.`schema`, buf)
    }
}




data class Secp256k1PublicKey (
    var `value`: List<UByte>
) {
    
}

public object FfiConverterTypeSecp256k1PublicKey: FfiConverterRustBuffer<Secp256k1PublicKey> {
    override fun read(buf: ByteBuffer): Secp256k1PublicKey {
        return Secp256k1PublicKey(
            FfiConverterSequenceUByte.read(buf),
        )
    }

    override fun allocationSize(value: Secp256k1PublicKey) = (
            FfiConverterSequenceUByte.allocationSize(value.`value`)
    )

    override fun write(value: Secp256k1PublicKey, buf: ByteBuffer) {
            FfiConverterSequenceUByte.write(value.`value`, buf)
    }
}




data class SecurityStructureRole (
    var `superAdminFactors`: List<PublicKey>, 
    var `thresholdFactors`: List<PublicKey>, 
    var `threshold`: UByte
) {
    
}

public object FfiConverterTypeSecurityStructureRole: FfiConverterRustBuffer<SecurityStructureRole> {
    override fun read(buf: ByteBuffer): SecurityStructureRole {
        return SecurityStructureRole(
            FfiConverterSequenceTypePublicKey.read(buf),
            FfiConverterSequenceTypePublicKey.read(buf),
            FfiConverterUByte.read(buf),
        )
    }

    override fun allocationSize(value: SecurityStructureRole) = (
            FfiConverterSequenceTypePublicKey.allocationSize(value.`superAdminFactors`) +
            FfiConverterSequenceTypePublicKey.allocationSize(value.`thresholdFactors`) +
            FfiConverterUByte.allocationSize(value.`threshold`)
    )

    override fun write(value: SecurityStructureRole, buf: ByteBuffer) {
            FfiConverterSequenceTypePublicKey.write(value.`superAdminFactors`, buf)
            FfiConverterSequenceTypePublicKey.write(value.`thresholdFactors`, buf)
            FfiConverterUByte.write(value.`threshold`, buf)
    }
}




data class SetAndLockRoleEvent (
    var `roleKey`: String, 
    var `rule`: AccessRule
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`roleKey`, 
        this.`rule`)
    }
    
}

public object FfiConverterTypeSetAndLockRoleEvent: FfiConverterRustBuffer<SetAndLockRoleEvent> {
    override fun read(buf: ByteBuffer): SetAndLockRoleEvent {
        return SetAndLockRoleEvent(
            FfiConverterString.read(buf),
            FfiConverterTypeAccessRule.read(buf),
        )
    }

    override fun allocationSize(value: SetAndLockRoleEvent) = (
            FfiConverterString.allocationSize(value.`roleKey`) +
            FfiConverterTypeAccessRule.allocationSize(value.`rule`)
    )

    override fun write(value: SetAndLockRoleEvent, buf: ByteBuffer) {
            FfiConverterString.write(value.`roleKey`, buf)
            FfiConverterTypeAccessRule.write(value.`rule`, buf)
    }
}




data class SetMetadataEvent (
    var `key`: String, 
    var `value`: MetadataValue
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`key`, 
        this.`value`)
    }
    
}

public object FfiConverterTypeSetMetadataEvent: FfiConverterRustBuffer<SetMetadataEvent> {
    override fun read(buf: ByteBuffer): SetMetadataEvent {
        return SetMetadataEvent(
            FfiConverterString.read(buf),
            FfiConverterTypeMetadataValue.read(buf),
        )
    }

    override fun allocationSize(value: SetMetadataEvent) = (
            FfiConverterString.allocationSize(value.`key`) +
            FfiConverterTypeMetadataValue.allocationSize(value.`value`)
    )

    override fun write(value: SetMetadataEvent, buf: ByteBuffer) {
            FfiConverterString.write(value.`key`, buf)
            FfiConverterTypeMetadataValue.write(value.`value`, buf)
    }
}




data class SetOwnerRoleEvent (
    var `rule`: AccessRule
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`rule`)
    }
    
}

public object FfiConverterTypeSetOwnerRoleEvent: FfiConverterRustBuffer<SetOwnerRoleEvent> {
    override fun read(buf: ByteBuffer): SetOwnerRoleEvent {
        return SetOwnerRoleEvent(
            FfiConverterTypeAccessRule.read(buf),
        )
    }

    override fun allocationSize(value: SetOwnerRoleEvent) = (
            FfiConverterTypeAccessRule.allocationSize(value.`rule`)
    )

    override fun write(value: SetOwnerRoleEvent, buf: ByteBuffer) {
            FfiConverterTypeAccessRule.write(value.`rule`, buf)
    }
}




data class SetRoleEvent (
    var `roleKey`: String, 
    var `rule`: AccessRule
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`roleKey`, 
        this.`rule`)
    }
    
}

public object FfiConverterTypeSetRoleEvent: FfiConverterRustBuffer<SetRoleEvent> {
    override fun read(buf: ByteBuffer): SetRoleEvent {
        return SetRoleEvent(
            FfiConverterString.read(buf),
            FfiConverterTypeAccessRule.read(buf),
        )
    }

    override fun allocationSize(value: SetRoleEvent) = (
            FfiConverterString.allocationSize(value.`roleKey`) +
            FfiConverterTypeAccessRule.allocationSize(value.`rule`)
    )

    override fun write(value: SetRoleEvent, buf: ByteBuffer) {
            FfiConverterString.write(value.`roleKey`, buf)
            FfiConverterTypeAccessRule.write(value.`rule`, buf)
    }
}




data class StakeEvent (
    var `xrdStaked`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`xrdStaked`)
    }
    
}

public object FfiConverterTypeStakeEvent: FfiConverterRustBuffer<StakeEvent> {
    override fun read(buf: ByteBuffer): StakeEvent {
        return StakeEvent(
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: StakeEvent) = (
            FfiConverterTypeDecimal.allocationSize(value.`xrdStaked`)
    )

    override fun write(value: StakeEvent, buf: ByteBuffer) {
            FfiConverterTypeDecimal.write(value.`xrdStaked`, buf)
    }
}




data class StakeInformation (
    var `fromAccount`: Address, 
    var `validatorAddress`: Address, 
    var `stakeUnitResource`: Address, 
    var `stakeUnitAmount`: Decimal, 
    var `stakedXrd`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`fromAccount`, 
        this.`validatorAddress`, 
        this.`stakeUnitResource`, 
        this.`stakeUnitAmount`, 
        this.`stakedXrd`)
    }
    
}

public object FfiConverterTypeStakeInformation: FfiConverterRustBuffer<StakeInformation> {
    override fun read(buf: ByteBuffer): StakeInformation {
        return StakeInformation(
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeDecimal.read(buf),
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: StakeInformation) = (
            FfiConverterTypeAddress.allocationSize(value.`fromAccount`) +
            FfiConverterTypeAddress.allocationSize(value.`validatorAddress`) +
            FfiConverterTypeAddress.allocationSize(value.`stakeUnitResource`) +
            FfiConverterTypeDecimal.allocationSize(value.`stakeUnitAmount`) +
            FfiConverterTypeDecimal.allocationSize(value.`stakedXrd`)
    )

    override fun write(value: StakeInformation, buf: ByteBuffer) {
            FfiConverterTypeAddress.write(value.`fromAccount`, buf)
            FfiConverterTypeAddress.write(value.`validatorAddress`, buf)
            FfiConverterTypeAddress.write(value.`stakeUnitResource`, buf)
            FfiConverterTypeDecimal.write(value.`stakeUnitAmount`, buf)
            FfiConverterTypeDecimal.write(value.`stakedXrd`, buf)
    }
}




data class StopTimedRecoveryEvent (
    var `placeholderField`: Boolean
) {
    
}

public object FfiConverterTypeStopTimedRecoveryEvent: FfiConverterRustBuffer<StopTimedRecoveryEvent> {
    override fun read(buf: ByteBuffer): StopTimedRecoveryEvent {
        return StopTimedRecoveryEvent(
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: StopTimedRecoveryEvent) = (
            FfiConverterBoolean.allocationSize(value.`placeholderField`)
    )

    override fun write(value: StopTimedRecoveryEvent, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`placeholderField`, buf)
    }
}




data class TransactionHeader (
    var `networkId`: UByte, 
    var `startEpochInclusive`: ULong, 
    var `endEpochExclusive`: ULong, 
    var `nonce`: UInt, 
    var `notaryPublicKey`: PublicKey, 
    var `notaryIsSignatory`: Boolean, 
    var `tipPercentage`: UShort
) {
    
}

public object FfiConverterTypeTransactionHeader: FfiConverterRustBuffer<TransactionHeader> {
    override fun read(buf: ByteBuffer): TransactionHeader {
        return TransactionHeader(
            FfiConverterUByte.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterTypePublicKey.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterUShort.read(buf),
        )
    }

    override fun allocationSize(value: TransactionHeader) = (
            FfiConverterUByte.allocationSize(value.`networkId`) +
            FfiConverterULong.allocationSize(value.`startEpochInclusive`) +
            FfiConverterULong.allocationSize(value.`endEpochExclusive`) +
            FfiConverterUInt.allocationSize(value.`nonce`) +
            FfiConverterTypePublicKey.allocationSize(value.`notaryPublicKey`) +
            FfiConverterBoolean.allocationSize(value.`notaryIsSignatory`) +
            FfiConverterUShort.allocationSize(value.`tipPercentage`)
    )

    override fun write(value: TransactionHeader, buf: ByteBuffer) {
            FfiConverterUByte.write(value.`networkId`, buf)
            FfiConverterULong.write(value.`startEpochInclusive`, buf)
            FfiConverterULong.write(value.`endEpochExclusive`, buf)
            FfiConverterUInt.write(value.`nonce`, buf)
            FfiConverterTypePublicKey.write(value.`notaryPublicKey`, buf)
            FfiConverterBoolean.write(value.`notaryIsSignatory`, buf)
            FfiConverterUShort.write(value.`tipPercentage`, buf)
    }
}




data class TransactionManifestModifications (
    var `addAccessControllerProofs`: List<Address>, 
    var `addLockFee`: LockFeeModification?, 
    var `addAssertions`: List<IndexedAssertion>
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`addAccessControllerProofs`, 
        this.`addLockFee`, 
        this.`addAssertions`)
    }
    
}

public object FfiConverterTypeTransactionManifestModifications: FfiConverterRustBuffer<TransactionManifestModifications> {
    override fun read(buf: ByteBuffer): TransactionManifestModifications {
        return TransactionManifestModifications(
            FfiConverterSequenceTypeAddress.read(buf),
            FfiConverterOptionalTypeLockFeeModification.read(buf),
            FfiConverterSequenceTypeIndexedAssertion.read(buf),
        )
    }

    override fun allocationSize(value: TransactionManifestModifications) = (
            FfiConverterSequenceTypeAddress.allocationSize(value.`addAccessControllerProofs`) +
            FfiConverterOptionalTypeLockFeeModification.allocationSize(value.`addLockFee`) +
            FfiConverterSequenceTypeIndexedAssertion.allocationSize(value.`addAssertions`)
    )

    override fun write(value: TransactionManifestModifications, buf: ByteBuffer) {
            FfiConverterSequenceTypeAddress.write(value.`addAccessControllerProofs`, buf)
            FfiConverterOptionalTypeLockFeeModification.write(value.`addLockFee`, buf)
            FfiConverterSequenceTypeIndexedAssertion.write(value.`addAssertions`, buf)
    }
}




data class TransferTransactionType (
    var `from`: Address, 
    var `transfers`: Map<String, Map<String, Resources>>
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`from`, 
        this.`transfers`)
    }
    
}

public object FfiConverterTypeTransferTransactionType: FfiConverterRustBuffer<TransferTransactionType> {
    override fun read(buf: ByteBuffer): TransferTransactionType {
        return TransferTransactionType(
            FfiConverterTypeAddress.read(buf),
            FfiConverterMapStringMapStringTypeResources.read(buf),
        )
    }

    override fun allocationSize(value: TransferTransactionType) = (
            FfiConverterTypeAddress.allocationSize(value.`from`) +
            FfiConverterMapStringMapStringTypeResources.allocationSize(value.`transfers`)
    )

    override fun write(value: TransferTransactionType, buf: ByteBuffer) {
            FfiConverterTypeAddress.write(value.`from`, buf)
            FfiConverterMapStringMapStringTypeResources.write(value.`transfers`, buf)
    }
}




data class TwoResourcePoolContributionEvent (
    var `contributedResources`: Map<String, Decimal>, 
    var `poolUnitsMinted`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`contributedResources`, 
        this.`poolUnitsMinted`)
    }
    
}

public object FfiConverterTypeTwoResourcePoolContributionEvent: FfiConverterRustBuffer<TwoResourcePoolContributionEvent> {
    override fun read(buf: ByteBuffer): TwoResourcePoolContributionEvent {
        return TwoResourcePoolContributionEvent(
            FfiConverterMapStringTypeDecimal.read(buf),
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: TwoResourcePoolContributionEvent) = (
            FfiConverterMapStringTypeDecimal.allocationSize(value.`contributedResources`) +
            FfiConverterTypeDecimal.allocationSize(value.`poolUnitsMinted`)
    )

    override fun write(value: TwoResourcePoolContributionEvent, buf: ByteBuffer) {
            FfiConverterMapStringTypeDecimal.write(value.`contributedResources`, buf)
            FfiConverterTypeDecimal.write(value.`poolUnitsMinted`, buf)
    }
}




data class TwoResourcePoolDepositEvent (
    var `resourceAddress`: Address, 
    var `amount`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`amount`)
    }
    
}

public object FfiConverterTypeTwoResourcePoolDepositEvent: FfiConverterRustBuffer<TwoResourcePoolDepositEvent> {
    override fun read(buf: ByteBuffer): TwoResourcePoolDepositEvent {
        return TwoResourcePoolDepositEvent(
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: TwoResourcePoolDepositEvent) = (
            FfiConverterTypeAddress.allocationSize(value.`resourceAddress`) +
            FfiConverterTypeDecimal.allocationSize(value.`amount`)
    )

    override fun write(value: TwoResourcePoolDepositEvent, buf: ByteBuffer) {
            FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
            FfiConverterTypeDecimal.write(value.`amount`, buf)
    }
}




data class TwoResourcePoolRedemptionEvent (
    var `poolUnitTokensRedeemed`: Decimal, 
    var `redeemedResources`: Map<String, Decimal>
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`poolUnitTokensRedeemed`, 
        this.`redeemedResources`)
    }
    
}

public object FfiConverterTypeTwoResourcePoolRedemptionEvent: FfiConverterRustBuffer<TwoResourcePoolRedemptionEvent> {
    override fun read(buf: ByteBuffer): TwoResourcePoolRedemptionEvent {
        return TwoResourcePoolRedemptionEvent(
            FfiConverterTypeDecimal.read(buf),
            FfiConverterMapStringTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: TwoResourcePoolRedemptionEvent) = (
            FfiConverterTypeDecimal.allocationSize(value.`poolUnitTokensRedeemed`) +
            FfiConverterMapStringTypeDecimal.allocationSize(value.`redeemedResources`)
    )

    override fun write(value: TwoResourcePoolRedemptionEvent, buf: ByteBuffer) {
            FfiConverterTypeDecimal.write(value.`poolUnitTokensRedeemed`, buf)
            FfiConverterMapStringTypeDecimal.write(value.`redeemedResources`, buf)
    }
}




data class TwoResourcePoolWithdrawEvent (
    var `resourceAddress`: Address, 
    var `amount`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`amount`)
    }
    
}

public object FfiConverterTypeTwoResourcePoolWithdrawEvent: FfiConverterRustBuffer<TwoResourcePoolWithdrawEvent> {
    override fun read(buf: ByteBuffer): TwoResourcePoolWithdrawEvent {
        return TwoResourcePoolWithdrawEvent(
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: TwoResourcePoolWithdrawEvent) = (
            FfiConverterTypeAddress.allocationSize(value.`resourceAddress`) +
            FfiConverterTypeDecimal.allocationSize(value.`amount`)
    )

    override fun write(value: TwoResourcePoolWithdrawEvent, buf: ByteBuffer) {
            FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
            FfiConverterTypeDecimal.write(value.`amount`, buf)
    }
}




data class UnlockPrimaryRoleEvent (
    var `placeholderField`: Boolean
) {
    
}

public object FfiConverterTypeUnlockPrimaryRoleEvent: FfiConverterRustBuffer<UnlockPrimaryRoleEvent> {
    override fun read(buf: ByteBuffer): UnlockPrimaryRoleEvent {
        return UnlockPrimaryRoleEvent(
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: UnlockPrimaryRoleEvent) = (
            FfiConverterBoolean.allocationSize(value.`placeholderField`)
    )

    override fun write(value: UnlockPrimaryRoleEvent, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`placeholderField`, buf)
    }
}




data class UnregisterValidatorEvent (
    var `placeholderField`: Boolean
) {
    
}

public object FfiConverterTypeUnregisterValidatorEvent: FfiConverterRustBuffer<UnregisterValidatorEvent> {
    override fun read(buf: ByteBuffer): UnregisterValidatorEvent {
        return UnregisterValidatorEvent(
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: UnregisterValidatorEvent) = (
            FfiConverterBoolean.allocationSize(value.`placeholderField`)
    )

    override fun write(value: UnregisterValidatorEvent, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`placeholderField`, buf)
    }
}




data class UnstakeData (
    var `name`: String, 
    var `claimEpoch`: ULong, 
    var `claimAmount`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`name`, 
        this.`claimEpoch`, 
        this.`claimAmount`)
    }
    
}

public object FfiConverterTypeUnstakeData: FfiConverterRustBuffer<UnstakeData> {
    override fun read(buf: ByteBuffer): UnstakeData {
        return UnstakeData(
            FfiConverterString.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: UnstakeData) = (
            FfiConverterString.allocationSize(value.`name`) +
            FfiConverterULong.allocationSize(value.`claimEpoch`) +
            FfiConverterTypeDecimal.allocationSize(value.`claimAmount`)
    )

    override fun write(value: UnstakeData, buf: ByteBuffer) {
            FfiConverterString.write(value.`name`, buf)
            FfiConverterULong.write(value.`claimEpoch`, buf)
            FfiConverterTypeDecimal.write(value.`claimAmount`, buf)
    }
}




data class UnstakeEvent (
    var `stakeUnits`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`stakeUnits`)
    }
    
}

public object FfiConverterTypeUnstakeEvent: FfiConverterRustBuffer<UnstakeEvent> {
    override fun read(buf: ByteBuffer): UnstakeEvent {
        return UnstakeEvent(
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: UnstakeEvent) = (
            FfiConverterTypeDecimal.allocationSize(value.`stakeUnits`)
    )

    override fun write(value: UnstakeEvent, buf: ByteBuffer) {
            FfiConverterTypeDecimal.write(value.`stakeUnits`, buf)
    }
}




data class UnstakeInformation (
    var `fromAccount`: Address, 
    var `stakeUnitAddress`: Address, 
    var `stakeUnitAmount`: Decimal, 
    var `validatorAddress`: Address, 
    var `claimNftResource`: Address, 
    var `claimNftLocalId`: NonFungibleLocalId, 
    var `claimNftData`: UnstakeData
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`fromAccount`, 
        this.`stakeUnitAddress`, 
        this.`stakeUnitAmount`, 
        this.`validatorAddress`, 
        this.`claimNftResource`, 
        this.`claimNftLocalId`, 
        this.`claimNftData`)
    }
    
}

public object FfiConverterTypeUnstakeInformation: FfiConverterRustBuffer<UnstakeInformation> {
    override fun read(buf: ByteBuffer): UnstakeInformation {
        return UnstakeInformation(
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeDecimal.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeAddress.read(buf),
            FfiConverterTypeNonFungibleLocalId.read(buf),
            FfiConverterTypeUnstakeData.read(buf),
        )
    }

    override fun allocationSize(value: UnstakeInformation) = (
            FfiConverterTypeAddress.allocationSize(value.`fromAccount`) +
            FfiConverterTypeAddress.allocationSize(value.`stakeUnitAddress`) +
            FfiConverterTypeDecimal.allocationSize(value.`stakeUnitAmount`) +
            FfiConverterTypeAddress.allocationSize(value.`validatorAddress`) +
            FfiConverterTypeAddress.allocationSize(value.`claimNftResource`) +
            FfiConverterTypeNonFungibleLocalId.allocationSize(value.`claimNftLocalId`) +
            FfiConverterTypeUnstakeData.allocationSize(value.`claimNftData`)
    )

    override fun write(value: UnstakeInformation, buf: ByteBuffer) {
            FfiConverterTypeAddress.write(value.`fromAccount`, buf)
            FfiConverterTypeAddress.write(value.`stakeUnitAddress`, buf)
            FfiConverterTypeDecimal.write(value.`stakeUnitAmount`, buf)
            FfiConverterTypeAddress.write(value.`validatorAddress`, buf)
            FfiConverterTypeAddress.write(value.`claimNftResource`, buf)
            FfiConverterTypeNonFungibleLocalId.write(value.`claimNftLocalId`, buf)
            FfiConverterTypeUnstakeData.write(value.`claimNftData`, buf)
    }
}




data class UpdateAcceptingStakeDelegationStateEvent (
    var `acceptsDelegation`: Boolean
) {
    
}

public object FfiConverterTypeUpdateAcceptingStakeDelegationStateEvent: FfiConverterRustBuffer<UpdateAcceptingStakeDelegationStateEvent> {
    override fun read(buf: ByteBuffer): UpdateAcceptingStakeDelegationStateEvent {
        return UpdateAcceptingStakeDelegationStateEvent(
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: UpdateAcceptingStakeDelegationStateEvent) = (
            FfiConverterBoolean.allocationSize(value.`acceptsDelegation`)
    )

    override fun write(value: UpdateAcceptingStakeDelegationStateEvent, buf: ByteBuffer) {
            FfiConverterBoolean.write(value.`acceptsDelegation`, buf)
    }
}




data class ValidatorEmissionAppliedEvent (
    var `epoch`: ULong, 
    var `startingStakePoolXrd`: Decimal, 
    var `stakePoolAddedXrd`: Decimal, 
    var `totalStakeUnitSupply`: Decimal, 
    var `validatorFeeXrd`: Decimal, 
    var `proposalsMade`: ULong, 
    var `proposalsMissed`: ULong
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`epoch`, 
        this.`startingStakePoolXrd`, 
        this.`stakePoolAddedXrd`, 
        this.`totalStakeUnitSupply`, 
        this.`validatorFeeXrd`, 
        this.`proposalsMade`, 
        this.`proposalsMissed`)
    }
    
}

public object FfiConverterTypeValidatorEmissionAppliedEvent: FfiConverterRustBuffer<ValidatorEmissionAppliedEvent> {
    override fun read(buf: ByteBuffer): ValidatorEmissionAppliedEvent {
        return ValidatorEmissionAppliedEvent(
            FfiConverterULong.read(buf),
            FfiConverterTypeDecimal.read(buf),
            FfiConverterTypeDecimal.read(buf),
            FfiConverterTypeDecimal.read(buf),
            FfiConverterTypeDecimal.read(buf),
            FfiConverterULong.read(buf),
            FfiConverterULong.read(buf),
        )
    }

    override fun allocationSize(value: ValidatorEmissionAppliedEvent) = (
            FfiConverterULong.allocationSize(value.`epoch`) +
            FfiConverterTypeDecimal.allocationSize(value.`startingStakePoolXrd`) +
            FfiConverterTypeDecimal.allocationSize(value.`stakePoolAddedXrd`) +
            FfiConverterTypeDecimal.allocationSize(value.`totalStakeUnitSupply`) +
            FfiConverterTypeDecimal.allocationSize(value.`validatorFeeXrd`) +
            FfiConverterULong.allocationSize(value.`proposalsMade`) +
            FfiConverterULong.allocationSize(value.`proposalsMissed`)
    )

    override fun write(value: ValidatorEmissionAppliedEvent, buf: ByteBuffer) {
            FfiConverterULong.write(value.`epoch`, buf)
            FfiConverterTypeDecimal.write(value.`startingStakePoolXrd`, buf)
            FfiConverterTypeDecimal.write(value.`stakePoolAddedXrd`, buf)
            FfiConverterTypeDecimal.write(value.`totalStakeUnitSupply`, buf)
            FfiConverterTypeDecimal.write(value.`validatorFeeXrd`, buf)
            FfiConverterULong.write(value.`proposalsMade`, buf)
            FfiConverterULong.write(value.`proposalsMissed`, buf)
    }
}




data class ValidatorInfo (
    var `key`: Secp256k1PublicKey, 
    var `stake`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`key`, 
        this.`stake`)
    }
    
}

public object FfiConverterTypeValidatorInfo: FfiConverterRustBuffer<ValidatorInfo> {
    override fun read(buf: ByteBuffer): ValidatorInfo {
        return ValidatorInfo(
            FfiConverterTypeSecp256k1PublicKey.read(buf),
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: ValidatorInfo) = (
            FfiConverterTypeSecp256k1PublicKey.allocationSize(value.`key`) +
            FfiConverterTypeDecimal.allocationSize(value.`stake`)
    )

    override fun write(value: ValidatorInfo, buf: ByteBuffer) {
            FfiConverterTypeSecp256k1PublicKey.write(value.`key`, buf)
            FfiConverterTypeDecimal.write(value.`stake`, buf)
    }
}




data class ValidatorRewardAppliedEvent (
    var `epoch`: ULong, 
    var `amount`: Decimal
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`epoch`, 
        this.`amount`)
    }
    
}

public object FfiConverterTypeValidatorRewardAppliedEvent: FfiConverterRustBuffer<ValidatorRewardAppliedEvent> {
    override fun read(buf: ByteBuffer): ValidatorRewardAppliedEvent {
        return ValidatorRewardAppliedEvent(
            FfiConverterULong.read(buf),
            FfiConverterTypeDecimal.read(buf),
        )
    }

    override fun allocationSize(value: ValidatorRewardAppliedEvent) = (
            FfiConverterULong.allocationSize(value.`epoch`) +
            FfiConverterTypeDecimal.allocationSize(value.`amount`)
    )

    override fun write(value: ValidatorRewardAppliedEvent, buf: ByteBuffer) {
            FfiConverterULong.write(value.`epoch`, buf)
            FfiConverterTypeDecimal.write(value.`amount`, buf)
    }
}




data class VaultCreationEvent (
    var `vaultId`: Address
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`vaultId`)
    }
    
}

public object FfiConverterTypeVaultCreationEvent: FfiConverterRustBuffer<VaultCreationEvent> {
    override fun read(buf: ByteBuffer): VaultCreationEvent {
        return VaultCreationEvent(
            FfiConverterTypeAddress.read(buf),
        )
    }

    override fun allocationSize(value: VaultCreationEvent) = (
            FfiConverterTypeAddress.allocationSize(value.`vaultId`)
    )

    override fun write(value: VaultCreationEvent, buf: ByteBuffer) {
            FfiConverterTypeAddress.write(value.`vaultId`, buf)
    }
}




enum class AccountDefaultDepositRule {
    ACCEPT,REJECT,ALLOW_EXISTING;
}

public object FfiConverterTypeAccountDefaultDepositRule: FfiConverterRustBuffer<AccountDefaultDepositRule> {
    override fun read(buf: ByteBuffer) = try {
        AccountDefaultDepositRule.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: AccountDefaultDepositRule) = 4

    override fun write(value: AccountDefaultDepositRule, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






sealed class AccountDepositEvent: Disposable  {
    data class Fungible(
        val `resourceAddress`: Address, 
        val `amount`: Decimal
        ) : AccountDepositEvent()
    data class NonFungible(
        val `resourceAddress`: Address, 
        val `ids`: List<NonFungibleLocalId>
        ) : AccountDepositEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is AccountDepositEvent.Fungible -> {
                
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`amount`)
                
            }
            is AccountDepositEvent.NonFungible -> {
                
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`ids`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeAccountDepositEvent : FfiConverterRustBuffer<AccountDepositEvent>{
    override fun read(buf: ByteBuffer): AccountDepositEvent {
        return when(buf.getInt()) {
            1 -> AccountDepositEvent.Fungible(
                FfiConverterTypeAddress.read(buf),
                FfiConverterTypeDecimal.read(buf),
                )
            2 -> AccountDepositEvent.NonFungible(
                FfiConverterTypeAddress.read(buf),
                FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AccountDepositEvent) = when(value) {
        is AccountDepositEvent.Fungible -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
                + FfiConverterTypeDecimal.allocationSize(value.`amount`)
            )
        }
        is AccountDepositEvent.NonFungible -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
                + FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`ids`)
            )
        }
    }

    override fun write(value: AccountDepositEvent, buf: ByteBuffer) {
        when(value) {
            is AccountDepositEvent.Fungible -> {
                buf.putInt(1)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                FfiConverterTypeDecimal.write(value.`amount`, buf)
                Unit
            }
            is AccountDepositEvent.NonFungible -> {
                buf.putInt(2)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                FfiConverterSequenceTypeNonFungibleLocalId.write(value.`ids`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class AccountRejectedDepositEvent: Disposable  {
    data class Fungible(
        val `resourceAddress`: Address, 
        val `amount`: Decimal
        ) : AccountRejectedDepositEvent()
    data class NonFungible(
        val `resourceAddress`: Address, 
        val `ids`: List<NonFungibleLocalId>
        ) : AccountRejectedDepositEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is AccountRejectedDepositEvent.Fungible -> {
                
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`amount`)
                
            }
            is AccountRejectedDepositEvent.NonFungible -> {
                
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`ids`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeAccountRejectedDepositEvent : FfiConverterRustBuffer<AccountRejectedDepositEvent>{
    override fun read(buf: ByteBuffer): AccountRejectedDepositEvent {
        return when(buf.getInt()) {
            1 -> AccountRejectedDepositEvent.Fungible(
                FfiConverterTypeAddress.read(buf),
                FfiConverterTypeDecimal.read(buf),
                )
            2 -> AccountRejectedDepositEvent.NonFungible(
                FfiConverterTypeAddress.read(buf),
                FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AccountRejectedDepositEvent) = when(value) {
        is AccountRejectedDepositEvent.Fungible -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
                + FfiConverterTypeDecimal.allocationSize(value.`amount`)
            )
        }
        is AccountRejectedDepositEvent.NonFungible -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
                + FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`ids`)
            )
        }
    }

    override fun write(value: AccountRejectedDepositEvent, buf: ByteBuffer) {
        when(value) {
            is AccountRejectedDepositEvent.Fungible -> {
                buf.putInt(1)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                FfiConverterTypeDecimal.write(value.`amount`, buf)
                Unit
            }
            is AccountRejectedDepositEvent.NonFungible -> {
                buf.putInt(2)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                FfiConverterSequenceTypeNonFungibleLocalId.write(value.`ids`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class AccountWithdrawEvent: Disposable  {
    data class Fungible(
        val `resourceAddress`: Address, 
        val `amount`: Decimal
        ) : AccountWithdrawEvent()
    data class NonFungible(
        val `resourceAddress`: Address, 
        val `ids`: List<NonFungibleLocalId>
        ) : AccountWithdrawEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is AccountWithdrawEvent.Fungible -> {
                
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`amount`)
                
            }
            is AccountWithdrawEvent.NonFungible -> {
                
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`ids`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeAccountWithdrawEvent : FfiConverterRustBuffer<AccountWithdrawEvent>{
    override fun read(buf: ByteBuffer): AccountWithdrawEvent {
        return when(buf.getInt()) {
            1 -> AccountWithdrawEvent.Fungible(
                FfiConverterTypeAddress.read(buf),
                FfiConverterTypeDecimal.read(buf),
                )
            2 -> AccountWithdrawEvent.NonFungible(
                FfiConverterTypeAddress.read(buf),
                FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: AccountWithdrawEvent) = when(value) {
        is AccountWithdrawEvent.Fungible -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
                + FfiConverterTypeDecimal.allocationSize(value.`amount`)
            )
        }
        is AccountWithdrawEvent.NonFungible -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
                + FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`ids`)
            )
        }
    }

    override fun write(value: AccountWithdrawEvent, buf: ByteBuffer) {
        when(value) {
            is AccountWithdrawEvent.Fungible -> {
                buf.putInt(1)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                FfiConverterTypeDecimal.write(value.`amount`, buf)
                Unit
            }
            is AccountWithdrawEvent.NonFungible -> {
                buf.putInt(2)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                FfiConverterSequenceTypeNonFungibleLocalId.write(value.`ids`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class Assertion: Disposable  {
    data class Amount(
        val `resourceAddress`: Address, 
        val `amount`: Decimal
        ) : Assertion()
    data class Ids(
        val `resourceAddress`: Address, 
        val `ids`: List<NonFungibleLocalId>
        ) : Assertion()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is Assertion.Amount -> {
                
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`amount`)
                
            }
            is Assertion.Ids -> {
                
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`ids`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeAssertion : FfiConverterRustBuffer<Assertion>{
    override fun read(buf: ByteBuffer): Assertion {
        return when(buf.getInt()) {
            1 -> Assertion.Amount(
                FfiConverterTypeAddress.read(buf),
                FfiConverterTypeDecimal.read(buf),
                )
            2 -> Assertion.Ids(
                FfiConverterTypeAddress.read(buf),
                FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: Assertion) = when(value) {
        is Assertion.Amount -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
                + FfiConverterTypeDecimal.allocationSize(value.`amount`)
            )
        }
        is Assertion.Ids -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
                + FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`ids`)
            )
        }
    }

    override fun write(value: Assertion, buf: ByteBuffer) {
        when(value) {
            is Assertion.Amount -> {
                buf.putInt(1)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                FfiConverterTypeDecimal.write(value.`amount`, buf)
                Unit
            }
            is Assertion.Ids -> {
                buf.putInt(2)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                FfiConverterSequenceTypeNonFungibleLocalId.write(value.`ids`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class Curve {
    SECP256K1,ED25519;
}

public object FfiConverterTypeCurve: FfiConverterRustBuffer<Curve> {
    override fun read(buf: ByteBuffer) = try {
        Curve.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: Curve) = 4

    override fun write(value: Curve, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class CurveType {
    ED25519,SECP256K1;
}

public object FfiConverterTypeCurveType: FfiConverterRustBuffer<CurveType> {
    override fun read(buf: ByteBuffer) = try {
        CurveType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: CurveType) = 4

    override fun write(value: CurveType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






sealed class DecimalSource: Disposable  {
    data class Guaranteed(
        val `value`: Decimal
        ) : DecimalSource()
    data class Predicted(
        val `instructionIndex`: ULong, 
        val `value`: Decimal
        ) : DecimalSource()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is DecimalSource.Guaranteed -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is DecimalSource.Predicted -> {
                
    Disposable.destroy(
        this.`instructionIndex`, 
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeDecimalSource : FfiConverterRustBuffer<DecimalSource>{
    override fun read(buf: ByteBuffer): DecimalSource {
        return when(buf.getInt()) {
            1 -> DecimalSource.Guaranteed(
                FfiConverterTypeDecimal.read(buf),
                )
            2 -> DecimalSource.Predicted(
                FfiConverterULong.read(buf),
                FfiConverterTypeDecimal.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DecimalSource) = when(value) {
        is DecimalSource.Guaranteed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeDecimal.allocationSize(value.`value`)
            )
        }
        is DecimalSource.Predicted -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterULong.allocationSize(value.`instructionIndex`)
                + FfiConverterTypeDecimal.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: DecimalSource, buf: ByteBuffer) {
        when(value) {
            is DecimalSource.Guaranteed -> {
                buf.putInt(1)
                FfiConverterTypeDecimal.write(value.`value`, buf)
                Unit
            }
            is DecimalSource.Predicted -> {
                buf.putInt(2)
                FfiConverterULong.write(value.`instructionIndex`, buf)
                FfiConverterTypeDecimal.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class DecryptorsByCurve {
    data class Ed25519(
        val `dhEphemeralPublicKey`: Ed25519PublicKey, 
        val `decryptors`: Map<List<UByte>, List<UByte>>
        ) : DecryptorsByCurve()
    data class Secp256k1(
        val `dhEphemeralPublicKey`: Secp256k1PublicKey, 
        val `decryptors`: Map<List<UByte>, List<UByte>>
        ) : DecryptorsByCurve()
    

    
}

public object FfiConverterTypeDecryptorsByCurve : FfiConverterRustBuffer<DecryptorsByCurve>{
    override fun read(buf: ByteBuffer): DecryptorsByCurve {
        return when(buf.getInt()) {
            1 -> DecryptorsByCurve.Ed25519(
                FfiConverterTypeEd25519PublicKey.read(buf),
                FfiConverterMapSequenceUByteSequenceUByte.read(buf),
                )
            2 -> DecryptorsByCurve.Secp256k1(
                FfiConverterTypeSecp256k1PublicKey.read(buf),
                FfiConverterMapSequenceUByteSequenceUByte.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DecryptorsByCurve) = when(value) {
        is DecryptorsByCurve.Ed25519 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeEd25519PublicKey.allocationSize(value.`dhEphemeralPublicKey`)
                + FfiConverterMapSequenceUByteSequenceUByte.allocationSize(value.`decryptors`)
            )
        }
        is DecryptorsByCurve.Secp256k1 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeSecp256k1PublicKey.allocationSize(value.`dhEphemeralPublicKey`)
                + FfiConverterMapSequenceUByteSequenceUByte.allocationSize(value.`decryptors`)
            )
        }
    }

    override fun write(value: DecryptorsByCurve, buf: ByteBuffer) {
        when(value) {
            is DecryptorsByCurve.Ed25519 -> {
                buf.putInt(1)
                FfiConverterTypeEd25519PublicKey.write(value.`dhEphemeralPublicKey`, buf)
                FfiConverterMapSequenceUByteSequenceUByte.write(value.`decryptors`, buf)
                Unit
            }
            is DecryptorsByCurve.Secp256k1 -> {
                buf.putInt(2)
                FfiConverterTypeSecp256k1PublicKey.write(value.`dhEphemeralPublicKey`, buf)
                FfiConverterMapSequenceUByteSequenceUByte.write(value.`decryptors`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class DependencyInformation {
    data class Version(
        val `value`: String
        ) : DependencyInformation()
    data class Tag(
        val `value`: String
        ) : DependencyInformation()
    data class Branch(
        val `value`: String
        ) : DependencyInformation()
    data class Rev(
        val `value`: String
        ) : DependencyInformation()
    

    
}

public object FfiConverterTypeDependencyInformation : FfiConverterRustBuffer<DependencyInformation>{
    override fun read(buf: ByteBuffer): DependencyInformation {
        return when(buf.getInt()) {
            1 -> DependencyInformation.Version(
                FfiConverterString.read(buf),
                )
            2 -> DependencyInformation.Tag(
                FfiConverterString.read(buf),
                )
            3 -> DependencyInformation.Branch(
                FfiConverterString.read(buf),
                )
            4 -> DependencyInformation.Rev(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DependencyInformation) = when(value) {
        is DependencyInformation.Version -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
        is DependencyInformation.Tag -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
        is DependencyInformation.Branch -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
        is DependencyInformation.Rev -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: DependencyInformation, buf: ByteBuffer) {
        when(value) {
            is DependencyInformation.Version -> {
                buf.putInt(1)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
            is DependencyInformation.Tag -> {
                buf.putInt(2)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
            is DependencyInformation.Branch -> {
                buf.putInt(3)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
            is DependencyInformation.Rev -> {
                buf.putInt(4)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class DepositResourceEvent: Disposable  {
    data class Amount(
        val `value`: Decimal
        ) : DepositResourceEvent()
    data class Ids(
        val `value`: List<NonFungibleLocalId>
        ) : DepositResourceEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is DepositResourceEvent.Amount -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is DepositResourceEvent.Ids -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeDepositResourceEvent : FfiConverterRustBuffer<DepositResourceEvent>{
    override fun read(buf: ByteBuffer): DepositResourceEvent {
        return when(buf.getInt()) {
            1 -> DepositResourceEvent.Amount(
                FfiConverterTypeDecimal.read(buf),
                )
            2 -> DepositResourceEvent.Ids(
                FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: DepositResourceEvent) = when(value) {
        is DepositResourceEvent.Amount -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeDecimal.allocationSize(value.`value`)
            )
        }
        is DepositResourceEvent.Ids -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: DepositResourceEvent, buf: ByteBuffer) {
        when(value) {
            is DepositResourceEvent.Amount -> {
                buf.putInt(1)
                FfiConverterTypeDecimal.write(value.`value`, buf)
                Unit
            }
            is DepositResourceEvent.Ids -> {
                buf.putInt(2)
                FfiConverterSequenceTypeNonFungibleLocalId.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class Emitter: Disposable  {
    data class Function(
        val `address`: Address, 
        val `blueprintName`: String
        ) : Emitter()
    data class Method(
        val `address`: Address, 
        val `objectModuleId`: ObjectModuleId
        ) : Emitter()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is Emitter.Function -> {
                
    Disposable.destroy(
        this.`address`, 
        this.`blueprintName`)
                
            }
            is Emitter.Method -> {
                
    Disposable.destroy(
        this.`address`, 
        this.`objectModuleId`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeEmitter : FfiConverterRustBuffer<Emitter>{
    override fun read(buf: ByteBuffer): Emitter {
        return when(buf.getInt()) {
            1 -> Emitter.Function(
                FfiConverterTypeAddress.read(buf),
                FfiConverterString.read(buf),
                )
            2 -> Emitter.Method(
                FfiConverterTypeAddress.read(buf),
                FfiConverterTypeObjectModuleId.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: Emitter) = when(value) {
        is Emitter.Function -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`address`)
                + FfiConverterString.allocationSize(value.`blueprintName`)
            )
        }
        is Emitter.Method -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`address`)
                + FfiConverterTypeObjectModuleId.allocationSize(value.`objectModuleId`)
            )
        }
    }

    override fun write(value: Emitter, buf: ByteBuffer) {
        when(value) {
            is Emitter.Function -> {
                buf.putInt(1)
                FfiConverterTypeAddress.write(value.`address`, buf)
                FfiConverterString.write(value.`blueprintName`, buf)
                Unit
            }
            is Emitter.Method -> {
                buf.putInt(2)
                FfiConverterTypeAddress.write(value.`address`, buf)
                FfiConverterTypeObjectModuleId.write(value.`objectModuleId`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class EntityType {
    GLOBAL_PACKAGE,GLOBAL_FUNGIBLE_RESOURCE_MANAGER,GLOBAL_NON_FUNGIBLE_RESOURCE_MANAGER,GLOBAL_CONSENSUS_MANAGER,GLOBAL_VALIDATOR,GLOBAL_ACCESS_CONTROLLER,GLOBAL_ACCOUNT,GLOBAL_IDENTITY,GLOBAL_GENERIC_COMPONENT,GLOBAL_VIRTUAL_SECP256K1_ACCOUNT,GLOBAL_VIRTUAL_ED25519_ACCOUNT,GLOBAL_VIRTUAL_SECP256K1_IDENTITY,GLOBAL_VIRTUAL_ED25519_IDENTITY,GLOBAL_ONE_RESOURCE_POOL,GLOBAL_TWO_RESOURCE_POOL,GLOBAL_MULTI_RESOURCE_POOL,GLOBAL_TRANSACTION_TRACKER,INTERNAL_FUNGIBLE_VAULT,INTERNAL_NON_FUNGIBLE_VAULT,INTERNAL_GENERIC_COMPONENT,INTERNAL_KEY_VALUE_STORE;
}

public object FfiConverterTypeEntityType: FfiConverterRustBuffer<EntityType> {
    override fun read(buf: ByteBuffer) = try {
        EntityType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: EntityType) = 4

    override fun write(value: EntityType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






sealed class Instruction: Disposable  {
    data class TakeAllFromWorktop(
        val `resourceAddress`: Address
        ) : Instruction()
    data class TakeFromWorktop(
        val `resourceAddress`: Address, 
        val `amount`: Decimal
        ) : Instruction()
    data class TakeNonFungiblesFromWorktop(
        val `resourceAddress`: Address, 
        val `ids`: List<NonFungibleLocalId>
        ) : Instruction()
    data class ReturnToWorktop(
        val `bucketId`: ManifestBucket
        ) : Instruction()
    data class AssertWorktopContains(
        val `resourceAddress`: Address, 
        val `amount`: Decimal
        ) : Instruction()
    data class AssertWorktopContainsAny(
        val `resourceAddress`: Address
        ) : Instruction()
    data class AssertWorktopContainsNonFungibles(
        val `resourceAddress`: Address, 
        val `ids`: List<NonFungibleLocalId>
        ) : Instruction()
    object PopFromAuthZone : Instruction()
    
    data class PushToAuthZone(
        val `proofId`: ManifestProof
        ) : Instruction()
    data class CreateProofFromAuthZoneOfAmount(
        val `resourceAddress`: Address, 
        val `amount`: Decimal
        ) : Instruction()
    data class CreateProofFromAuthZoneOfNonFungibles(
        val `resourceAddress`: Address, 
        val `ids`: List<NonFungibleLocalId>
        ) : Instruction()
    data class CreateProofFromAuthZoneOfAll(
        val `resourceAddress`: Address
        ) : Instruction()
    object DropAllProofs : Instruction()
    
    object DropNamedProofs : Instruction()
    
    object DropAuthZoneProofs : Instruction()
    
    object DropAuthZoneRegularProofs : Instruction()
    
    object DropAuthZoneSignatureProofs : Instruction()
    
    data class CreateProofFromBucketOfAmount(
        val `bucketId`: ManifestBucket, 
        val `amount`: Decimal
        ) : Instruction()
    data class CreateProofFromBucketOfNonFungibles(
        val `bucketId`: ManifestBucket, 
        val `ids`: List<NonFungibleLocalId>
        ) : Instruction()
    data class CreateProofFromBucketOfAll(
        val `bucketId`: ManifestBucket
        ) : Instruction()
    data class BurnResource(
        val `bucketId`: ManifestBucket
        ) : Instruction()
    data class CloneProof(
        val `proofId`: ManifestProof
        ) : Instruction()
    data class DropProof(
        val `proofId`: ManifestProof
        ) : Instruction()
    data class CallFunction(
        val `packageAddress`: ManifestAddress, 
        val `blueprintName`: String, 
        val `functionName`: String, 
        val `args`: ManifestValue
        ) : Instruction()
    data class CallMethod(
        val `address`: ManifestAddress, 
        val `methodName`: String, 
        val `args`: ManifestValue
        ) : Instruction()
    data class CallRoyaltyMethod(
        val `address`: ManifestAddress, 
        val `methodName`: String, 
        val `args`: ManifestValue
        ) : Instruction()
    data class CallMetadataMethod(
        val `address`: ManifestAddress, 
        val `methodName`: String, 
        val `args`: ManifestValue
        ) : Instruction()
    data class CallRoleAssignmentMethod(
        val `address`: ManifestAddress, 
        val `methodName`: String, 
        val `args`: ManifestValue
        ) : Instruction()
    data class CallDirectVaultMethod(
        val `address`: Address, 
        val `methodName`: String, 
        val `args`: ManifestValue
        ) : Instruction()
    data class AllocateGlobalAddress(
        val `packageAddress`: Address, 
        val `blueprintName`: String
        ) : Instruction()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is Instruction.TakeAllFromWorktop -> {
                
    Disposable.destroy(
        this.`resourceAddress`)
                
            }
            is Instruction.TakeFromWorktop -> {
                
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`amount`)
                
            }
            is Instruction.TakeNonFungiblesFromWorktop -> {
                
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`ids`)
                
            }
            is Instruction.ReturnToWorktop -> {
                
    Disposable.destroy(
        this.`bucketId`)
                
            }
            is Instruction.AssertWorktopContains -> {
                
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`amount`)
                
            }
            is Instruction.AssertWorktopContainsAny -> {
                
    Disposable.destroy(
        this.`resourceAddress`)
                
            }
            is Instruction.AssertWorktopContainsNonFungibles -> {
                
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`ids`)
                
            }
            is Instruction.PopFromAuthZone -> {// Nothing to destroy
            }
            is Instruction.PushToAuthZone -> {
                
    Disposable.destroy(
        this.`proofId`)
                
            }
            is Instruction.CreateProofFromAuthZoneOfAmount -> {
                
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`amount`)
                
            }
            is Instruction.CreateProofFromAuthZoneOfNonFungibles -> {
                
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`ids`)
                
            }
            is Instruction.CreateProofFromAuthZoneOfAll -> {
                
    Disposable.destroy(
        this.`resourceAddress`)
                
            }
            is Instruction.DropAllProofs -> {// Nothing to destroy
            }
            is Instruction.DropNamedProofs -> {// Nothing to destroy
            }
            is Instruction.DropAuthZoneProofs -> {// Nothing to destroy
            }
            is Instruction.DropAuthZoneRegularProofs -> {// Nothing to destroy
            }
            is Instruction.DropAuthZoneSignatureProofs -> {// Nothing to destroy
            }
            is Instruction.CreateProofFromBucketOfAmount -> {
                
    Disposable.destroy(
        this.`bucketId`, 
        this.`amount`)
                
            }
            is Instruction.CreateProofFromBucketOfNonFungibles -> {
                
    Disposable.destroy(
        this.`bucketId`, 
        this.`ids`)
                
            }
            is Instruction.CreateProofFromBucketOfAll -> {
                
    Disposable.destroy(
        this.`bucketId`)
                
            }
            is Instruction.BurnResource -> {
                
    Disposable.destroy(
        this.`bucketId`)
                
            }
            is Instruction.CloneProof -> {
                
    Disposable.destroy(
        this.`proofId`)
                
            }
            is Instruction.DropProof -> {
                
    Disposable.destroy(
        this.`proofId`)
                
            }
            is Instruction.CallFunction -> {
                
    Disposable.destroy(
        this.`packageAddress`, 
        this.`blueprintName`, 
        this.`functionName`, 
        this.`args`)
                
            }
            is Instruction.CallMethod -> {
                
    Disposable.destroy(
        this.`address`, 
        this.`methodName`, 
        this.`args`)
                
            }
            is Instruction.CallRoyaltyMethod -> {
                
    Disposable.destroy(
        this.`address`, 
        this.`methodName`, 
        this.`args`)
                
            }
            is Instruction.CallMetadataMethod -> {
                
    Disposable.destroy(
        this.`address`, 
        this.`methodName`, 
        this.`args`)
                
            }
            is Instruction.CallRoleAssignmentMethod -> {
                
    Disposable.destroy(
        this.`address`, 
        this.`methodName`, 
        this.`args`)
                
            }
            is Instruction.CallDirectVaultMethod -> {
                
    Disposable.destroy(
        this.`address`, 
        this.`methodName`, 
        this.`args`)
                
            }
            is Instruction.AllocateGlobalAddress -> {
                
    Disposable.destroy(
        this.`packageAddress`, 
        this.`blueprintName`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeInstruction : FfiConverterRustBuffer<Instruction>{
    override fun read(buf: ByteBuffer): Instruction {
        return when(buf.getInt()) {
            1 -> Instruction.TakeAllFromWorktop(
                FfiConverterTypeAddress.read(buf),
                )
            2 -> Instruction.TakeFromWorktop(
                FfiConverterTypeAddress.read(buf),
                FfiConverterTypeDecimal.read(buf),
                )
            3 -> Instruction.TakeNonFungiblesFromWorktop(
                FfiConverterTypeAddress.read(buf),
                FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
                )
            4 -> Instruction.ReturnToWorktop(
                FfiConverterTypeManifestBucket.read(buf),
                )
            5 -> Instruction.AssertWorktopContains(
                FfiConverterTypeAddress.read(buf),
                FfiConverterTypeDecimal.read(buf),
                )
            6 -> Instruction.AssertWorktopContainsAny(
                FfiConverterTypeAddress.read(buf),
                )
            7 -> Instruction.AssertWorktopContainsNonFungibles(
                FfiConverterTypeAddress.read(buf),
                FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
                )
            8 -> Instruction.PopFromAuthZone
            9 -> Instruction.PushToAuthZone(
                FfiConverterTypeManifestProof.read(buf),
                )
            10 -> Instruction.CreateProofFromAuthZoneOfAmount(
                FfiConverterTypeAddress.read(buf),
                FfiConverterTypeDecimal.read(buf),
                )
            11 -> Instruction.CreateProofFromAuthZoneOfNonFungibles(
                FfiConverterTypeAddress.read(buf),
                FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
                )
            12 -> Instruction.CreateProofFromAuthZoneOfAll(
                FfiConverterTypeAddress.read(buf),
                )
            13 -> Instruction.DropAllProofs
            14 -> Instruction.DropNamedProofs
            15 -> Instruction.DropAuthZoneProofs
            16 -> Instruction.DropAuthZoneRegularProofs
            17 -> Instruction.DropAuthZoneSignatureProofs
            18 -> Instruction.CreateProofFromBucketOfAmount(
                FfiConverterTypeManifestBucket.read(buf),
                FfiConverterTypeDecimal.read(buf),
                )
            19 -> Instruction.CreateProofFromBucketOfNonFungibles(
                FfiConverterTypeManifestBucket.read(buf),
                FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
                )
            20 -> Instruction.CreateProofFromBucketOfAll(
                FfiConverterTypeManifestBucket.read(buf),
                )
            21 -> Instruction.BurnResource(
                FfiConverterTypeManifestBucket.read(buf),
                )
            22 -> Instruction.CloneProof(
                FfiConverterTypeManifestProof.read(buf),
                )
            23 -> Instruction.DropProof(
                FfiConverterTypeManifestProof.read(buf),
                )
            24 -> Instruction.CallFunction(
                FfiConverterTypeManifestAddress.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterTypeManifestValue.read(buf),
                )
            25 -> Instruction.CallMethod(
                FfiConverterTypeManifestAddress.read(buf),
                FfiConverterString.read(buf),
                FfiConverterTypeManifestValue.read(buf),
                )
            26 -> Instruction.CallRoyaltyMethod(
                FfiConverterTypeManifestAddress.read(buf),
                FfiConverterString.read(buf),
                FfiConverterTypeManifestValue.read(buf),
                )
            27 -> Instruction.CallMetadataMethod(
                FfiConverterTypeManifestAddress.read(buf),
                FfiConverterString.read(buf),
                FfiConverterTypeManifestValue.read(buf),
                )
            28 -> Instruction.CallRoleAssignmentMethod(
                FfiConverterTypeManifestAddress.read(buf),
                FfiConverterString.read(buf),
                FfiConverterTypeManifestValue.read(buf),
                )
            29 -> Instruction.CallDirectVaultMethod(
                FfiConverterTypeAddress.read(buf),
                FfiConverterString.read(buf),
                FfiConverterTypeManifestValue.read(buf),
                )
            30 -> Instruction.AllocateGlobalAddress(
                FfiConverterTypeAddress.read(buf),
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: Instruction) = when(value) {
        is Instruction.TakeAllFromWorktop -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
            )
        }
        is Instruction.TakeFromWorktop -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
                + FfiConverterTypeDecimal.allocationSize(value.`amount`)
            )
        }
        is Instruction.TakeNonFungiblesFromWorktop -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
                + FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`ids`)
            )
        }
        is Instruction.ReturnToWorktop -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestBucket.allocationSize(value.`bucketId`)
            )
        }
        is Instruction.AssertWorktopContains -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
                + FfiConverterTypeDecimal.allocationSize(value.`amount`)
            )
        }
        is Instruction.AssertWorktopContainsAny -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
            )
        }
        is Instruction.AssertWorktopContainsNonFungibles -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
                + FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`ids`)
            )
        }
        is Instruction.PopFromAuthZone -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is Instruction.PushToAuthZone -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestProof.allocationSize(value.`proofId`)
            )
        }
        is Instruction.CreateProofFromAuthZoneOfAmount -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
                + FfiConverterTypeDecimal.allocationSize(value.`amount`)
            )
        }
        is Instruction.CreateProofFromAuthZoneOfNonFungibles -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
                + FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`ids`)
            )
        }
        is Instruction.CreateProofFromAuthZoneOfAll -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
            )
        }
        is Instruction.DropAllProofs -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is Instruction.DropNamedProofs -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is Instruction.DropAuthZoneProofs -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is Instruction.DropAuthZoneRegularProofs -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is Instruction.DropAuthZoneSignatureProofs -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is Instruction.CreateProofFromBucketOfAmount -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestBucket.allocationSize(value.`bucketId`)
                + FfiConverterTypeDecimal.allocationSize(value.`amount`)
            )
        }
        is Instruction.CreateProofFromBucketOfNonFungibles -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestBucket.allocationSize(value.`bucketId`)
                + FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`ids`)
            )
        }
        is Instruction.CreateProofFromBucketOfAll -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestBucket.allocationSize(value.`bucketId`)
            )
        }
        is Instruction.BurnResource -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestBucket.allocationSize(value.`bucketId`)
            )
        }
        is Instruction.CloneProof -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestProof.allocationSize(value.`proofId`)
            )
        }
        is Instruction.DropProof -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestProof.allocationSize(value.`proofId`)
            )
        }
        is Instruction.CallFunction -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestAddress.allocationSize(value.`packageAddress`)
                + FfiConverterString.allocationSize(value.`blueprintName`)
                + FfiConverterString.allocationSize(value.`functionName`)
                + FfiConverterTypeManifestValue.allocationSize(value.`args`)
            )
        }
        is Instruction.CallMethod -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestAddress.allocationSize(value.`address`)
                + FfiConverterString.allocationSize(value.`methodName`)
                + FfiConverterTypeManifestValue.allocationSize(value.`args`)
            )
        }
        is Instruction.CallRoyaltyMethod -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestAddress.allocationSize(value.`address`)
                + FfiConverterString.allocationSize(value.`methodName`)
                + FfiConverterTypeManifestValue.allocationSize(value.`args`)
            )
        }
        is Instruction.CallMetadataMethod -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestAddress.allocationSize(value.`address`)
                + FfiConverterString.allocationSize(value.`methodName`)
                + FfiConverterTypeManifestValue.allocationSize(value.`args`)
            )
        }
        is Instruction.CallRoleAssignmentMethod -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestAddress.allocationSize(value.`address`)
                + FfiConverterString.allocationSize(value.`methodName`)
                + FfiConverterTypeManifestValue.allocationSize(value.`args`)
            )
        }
        is Instruction.CallDirectVaultMethod -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`address`)
                + FfiConverterString.allocationSize(value.`methodName`)
                + FfiConverterTypeManifestValue.allocationSize(value.`args`)
            )
        }
        is Instruction.AllocateGlobalAddress -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`packageAddress`)
                + FfiConverterString.allocationSize(value.`blueprintName`)
            )
        }
    }

    override fun write(value: Instruction, buf: ByteBuffer) {
        when(value) {
            is Instruction.TakeAllFromWorktop -> {
                buf.putInt(1)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                Unit
            }
            is Instruction.TakeFromWorktop -> {
                buf.putInt(2)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                FfiConverterTypeDecimal.write(value.`amount`, buf)
                Unit
            }
            is Instruction.TakeNonFungiblesFromWorktop -> {
                buf.putInt(3)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                FfiConverterSequenceTypeNonFungibleLocalId.write(value.`ids`, buf)
                Unit
            }
            is Instruction.ReturnToWorktop -> {
                buf.putInt(4)
                FfiConverterTypeManifestBucket.write(value.`bucketId`, buf)
                Unit
            }
            is Instruction.AssertWorktopContains -> {
                buf.putInt(5)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                FfiConverterTypeDecimal.write(value.`amount`, buf)
                Unit
            }
            is Instruction.AssertWorktopContainsAny -> {
                buf.putInt(6)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                Unit
            }
            is Instruction.AssertWorktopContainsNonFungibles -> {
                buf.putInt(7)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                FfiConverterSequenceTypeNonFungibleLocalId.write(value.`ids`, buf)
                Unit
            }
            is Instruction.PopFromAuthZone -> {
                buf.putInt(8)
                Unit
            }
            is Instruction.PushToAuthZone -> {
                buf.putInt(9)
                FfiConverterTypeManifestProof.write(value.`proofId`, buf)
                Unit
            }
            is Instruction.CreateProofFromAuthZoneOfAmount -> {
                buf.putInt(10)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                FfiConverterTypeDecimal.write(value.`amount`, buf)
                Unit
            }
            is Instruction.CreateProofFromAuthZoneOfNonFungibles -> {
                buf.putInt(11)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                FfiConverterSequenceTypeNonFungibleLocalId.write(value.`ids`, buf)
                Unit
            }
            is Instruction.CreateProofFromAuthZoneOfAll -> {
                buf.putInt(12)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                Unit
            }
            is Instruction.DropAllProofs -> {
                buf.putInt(13)
                Unit
            }
            is Instruction.DropNamedProofs -> {
                buf.putInt(14)
                Unit
            }
            is Instruction.DropAuthZoneProofs -> {
                buf.putInt(15)
                Unit
            }
            is Instruction.DropAuthZoneRegularProofs -> {
                buf.putInt(16)
                Unit
            }
            is Instruction.DropAuthZoneSignatureProofs -> {
                buf.putInt(17)
                Unit
            }
            is Instruction.CreateProofFromBucketOfAmount -> {
                buf.putInt(18)
                FfiConverterTypeManifestBucket.write(value.`bucketId`, buf)
                FfiConverterTypeDecimal.write(value.`amount`, buf)
                Unit
            }
            is Instruction.CreateProofFromBucketOfNonFungibles -> {
                buf.putInt(19)
                FfiConverterTypeManifestBucket.write(value.`bucketId`, buf)
                FfiConverterSequenceTypeNonFungibleLocalId.write(value.`ids`, buf)
                Unit
            }
            is Instruction.CreateProofFromBucketOfAll -> {
                buf.putInt(20)
                FfiConverterTypeManifestBucket.write(value.`bucketId`, buf)
                Unit
            }
            is Instruction.BurnResource -> {
                buf.putInt(21)
                FfiConverterTypeManifestBucket.write(value.`bucketId`, buf)
                Unit
            }
            is Instruction.CloneProof -> {
                buf.putInt(22)
                FfiConverterTypeManifestProof.write(value.`proofId`, buf)
                Unit
            }
            is Instruction.DropProof -> {
                buf.putInt(23)
                FfiConverterTypeManifestProof.write(value.`proofId`, buf)
                Unit
            }
            is Instruction.CallFunction -> {
                buf.putInt(24)
                FfiConverterTypeManifestAddress.write(value.`packageAddress`, buf)
                FfiConverterString.write(value.`blueprintName`, buf)
                FfiConverterString.write(value.`functionName`, buf)
                FfiConverterTypeManifestValue.write(value.`args`, buf)
                Unit
            }
            is Instruction.CallMethod -> {
                buf.putInt(25)
                FfiConverterTypeManifestAddress.write(value.`address`, buf)
                FfiConverterString.write(value.`methodName`, buf)
                FfiConverterTypeManifestValue.write(value.`args`, buf)
                Unit
            }
            is Instruction.CallRoyaltyMethod -> {
                buf.putInt(26)
                FfiConverterTypeManifestAddress.write(value.`address`, buf)
                FfiConverterString.write(value.`methodName`, buf)
                FfiConverterTypeManifestValue.write(value.`args`, buf)
                Unit
            }
            is Instruction.CallMetadataMethod -> {
                buf.putInt(27)
                FfiConverterTypeManifestAddress.write(value.`address`, buf)
                FfiConverterString.write(value.`methodName`, buf)
                FfiConverterTypeManifestValue.write(value.`args`, buf)
                Unit
            }
            is Instruction.CallRoleAssignmentMethod -> {
                buf.putInt(28)
                FfiConverterTypeManifestAddress.write(value.`address`, buf)
                FfiConverterString.write(value.`methodName`, buf)
                FfiConverterTypeManifestValue.write(value.`args`, buf)
                Unit
            }
            is Instruction.CallDirectVaultMethod -> {
                buf.putInt(29)
                FfiConverterTypeAddress.write(value.`address`, buf)
                FfiConverterString.write(value.`methodName`, buf)
                FfiConverterTypeManifestValue.write(value.`args`, buf)
                Unit
            }
            is Instruction.AllocateGlobalAddress -> {
                buf.putInt(30)
                FfiConverterTypeAddress.write(value.`packageAddress`, buf)
                FfiConverterString.write(value.`blueprintName`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class LocalTypeId {
    data class WellKnown(
        val `value`: UByte
        ) : LocalTypeId()
    data class SchemaLocalIndex(
        val `value`: ULong
        ) : LocalTypeId()
    

    
}

public object FfiConverterTypeLocalTypeId : FfiConverterRustBuffer<LocalTypeId>{
    override fun read(buf: ByteBuffer): LocalTypeId {
        return when(buf.getInt()) {
            1 -> LocalTypeId.WellKnown(
                FfiConverterUByte.read(buf),
                )
            2 -> LocalTypeId.SchemaLocalIndex(
                FfiConverterULong.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: LocalTypeId) = when(value) {
        is LocalTypeId.WellKnown -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterUByte.allocationSize(value.`value`)
            )
        }
        is LocalTypeId.SchemaLocalIndex -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterULong.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: LocalTypeId, buf: ByteBuffer) {
        when(value) {
            is LocalTypeId.WellKnown -> {
                buf.putInt(1)
                FfiConverterUByte.write(value.`value`, buf)
                Unit
            }
            is LocalTypeId.SchemaLocalIndex -> {
                buf.putInt(2)
                FfiConverterULong.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class ManifestAddress: Disposable  {
    data class Named(
        val `value`: UInt
        ) : ManifestAddress()
    data class Static(
        val `value`: Address
        ) : ManifestAddress()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is ManifestAddress.Named -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestAddress.Static -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeManifestAddress : FfiConverterRustBuffer<ManifestAddress>{
    override fun read(buf: ByteBuffer): ManifestAddress {
        return when(buf.getInt()) {
            1 -> ManifestAddress.Named(
                FfiConverterUInt.read(buf),
                )
            2 -> ManifestAddress.Static(
                FfiConverterTypeAddress.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ManifestAddress) = when(value) {
        is ManifestAddress.Named -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterUInt.allocationSize(value.`value`)
            )
        }
        is ManifestAddress.Static -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: ManifestAddress, buf: ByteBuffer) {
        when(value) {
            is ManifestAddress.Named -> {
                buf.putInt(1)
                FfiConverterUInt.write(value.`value`, buf)
                Unit
            }
            is ManifestAddress.Static -> {
                buf.putInt(2)
                FfiConverterTypeAddress.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class ManifestBuilderAddress: Disposable  {
    data class Named(
        val `value`: ManifestBuilderNamedAddress
        ) : ManifestBuilderAddress()
    data class Static(
        val `value`: Address
        ) : ManifestBuilderAddress()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is ManifestBuilderAddress.Named -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderAddress.Static -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeManifestBuilderAddress : FfiConverterRustBuffer<ManifestBuilderAddress>{
    override fun read(buf: ByteBuffer): ManifestBuilderAddress {
        return when(buf.getInt()) {
            1 -> ManifestBuilderAddress.Named(
                FfiConverterTypeManifestBuilderNamedAddress.read(buf),
                )
            2 -> ManifestBuilderAddress.Static(
                FfiConverterTypeAddress.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ManifestBuilderAddress) = when(value) {
        is ManifestBuilderAddress.Named -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestBuilderNamedAddress.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderAddress.Static -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: ManifestBuilderAddress, buf: ByteBuffer) {
        when(value) {
            is ManifestBuilderAddress.Named -> {
                buf.putInt(1)
                FfiConverterTypeManifestBuilderNamedAddress.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderAddress.Static -> {
                buf.putInt(2)
                FfiConverterTypeAddress.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class ManifestBuilderValue: Disposable  {
    data class BoolValue(
        val `value`: Boolean
        ) : ManifestBuilderValue()
    data class I8Value(
        val `value`: Byte
        ) : ManifestBuilderValue()
    data class I16Value(
        val `value`: Short
        ) : ManifestBuilderValue()
    data class I32Value(
        val `value`: Int
        ) : ManifestBuilderValue()
    data class I64Value(
        val `value`: Long
        ) : ManifestBuilderValue()
    data class I128Value(
        val `value`: String
        ) : ManifestBuilderValue()
    data class U8Value(
        val `value`: UByte
        ) : ManifestBuilderValue()
    data class U16Value(
        val `value`: UShort
        ) : ManifestBuilderValue()
    data class U32Value(
        val `value`: UInt
        ) : ManifestBuilderValue()
    data class U64Value(
        val `value`: ULong
        ) : ManifestBuilderValue()
    data class U128Value(
        val `value`: String
        ) : ManifestBuilderValue()
    data class StringValue(
        val `value`: String
        ) : ManifestBuilderValue()
    data class EnumValue(
        val `discriminator`: UByte, 
        val `fields`: List<ManifestBuilderValue>
        ) : ManifestBuilderValue()
    data class ArrayValue(
        val `elementValueKind`: ManifestBuilderValueKind, 
        val `elements`: List<ManifestBuilderValue>
        ) : ManifestBuilderValue()
    data class TupleValue(
        val `fields`: List<ManifestBuilderValue>
        ) : ManifestBuilderValue()
    data class MapValue(
        val `keyValueKind`: ManifestBuilderValueKind, 
        val `valueValueKind`: ManifestBuilderValueKind, 
        val `entries`: List<ManifestBuilderMapEntry>
        ) : ManifestBuilderValue()
    data class AddressValue(
        val `value`: ManifestBuilderAddress
        ) : ManifestBuilderValue()
    data class BucketValue(
        val `value`: ManifestBuilderBucket
        ) : ManifestBuilderValue()
    data class ProofValue(
        val `value`: ManifestBuilderProof
        ) : ManifestBuilderValue()
    data class ExpressionValue(
        val `value`: ManifestExpression
        ) : ManifestBuilderValue()
    data class BlobValue(
        val `value`: ManifestBlobRef
        ) : ManifestBuilderValue()
    data class DecimalValue(
        val `value`: Decimal
        ) : ManifestBuilderValue()
    data class PreciseDecimalValue(
        val `value`: PreciseDecimal
        ) : ManifestBuilderValue()
    data class NonFungibleLocalIdValue(
        val `value`: NonFungibleLocalId
        ) : ManifestBuilderValue()
    data class AddressReservationValue(
        val `value`: ManifestBuilderAddressReservation
        ) : ManifestBuilderValue()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is ManifestBuilderValue.BoolValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderValue.I8Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderValue.I16Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderValue.I32Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderValue.I64Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderValue.I128Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderValue.U8Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderValue.U16Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderValue.U32Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderValue.U64Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderValue.U128Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderValue.StringValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderValue.EnumValue -> {
                
    Disposable.destroy(
        this.`discriminator`, 
        this.`fields`)
                
            }
            is ManifestBuilderValue.ArrayValue -> {
                
    Disposable.destroy(
        this.`elementValueKind`, 
        this.`elements`)
                
            }
            is ManifestBuilderValue.TupleValue -> {
                
    Disposable.destroy(
        this.`fields`)
                
            }
            is ManifestBuilderValue.MapValue -> {
                
    Disposable.destroy(
        this.`keyValueKind`, 
        this.`valueValueKind`, 
        this.`entries`)
                
            }
            is ManifestBuilderValue.AddressValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderValue.BucketValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderValue.ProofValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderValue.ExpressionValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderValue.BlobValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderValue.DecimalValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderValue.PreciseDecimalValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderValue.NonFungibleLocalIdValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestBuilderValue.AddressReservationValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeManifestBuilderValue : FfiConverterRustBuffer<ManifestBuilderValue>{
    override fun read(buf: ByteBuffer): ManifestBuilderValue {
        return when(buf.getInt()) {
            1 -> ManifestBuilderValue.BoolValue(
                FfiConverterBoolean.read(buf),
                )
            2 -> ManifestBuilderValue.I8Value(
                FfiConverterByte.read(buf),
                )
            3 -> ManifestBuilderValue.I16Value(
                FfiConverterShort.read(buf),
                )
            4 -> ManifestBuilderValue.I32Value(
                FfiConverterInt.read(buf),
                )
            5 -> ManifestBuilderValue.I64Value(
                FfiConverterLong.read(buf),
                )
            6 -> ManifestBuilderValue.I128Value(
                FfiConverterString.read(buf),
                )
            7 -> ManifestBuilderValue.U8Value(
                FfiConverterUByte.read(buf),
                )
            8 -> ManifestBuilderValue.U16Value(
                FfiConverterUShort.read(buf),
                )
            9 -> ManifestBuilderValue.U32Value(
                FfiConverterUInt.read(buf),
                )
            10 -> ManifestBuilderValue.U64Value(
                FfiConverterULong.read(buf),
                )
            11 -> ManifestBuilderValue.U128Value(
                FfiConverterString.read(buf),
                )
            12 -> ManifestBuilderValue.StringValue(
                FfiConverterString.read(buf),
                )
            13 -> ManifestBuilderValue.EnumValue(
                FfiConverterUByte.read(buf),
                FfiConverterSequenceTypeManifestBuilderValue.read(buf),
                )
            14 -> ManifestBuilderValue.ArrayValue(
                FfiConverterTypeManifestBuilderValueKind.read(buf),
                FfiConverterSequenceTypeManifestBuilderValue.read(buf),
                )
            15 -> ManifestBuilderValue.TupleValue(
                FfiConverterSequenceTypeManifestBuilderValue.read(buf),
                )
            16 -> ManifestBuilderValue.MapValue(
                FfiConverterTypeManifestBuilderValueKind.read(buf),
                FfiConverterTypeManifestBuilderValueKind.read(buf),
                FfiConverterSequenceTypeManifestBuilderMapEntry.read(buf),
                )
            17 -> ManifestBuilderValue.AddressValue(
                FfiConverterTypeManifestBuilderAddress.read(buf),
                )
            18 -> ManifestBuilderValue.BucketValue(
                FfiConverterTypeManifestBuilderBucket.read(buf),
                )
            19 -> ManifestBuilderValue.ProofValue(
                FfiConverterTypeManifestBuilderProof.read(buf),
                )
            20 -> ManifestBuilderValue.ExpressionValue(
                FfiConverterTypeManifestExpression.read(buf),
                )
            21 -> ManifestBuilderValue.BlobValue(
                FfiConverterTypeManifestBlobRef.read(buf),
                )
            22 -> ManifestBuilderValue.DecimalValue(
                FfiConverterTypeDecimal.read(buf),
                )
            23 -> ManifestBuilderValue.PreciseDecimalValue(
                FfiConverterTypePreciseDecimal.read(buf),
                )
            24 -> ManifestBuilderValue.NonFungibleLocalIdValue(
                FfiConverterTypeNonFungibleLocalId.read(buf),
                )
            25 -> ManifestBuilderValue.AddressReservationValue(
                FfiConverterTypeManifestBuilderAddressReservation.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ManifestBuilderValue) = when(value) {
        is ManifestBuilderValue.BoolValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterBoolean.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderValue.I8Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterByte.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderValue.I16Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterShort.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderValue.I32Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterInt.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderValue.I64Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterLong.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderValue.I128Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderValue.U8Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterUByte.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderValue.U16Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterUShort.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderValue.U32Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterUInt.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderValue.U64Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterULong.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderValue.U128Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderValue.StringValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderValue.EnumValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterUByte.allocationSize(value.`discriminator`)
                + FfiConverterSequenceTypeManifestBuilderValue.allocationSize(value.`fields`)
            )
        }
        is ManifestBuilderValue.ArrayValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestBuilderValueKind.allocationSize(value.`elementValueKind`)
                + FfiConverterSequenceTypeManifestBuilderValue.allocationSize(value.`elements`)
            )
        }
        is ManifestBuilderValue.TupleValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceTypeManifestBuilderValue.allocationSize(value.`fields`)
            )
        }
        is ManifestBuilderValue.MapValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestBuilderValueKind.allocationSize(value.`keyValueKind`)
                + FfiConverterTypeManifestBuilderValueKind.allocationSize(value.`valueValueKind`)
                + FfiConverterSequenceTypeManifestBuilderMapEntry.allocationSize(value.`entries`)
            )
        }
        is ManifestBuilderValue.AddressValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestBuilderAddress.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderValue.BucketValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestBuilderBucket.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderValue.ProofValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestBuilderProof.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderValue.ExpressionValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestExpression.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderValue.BlobValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestBlobRef.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderValue.DecimalValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeDecimal.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderValue.PreciseDecimalValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypePreciseDecimal.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderValue.NonFungibleLocalIdValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeNonFungibleLocalId.allocationSize(value.`value`)
            )
        }
        is ManifestBuilderValue.AddressReservationValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestBuilderAddressReservation.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: ManifestBuilderValue, buf: ByteBuffer) {
        when(value) {
            is ManifestBuilderValue.BoolValue -> {
                buf.putInt(1)
                FfiConverterBoolean.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderValue.I8Value -> {
                buf.putInt(2)
                FfiConverterByte.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderValue.I16Value -> {
                buf.putInt(3)
                FfiConverterShort.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderValue.I32Value -> {
                buf.putInt(4)
                FfiConverterInt.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderValue.I64Value -> {
                buf.putInt(5)
                FfiConverterLong.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderValue.I128Value -> {
                buf.putInt(6)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderValue.U8Value -> {
                buf.putInt(7)
                FfiConverterUByte.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderValue.U16Value -> {
                buf.putInt(8)
                FfiConverterUShort.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderValue.U32Value -> {
                buf.putInt(9)
                FfiConverterUInt.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderValue.U64Value -> {
                buf.putInt(10)
                FfiConverterULong.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderValue.U128Value -> {
                buf.putInt(11)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderValue.StringValue -> {
                buf.putInt(12)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderValue.EnumValue -> {
                buf.putInt(13)
                FfiConverterUByte.write(value.`discriminator`, buf)
                FfiConverterSequenceTypeManifestBuilderValue.write(value.`fields`, buf)
                Unit
            }
            is ManifestBuilderValue.ArrayValue -> {
                buf.putInt(14)
                FfiConverterTypeManifestBuilderValueKind.write(value.`elementValueKind`, buf)
                FfiConverterSequenceTypeManifestBuilderValue.write(value.`elements`, buf)
                Unit
            }
            is ManifestBuilderValue.TupleValue -> {
                buf.putInt(15)
                FfiConverterSequenceTypeManifestBuilderValue.write(value.`fields`, buf)
                Unit
            }
            is ManifestBuilderValue.MapValue -> {
                buf.putInt(16)
                FfiConverterTypeManifestBuilderValueKind.write(value.`keyValueKind`, buf)
                FfiConverterTypeManifestBuilderValueKind.write(value.`valueValueKind`, buf)
                FfiConverterSequenceTypeManifestBuilderMapEntry.write(value.`entries`, buf)
                Unit
            }
            is ManifestBuilderValue.AddressValue -> {
                buf.putInt(17)
                FfiConverterTypeManifestBuilderAddress.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderValue.BucketValue -> {
                buf.putInt(18)
                FfiConverterTypeManifestBuilderBucket.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderValue.ProofValue -> {
                buf.putInt(19)
                FfiConverterTypeManifestBuilderProof.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderValue.ExpressionValue -> {
                buf.putInt(20)
                FfiConverterTypeManifestExpression.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderValue.BlobValue -> {
                buf.putInt(21)
                FfiConverterTypeManifestBlobRef.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderValue.DecimalValue -> {
                buf.putInt(22)
                FfiConverterTypeDecimal.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderValue.PreciseDecimalValue -> {
                buf.putInt(23)
                FfiConverterTypePreciseDecimal.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderValue.NonFungibleLocalIdValue -> {
                buf.putInt(24)
                FfiConverterTypeNonFungibleLocalId.write(value.`value`, buf)
                Unit
            }
            is ManifestBuilderValue.AddressReservationValue -> {
                buf.putInt(25)
                FfiConverterTypeManifestBuilderAddressReservation.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class ManifestBuilderValueKind {
    BOOL_VALUE,I8_VALUE,I16_VALUE,I32_VALUE,I64_VALUE,I128_VALUE,U8_VALUE,U16_VALUE,U32_VALUE,U64_VALUE,U128_VALUE,STRING_VALUE,ENUM_VALUE,ARRAY_VALUE,TUPLE_VALUE,MAP_VALUE,ADDRESS_VALUE,BUCKET_VALUE,PROOF_VALUE,EXPRESSION_VALUE,BLOB_VALUE,DECIMAL_VALUE,PRECISE_DECIMAL_VALUE,NON_FUNGIBLE_LOCAL_ID_VALUE,ADDRESS_RESERVATION_VALUE;
}

public object FfiConverterTypeManifestBuilderValueKind: FfiConverterRustBuffer<ManifestBuilderValueKind> {
    override fun read(buf: ByteBuffer) = try {
        ManifestBuilderValueKind.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ManifestBuilderValueKind) = 4

    override fun write(value: ManifestBuilderValueKind, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class ManifestExpression {
    ENTIRE_WORKTOP,ENTIRE_AUTH_ZONE;
}

public object FfiConverterTypeManifestExpression: FfiConverterRustBuffer<ManifestExpression> {
    override fun read(buf: ByteBuffer) = try {
        ManifestExpression.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ManifestExpression) = 4

    override fun write(value: ManifestExpression, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






sealed class ManifestSborStringRepresentation {
    object ManifestString : ManifestSborStringRepresentation()
    
    data class Json(
        val `value`: SerializationMode
        ) : ManifestSborStringRepresentation()
    

    
}

public object FfiConverterTypeManifestSborStringRepresentation : FfiConverterRustBuffer<ManifestSborStringRepresentation>{
    override fun read(buf: ByteBuffer): ManifestSborStringRepresentation {
        return when(buf.getInt()) {
            1 -> ManifestSborStringRepresentation.ManifestString
            2 -> ManifestSborStringRepresentation.Json(
                FfiConverterTypeSerializationMode.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ManifestSborStringRepresentation) = when(value) {
        is ManifestSborStringRepresentation.ManifestString -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is ManifestSborStringRepresentation.Json -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeSerializationMode.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: ManifestSborStringRepresentation, buf: ByteBuffer) {
        when(value) {
            is ManifestSborStringRepresentation.ManifestString -> {
                buf.putInt(1)
                Unit
            }
            is ManifestSborStringRepresentation.Json -> {
                buf.putInt(2)
                FfiConverterTypeSerializationMode.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class ManifestValue: Disposable  {
    data class BoolValue(
        val `value`: Boolean
        ) : ManifestValue()
    data class I8Value(
        val `value`: Byte
        ) : ManifestValue()
    data class I16Value(
        val `value`: Short
        ) : ManifestValue()
    data class I32Value(
        val `value`: Int
        ) : ManifestValue()
    data class I64Value(
        val `value`: Long
        ) : ManifestValue()
    data class I128Value(
        val `value`: String
        ) : ManifestValue()
    data class U8Value(
        val `value`: UByte
        ) : ManifestValue()
    data class U16Value(
        val `value`: UShort
        ) : ManifestValue()
    data class U32Value(
        val `value`: UInt
        ) : ManifestValue()
    data class U64Value(
        val `value`: ULong
        ) : ManifestValue()
    data class U128Value(
        val `value`: String
        ) : ManifestValue()
    data class StringValue(
        val `value`: String
        ) : ManifestValue()
    data class EnumValue(
        val `discriminator`: UByte, 
        val `fields`: List<ManifestValue>
        ) : ManifestValue()
    data class ArrayValue(
        val `elementValueKind`: ManifestValueKind, 
        val `elements`: List<ManifestValue>
        ) : ManifestValue()
    data class TupleValue(
        val `fields`: List<ManifestValue>
        ) : ManifestValue()
    data class MapValue(
        val `keyValueKind`: ManifestValueKind, 
        val `valueValueKind`: ManifestValueKind, 
        val `entries`: List<MapEntry>
        ) : ManifestValue()
    data class AddressValue(
        val `value`: ManifestAddress
        ) : ManifestValue()
    data class BucketValue(
        val `value`: ManifestBucket
        ) : ManifestValue()
    data class ProofValue(
        val `value`: ManifestProof
        ) : ManifestValue()
    data class ExpressionValue(
        val `value`: ManifestExpression
        ) : ManifestValue()
    data class BlobValue(
        val `value`: ManifestBlobRef
        ) : ManifestValue()
    data class DecimalValue(
        val `value`: Decimal
        ) : ManifestValue()
    data class PreciseDecimalValue(
        val `value`: PreciseDecimal
        ) : ManifestValue()
    data class NonFungibleLocalIdValue(
        val `value`: NonFungibleLocalId
        ) : ManifestValue()
    data class AddressReservationValue(
        val `value`: ManifestAddressReservation
        ) : ManifestValue()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is ManifestValue.BoolValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestValue.I8Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestValue.I16Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestValue.I32Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestValue.I64Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestValue.I128Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestValue.U8Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestValue.U16Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestValue.U32Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestValue.U64Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestValue.U128Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestValue.StringValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestValue.EnumValue -> {
                
    Disposable.destroy(
        this.`discriminator`, 
        this.`fields`)
                
            }
            is ManifestValue.ArrayValue -> {
                
    Disposable.destroy(
        this.`elementValueKind`, 
        this.`elements`)
                
            }
            is ManifestValue.TupleValue -> {
                
    Disposable.destroy(
        this.`fields`)
                
            }
            is ManifestValue.MapValue -> {
                
    Disposable.destroy(
        this.`keyValueKind`, 
        this.`valueValueKind`, 
        this.`entries`)
                
            }
            is ManifestValue.AddressValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestValue.BucketValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestValue.ProofValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestValue.ExpressionValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestValue.BlobValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestValue.DecimalValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestValue.PreciseDecimalValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestValue.NonFungibleLocalIdValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ManifestValue.AddressReservationValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeManifestValue : FfiConverterRustBuffer<ManifestValue>{
    override fun read(buf: ByteBuffer): ManifestValue {
        return when(buf.getInt()) {
            1 -> ManifestValue.BoolValue(
                FfiConverterBoolean.read(buf),
                )
            2 -> ManifestValue.I8Value(
                FfiConverterByte.read(buf),
                )
            3 -> ManifestValue.I16Value(
                FfiConverterShort.read(buf),
                )
            4 -> ManifestValue.I32Value(
                FfiConverterInt.read(buf),
                )
            5 -> ManifestValue.I64Value(
                FfiConverterLong.read(buf),
                )
            6 -> ManifestValue.I128Value(
                FfiConverterString.read(buf),
                )
            7 -> ManifestValue.U8Value(
                FfiConverterUByte.read(buf),
                )
            8 -> ManifestValue.U16Value(
                FfiConverterUShort.read(buf),
                )
            9 -> ManifestValue.U32Value(
                FfiConverterUInt.read(buf),
                )
            10 -> ManifestValue.U64Value(
                FfiConverterULong.read(buf),
                )
            11 -> ManifestValue.U128Value(
                FfiConverterString.read(buf),
                )
            12 -> ManifestValue.StringValue(
                FfiConverterString.read(buf),
                )
            13 -> ManifestValue.EnumValue(
                FfiConverterUByte.read(buf),
                FfiConverterSequenceTypeManifestValue.read(buf),
                )
            14 -> ManifestValue.ArrayValue(
                FfiConverterTypeManifestValueKind.read(buf),
                FfiConverterSequenceTypeManifestValue.read(buf),
                )
            15 -> ManifestValue.TupleValue(
                FfiConverterSequenceTypeManifestValue.read(buf),
                )
            16 -> ManifestValue.MapValue(
                FfiConverterTypeManifestValueKind.read(buf),
                FfiConverterTypeManifestValueKind.read(buf),
                FfiConverterSequenceTypeMapEntry.read(buf),
                )
            17 -> ManifestValue.AddressValue(
                FfiConverterTypeManifestAddress.read(buf),
                )
            18 -> ManifestValue.BucketValue(
                FfiConverterTypeManifestBucket.read(buf),
                )
            19 -> ManifestValue.ProofValue(
                FfiConverterTypeManifestProof.read(buf),
                )
            20 -> ManifestValue.ExpressionValue(
                FfiConverterTypeManifestExpression.read(buf),
                )
            21 -> ManifestValue.BlobValue(
                FfiConverterTypeManifestBlobRef.read(buf),
                )
            22 -> ManifestValue.DecimalValue(
                FfiConverterTypeDecimal.read(buf),
                )
            23 -> ManifestValue.PreciseDecimalValue(
                FfiConverterTypePreciseDecimal.read(buf),
                )
            24 -> ManifestValue.NonFungibleLocalIdValue(
                FfiConverterTypeNonFungibleLocalId.read(buf),
                )
            25 -> ManifestValue.AddressReservationValue(
                FfiConverterTypeManifestAddressReservation.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ManifestValue) = when(value) {
        is ManifestValue.BoolValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterBoolean.allocationSize(value.`value`)
            )
        }
        is ManifestValue.I8Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterByte.allocationSize(value.`value`)
            )
        }
        is ManifestValue.I16Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterShort.allocationSize(value.`value`)
            )
        }
        is ManifestValue.I32Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterInt.allocationSize(value.`value`)
            )
        }
        is ManifestValue.I64Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterLong.allocationSize(value.`value`)
            )
        }
        is ManifestValue.I128Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
        is ManifestValue.U8Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterUByte.allocationSize(value.`value`)
            )
        }
        is ManifestValue.U16Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterUShort.allocationSize(value.`value`)
            )
        }
        is ManifestValue.U32Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterUInt.allocationSize(value.`value`)
            )
        }
        is ManifestValue.U64Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterULong.allocationSize(value.`value`)
            )
        }
        is ManifestValue.U128Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
        is ManifestValue.StringValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
        is ManifestValue.EnumValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterUByte.allocationSize(value.`discriminator`)
                + FfiConverterSequenceTypeManifestValue.allocationSize(value.`fields`)
            )
        }
        is ManifestValue.ArrayValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestValueKind.allocationSize(value.`elementValueKind`)
                + FfiConverterSequenceTypeManifestValue.allocationSize(value.`elements`)
            )
        }
        is ManifestValue.TupleValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceTypeManifestValue.allocationSize(value.`fields`)
            )
        }
        is ManifestValue.MapValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestValueKind.allocationSize(value.`keyValueKind`)
                + FfiConverterTypeManifestValueKind.allocationSize(value.`valueValueKind`)
                + FfiConverterSequenceTypeMapEntry.allocationSize(value.`entries`)
            )
        }
        is ManifestValue.AddressValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestAddress.allocationSize(value.`value`)
            )
        }
        is ManifestValue.BucketValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestBucket.allocationSize(value.`value`)
            )
        }
        is ManifestValue.ProofValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestProof.allocationSize(value.`value`)
            )
        }
        is ManifestValue.ExpressionValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestExpression.allocationSize(value.`value`)
            )
        }
        is ManifestValue.BlobValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestBlobRef.allocationSize(value.`value`)
            )
        }
        is ManifestValue.DecimalValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeDecimal.allocationSize(value.`value`)
            )
        }
        is ManifestValue.PreciseDecimalValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypePreciseDecimal.allocationSize(value.`value`)
            )
        }
        is ManifestValue.NonFungibleLocalIdValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeNonFungibleLocalId.allocationSize(value.`value`)
            )
        }
        is ManifestValue.AddressReservationValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeManifestAddressReservation.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: ManifestValue, buf: ByteBuffer) {
        when(value) {
            is ManifestValue.BoolValue -> {
                buf.putInt(1)
                FfiConverterBoolean.write(value.`value`, buf)
                Unit
            }
            is ManifestValue.I8Value -> {
                buf.putInt(2)
                FfiConverterByte.write(value.`value`, buf)
                Unit
            }
            is ManifestValue.I16Value -> {
                buf.putInt(3)
                FfiConverterShort.write(value.`value`, buf)
                Unit
            }
            is ManifestValue.I32Value -> {
                buf.putInt(4)
                FfiConverterInt.write(value.`value`, buf)
                Unit
            }
            is ManifestValue.I64Value -> {
                buf.putInt(5)
                FfiConverterLong.write(value.`value`, buf)
                Unit
            }
            is ManifestValue.I128Value -> {
                buf.putInt(6)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
            is ManifestValue.U8Value -> {
                buf.putInt(7)
                FfiConverterUByte.write(value.`value`, buf)
                Unit
            }
            is ManifestValue.U16Value -> {
                buf.putInt(8)
                FfiConverterUShort.write(value.`value`, buf)
                Unit
            }
            is ManifestValue.U32Value -> {
                buf.putInt(9)
                FfiConverterUInt.write(value.`value`, buf)
                Unit
            }
            is ManifestValue.U64Value -> {
                buf.putInt(10)
                FfiConverterULong.write(value.`value`, buf)
                Unit
            }
            is ManifestValue.U128Value -> {
                buf.putInt(11)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
            is ManifestValue.StringValue -> {
                buf.putInt(12)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
            is ManifestValue.EnumValue -> {
                buf.putInt(13)
                FfiConverterUByte.write(value.`discriminator`, buf)
                FfiConverterSequenceTypeManifestValue.write(value.`fields`, buf)
                Unit
            }
            is ManifestValue.ArrayValue -> {
                buf.putInt(14)
                FfiConverterTypeManifestValueKind.write(value.`elementValueKind`, buf)
                FfiConverterSequenceTypeManifestValue.write(value.`elements`, buf)
                Unit
            }
            is ManifestValue.TupleValue -> {
                buf.putInt(15)
                FfiConverterSequenceTypeManifestValue.write(value.`fields`, buf)
                Unit
            }
            is ManifestValue.MapValue -> {
                buf.putInt(16)
                FfiConverterTypeManifestValueKind.write(value.`keyValueKind`, buf)
                FfiConverterTypeManifestValueKind.write(value.`valueValueKind`, buf)
                FfiConverterSequenceTypeMapEntry.write(value.`entries`, buf)
                Unit
            }
            is ManifestValue.AddressValue -> {
                buf.putInt(17)
                FfiConverterTypeManifestAddress.write(value.`value`, buf)
                Unit
            }
            is ManifestValue.BucketValue -> {
                buf.putInt(18)
                FfiConverterTypeManifestBucket.write(value.`value`, buf)
                Unit
            }
            is ManifestValue.ProofValue -> {
                buf.putInt(19)
                FfiConverterTypeManifestProof.write(value.`value`, buf)
                Unit
            }
            is ManifestValue.ExpressionValue -> {
                buf.putInt(20)
                FfiConverterTypeManifestExpression.write(value.`value`, buf)
                Unit
            }
            is ManifestValue.BlobValue -> {
                buf.putInt(21)
                FfiConverterTypeManifestBlobRef.write(value.`value`, buf)
                Unit
            }
            is ManifestValue.DecimalValue -> {
                buf.putInt(22)
                FfiConverterTypeDecimal.write(value.`value`, buf)
                Unit
            }
            is ManifestValue.PreciseDecimalValue -> {
                buf.putInt(23)
                FfiConverterTypePreciseDecimal.write(value.`value`, buf)
                Unit
            }
            is ManifestValue.NonFungibleLocalIdValue -> {
                buf.putInt(24)
                FfiConverterTypeNonFungibleLocalId.write(value.`value`, buf)
                Unit
            }
            is ManifestValue.AddressReservationValue -> {
                buf.putInt(25)
                FfiConverterTypeManifestAddressReservation.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class ManifestValueKind {
    BOOL_VALUE,I8_VALUE,I16_VALUE,I32_VALUE,I64_VALUE,I128_VALUE,U8_VALUE,U16_VALUE,U32_VALUE,U64_VALUE,U128_VALUE,STRING_VALUE,ENUM_VALUE,ARRAY_VALUE,TUPLE_VALUE,MAP_VALUE,ADDRESS_VALUE,BUCKET_VALUE,PROOF_VALUE,EXPRESSION_VALUE,BLOB_VALUE,DECIMAL_VALUE,PRECISE_DECIMAL_VALUE,NON_FUNGIBLE_LOCAL_ID_VALUE,ADDRESS_RESERVATION_VALUE;
}

public object FfiConverterTypeManifestValueKind: FfiConverterRustBuffer<ManifestValueKind> {
    override fun read(buf: ByteBuffer) = try {
        ManifestValueKind.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ManifestValueKind) = 4

    override fun write(value: ManifestValueKind, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






sealed class Message {
    object None : Message()
    
    data class PlainText(
        val `value`: PlainTextMessage
        ) : Message()
    data class Encrypted(
        val `value`: EncryptedMessage
        ) : Message()
    

    
}

public object FfiConverterTypeMessage : FfiConverterRustBuffer<Message>{
    override fun read(buf: ByteBuffer): Message {
        return when(buf.getInt()) {
            1 -> Message.None
            2 -> Message.PlainText(
                FfiConverterTypePlainTextMessage.read(buf),
                )
            3 -> Message.Encrypted(
                FfiConverterTypeEncryptedMessage.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: Message) = when(value) {
        is Message.None -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is Message.PlainText -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypePlainTextMessage.allocationSize(value.`value`)
            )
        }
        is Message.Encrypted -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeEncryptedMessage.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: Message, buf: ByteBuffer) {
        when(value) {
            is Message.None -> {
                buf.putInt(1)
                Unit
            }
            is Message.PlainText -> {
                buf.putInt(2)
                FfiConverterTypePlainTextMessage.write(value.`value`, buf)
                Unit
            }
            is Message.Encrypted -> {
                buf.putInt(3)
                FfiConverterTypeEncryptedMessage.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class MessageContent {
    data class Str(
        val `value`: String
        ) : MessageContent()
    data class Bytes(
        val `value`: List<UByte>
        ) : MessageContent()
    

    
}

public object FfiConverterTypeMessageContent : FfiConverterRustBuffer<MessageContent>{
    override fun read(buf: ByteBuffer): MessageContent {
        return when(buf.getInt()) {
            1 -> MessageContent.Str(
                FfiConverterString.read(buf),
                )
            2 -> MessageContent.Bytes(
                FfiConverterSequenceUByte.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MessageContent) = when(value) {
        is MessageContent.Str -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
        is MessageContent.Bytes -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceUByte.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: MessageContent, buf: ByteBuffer) {
        when(value) {
            is MessageContent.Str -> {
                buf.putInt(1)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
            is MessageContent.Bytes -> {
                buf.putInt(2)
                FfiConverterSequenceUByte.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class MetadataValue: Disposable  {
    data class StringValue(
        val `value`: String
        ) : MetadataValue()
    data class BoolValue(
        val `value`: Boolean
        ) : MetadataValue()
    data class U8Value(
        val `value`: UByte
        ) : MetadataValue()
    data class U32Value(
        val `value`: UInt
        ) : MetadataValue()
    data class U64Value(
        val `value`: ULong
        ) : MetadataValue()
    data class I32Value(
        val `value`: Int
        ) : MetadataValue()
    data class I64Value(
        val `value`: Long
        ) : MetadataValue()
    data class DecimalValue(
        val `value`: Decimal
        ) : MetadataValue()
    data class GlobalAddressValue(
        val `value`: Address
        ) : MetadataValue()
    data class PublicKeyValue(
        val `value`: PublicKey
        ) : MetadataValue()
    data class NonFungibleGlobalIdValue(
        val `value`: NonFungibleGlobalId
        ) : MetadataValue()
    data class NonFungibleLocalIdValue(
        val `value`: NonFungibleLocalId
        ) : MetadataValue()
    data class InstantValue(
        val `value`: Long
        ) : MetadataValue()
    data class UrlValue(
        val `value`: String
        ) : MetadataValue()
    data class OriginValue(
        val `value`: String
        ) : MetadataValue()
    data class PublicKeyHashValue(
        val `value`: PublicKeyHash
        ) : MetadataValue()
    data class StringArrayValue(
        val `value`: List<String>
        ) : MetadataValue()
    data class BoolArrayValue(
        val `value`: List<Boolean>
        ) : MetadataValue()
    data class U8ArrayValue(
        val `value`: List<UByte>
        ) : MetadataValue()
    data class U32ArrayValue(
        val `value`: List<UInt>
        ) : MetadataValue()
    data class U64ArrayValue(
        val `value`: List<ULong>
        ) : MetadataValue()
    data class I32ArrayValue(
        val `value`: List<Int>
        ) : MetadataValue()
    data class I64ArrayValue(
        val `value`: List<Long>
        ) : MetadataValue()
    data class DecimalArrayValue(
        val `value`: List<Decimal>
        ) : MetadataValue()
    data class GlobalAddressArrayValue(
        val `value`: List<Address>
        ) : MetadataValue()
    data class PublicKeyArrayValue(
        val `value`: List<PublicKey>
        ) : MetadataValue()
    data class NonFungibleGlobalIdArrayValue(
        val `value`: List<NonFungibleGlobalId>
        ) : MetadataValue()
    data class NonFungibleLocalIdArrayValue(
        val `value`: List<NonFungibleLocalId>
        ) : MetadataValue()
    data class InstantArrayValue(
        val `value`: List<Long>
        ) : MetadataValue()
    data class UrlArrayValue(
        val `value`: List<String>
        ) : MetadataValue()
    data class OriginArrayValue(
        val `value`: List<String>
        ) : MetadataValue()
    data class PublicKeyHashArrayValue(
        val `value`: List<PublicKeyHash>
        ) : MetadataValue()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is MetadataValue.StringValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.BoolValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.U8Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.U32Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.U64Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.I32Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.I64Value -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.DecimalValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.GlobalAddressValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.PublicKeyValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.NonFungibleGlobalIdValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.NonFungibleLocalIdValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.InstantValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.UrlValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.OriginValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.PublicKeyHashValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.StringArrayValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.BoolArrayValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.U8ArrayValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.U32ArrayValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.U64ArrayValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.I32ArrayValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.I64ArrayValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.DecimalArrayValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.GlobalAddressArrayValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.PublicKeyArrayValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.NonFungibleGlobalIdArrayValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.NonFungibleLocalIdArrayValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.InstantArrayValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.UrlArrayValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.OriginArrayValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is MetadataValue.PublicKeyHashArrayValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeMetadataValue : FfiConverterRustBuffer<MetadataValue>{
    override fun read(buf: ByteBuffer): MetadataValue {
        return when(buf.getInt()) {
            1 -> MetadataValue.StringValue(
                FfiConverterString.read(buf),
                )
            2 -> MetadataValue.BoolValue(
                FfiConverterBoolean.read(buf),
                )
            3 -> MetadataValue.U8Value(
                FfiConverterUByte.read(buf),
                )
            4 -> MetadataValue.U32Value(
                FfiConverterUInt.read(buf),
                )
            5 -> MetadataValue.U64Value(
                FfiConverterULong.read(buf),
                )
            6 -> MetadataValue.I32Value(
                FfiConverterInt.read(buf),
                )
            7 -> MetadataValue.I64Value(
                FfiConverterLong.read(buf),
                )
            8 -> MetadataValue.DecimalValue(
                FfiConverterTypeDecimal.read(buf),
                )
            9 -> MetadataValue.GlobalAddressValue(
                FfiConverterTypeAddress.read(buf),
                )
            10 -> MetadataValue.PublicKeyValue(
                FfiConverterTypePublicKey.read(buf),
                )
            11 -> MetadataValue.NonFungibleGlobalIdValue(
                FfiConverterTypeNonFungibleGlobalId.read(buf),
                )
            12 -> MetadataValue.NonFungibleLocalIdValue(
                FfiConverterTypeNonFungibleLocalId.read(buf),
                )
            13 -> MetadataValue.InstantValue(
                FfiConverterLong.read(buf),
                )
            14 -> MetadataValue.UrlValue(
                FfiConverterString.read(buf),
                )
            15 -> MetadataValue.OriginValue(
                FfiConverterString.read(buf),
                )
            16 -> MetadataValue.PublicKeyHashValue(
                FfiConverterTypePublicKeyHash.read(buf),
                )
            17 -> MetadataValue.StringArrayValue(
                FfiConverterSequenceString.read(buf),
                )
            18 -> MetadataValue.BoolArrayValue(
                FfiConverterSequenceBoolean.read(buf),
                )
            19 -> MetadataValue.U8ArrayValue(
                FfiConverterSequenceUByte.read(buf),
                )
            20 -> MetadataValue.U32ArrayValue(
                FfiConverterSequenceUInt.read(buf),
                )
            21 -> MetadataValue.U64ArrayValue(
                FfiConverterSequenceULong.read(buf),
                )
            22 -> MetadataValue.I32ArrayValue(
                FfiConverterSequenceInt.read(buf),
                )
            23 -> MetadataValue.I64ArrayValue(
                FfiConverterSequenceLong.read(buf),
                )
            24 -> MetadataValue.DecimalArrayValue(
                FfiConverterSequenceTypeDecimal.read(buf),
                )
            25 -> MetadataValue.GlobalAddressArrayValue(
                FfiConverterSequenceTypeAddress.read(buf),
                )
            26 -> MetadataValue.PublicKeyArrayValue(
                FfiConverterSequenceTypePublicKey.read(buf),
                )
            27 -> MetadataValue.NonFungibleGlobalIdArrayValue(
                FfiConverterSequenceTypeNonFungibleGlobalId.read(buf),
                )
            28 -> MetadataValue.NonFungibleLocalIdArrayValue(
                FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
                )
            29 -> MetadataValue.InstantArrayValue(
                FfiConverterSequenceLong.read(buf),
                )
            30 -> MetadataValue.UrlArrayValue(
                FfiConverterSequenceString.read(buf),
                )
            31 -> MetadataValue.OriginArrayValue(
                FfiConverterSequenceString.read(buf),
                )
            32 -> MetadataValue.PublicKeyHashArrayValue(
                FfiConverterSequenceTypePublicKeyHash.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: MetadataValue) = when(value) {
        is MetadataValue.StringValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
        is MetadataValue.BoolValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterBoolean.allocationSize(value.`value`)
            )
        }
        is MetadataValue.U8Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterUByte.allocationSize(value.`value`)
            )
        }
        is MetadataValue.U32Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterUInt.allocationSize(value.`value`)
            )
        }
        is MetadataValue.U64Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterULong.allocationSize(value.`value`)
            )
        }
        is MetadataValue.I32Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterInt.allocationSize(value.`value`)
            )
        }
        is MetadataValue.I64Value -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterLong.allocationSize(value.`value`)
            )
        }
        is MetadataValue.DecimalValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeDecimal.allocationSize(value.`value`)
            )
        }
        is MetadataValue.GlobalAddressValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`value`)
            )
        }
        is MetadataValue.PublicKeyValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypePublicKey.allocationSize(value.`value`)
            )
        }
        is MetadataValue.NonFungibleGlobalIdValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeNonFungibleGlobalId.allocationSize(value.`value`)
            )
        }
        is MetadataValue.NonFungibleLocalIdValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeNonFungibleLocalId.allocationSize(value.`value`)
            )
        }
        is MetadataValue.InstantValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterLong.allocationSize(value.`value`)
            )
        }
        is MetadataValue.UrlValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
        is MetadataValue.OriginValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
        is MetadataValue.PublicKeyHashValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypePublicKeyHash.allocationSize(value.`value`)
            )
        }
        is MetadataValue.StringArrayValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceString.allocationSize(value.`value`)
            )
        }
        is MetadataValue.BoolArrayValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceBoolean.allocationSize(value.`value`)
            )
        }
        is MetadataValue.U8ArrayValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceUByte.allocationSize(value.`value`)
            )
        }
        is MetadataValue.U32ArrayValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceUInt.allocationSize(value.`value`)
            )
        }
        is MetadataValue.U64ArrayValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceULong.allocationSize(value.`value`)
            )
        }
        is MetadataValue.I32ArrayValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceInt.allocationSize(value.`value`)
            )
        }
        is MetadataValue.I64ArrayValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceLong.allocationSize(value.`value`)
            )
        }
        is MetadataValue.DecimalArrayValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceTypeDecimal.allocationSize(value.`value`)
            )
        }
        is MetadataValue.GlobalAddressArrayValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceTypeAddress.allocationSize(value.`value`)
            )
        }
        is MetadataValue.PublicKeyArrayValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceTypePublicKey.allocationSize(value.`value`)
            )
        }
        is MetadataValue.NonFungibleGlobalIdArrayValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceTypeNonFungibleGlobalId.allocationSize(value.`value`)
            )
        }
        is MetadataValue.NonFungibleLocalIdArrayValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`value`)
            )
        }
        is MetadataValue.InstantArrayValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceLong.allocationSize(value.`value`)
            )
        }
        is MetadataValue.UrlArrayValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceString.allocationSize(value.`value`)
            )
        }
        is MetadataValue.OriginArrayValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceString.allocationSize(value.`value`)
            )
        }
        is MetadataValue.PublicKeyHashArrayValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceTypePublicKeyHash.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: MetadataValue, buf: ByteBuffer) {
        when(value) {
            is MetadataValue.StringValue -> {
                buf.putInt(1)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.BoolValue -> {
                buf.putInt(2)
                FfiConverterBoolean.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.U8Value -> {
                buf.putInt(3)
                FfiConverterUByte.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.U32Value -> {
                buf.putInt(4)
                FfiConverterUInt.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.U64Value -> {
                buf.putInt(5)
                FfiConverterULong.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.I32Value -> {
                buf.putInt(6)
                FfiConverterInt.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.I64Value -> {
                buf.putInt(7)
                FfiConverterLong.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.DecimalValue -> {
                buf.putInt(8)
                FfiConverterTypeDecimal.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.GlobalAddressValue -> {
                buf.putInt(9)
                FfiConverterTypeAddress.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.PublicKeyValue -> {
                buf.putInt(10)
                FfiConverterTypePublicKey.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.NonFungibleGlobalIdValue -> {
                buf.putInt(11)
                FfiConverterTypeNonFungibleGlobalId.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.NonFungibleLocalIdValue -> {
                buf.putInt(12)
                FfiConverterTypeNonFungibleLocalId.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.InstantValue -> {
                buf.putInt(13)
                FfiConverterLong.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.UrlValue -> {
                buf.putInt(14)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.OriginValue -> {
                buf.putInt(15)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.PublicKeyHashValue -> {
                buf.putInt(16)
                FfiConverterTypePublicKeyHash.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.StringArrayValue -> {
                buf.putInt(17)
                FfiConverterSequenceString.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.BoolArrayValue -> {
                buf.putInt(18)
                FfiConverterSequenceBoolean.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.U8ArrayValue -> {
                buf.putInt(19)
                FfiConverterSequenceUByte.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.U32ArrayValue -> {
                buf.putInt(20)
                FfiConverterSequenceUInt.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.U64ArrayValue -> {
                buf.putInt(21)
                FfiConverterSequenceULong.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.I32ArrayValue -> {
                buf.putInt(22)
                FfiConverterSequenceInt.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.I64ArrayValue -> {
                buf.putInt(23)
                FfiConverterSequenceLong.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.DecimalArrayValue -> {
                buf.putInt(24)
                FfiConverterSequenceTypeDecimal.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.GlobalAddressArrayValue -> {
                buf.putInt(25)
                FfiConverterSequenceTypeAddress.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.PublicKeyArrayValue -> {
                buf.putInt(26)
                FfiConverterSequenceTypePublicKey.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.NonFungibleGlobalIdArrayValue -> {
                buf.putInt(27)
                FfiConverterSequenceTypeNonFungibleGlobalId.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.NonFungibleLocalIdArrayValue -> {
                buf.putInt(28)
                FfiConverterSequenceTypeNonFungibleLocalId.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.InstantArrayValue -> {
                buf.putInt(29)
                FfiConverterSequenceLong.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.UrlArrayValue -> {
                buf.putInt(30)
                FfiConverterSequenceString.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.OriginArrayValue -> {
                buf.putInt(31)
                FfiConverterSequenceString.write(value.`value`, buf)
                Unit
            }
            is MetadataValue.PublicKeyHashArrayValue -> {
                buf.putInt(32)
                FfiConverterSequenceTypePublicKeyHash.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class NameRecordError {
    data class ObjectNameIsAlreadyTaken(
        val `object`: String, 
        val `name`: String
        ) : NameRecordError()
    data class ObjectDoesNotExist(
        val `object`: String, 
        val `name`: String
        ) : NameRecordError()
    

    
}

public object FfiConverterTypeNameRecordError : FfiConverterRustBuffer<NameRecordError>{
    override fun read(buf: ByteBuffer): NameRecordError {
        return when(buf.getInt()) {
            1 -> NameRecordError.ObjectNameIsAlreadyTaken(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            2 -> NameRecordError.ObjectDoesNotExist(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: NameRecordError) = when(value) {
        is NameRecordError.ObjectNameIsAlreadyTaken -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`object`)
                + FfiConverterString.allocationSize(value.`name`)
            )
        }
        is NameRecordError.ObjectDoesNotExist -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`object`)
                + FfiConverterString.allocationSize(value.`name`)
            )
        }
    }

    override fun write(value: NameRecordError, buf: ByteBuffer) {
        when(value) {
            is NameRecordError.ObjectNameIsAlreadyTaken -> {
                buf.putInt(1)
                FfiConverterString.write(value.`object`, buf)
                FfiConverterString.write(value.`name`, buf)
                Unit
            }
            is NameRecordError.ObjectDoesNotExist -> {
                buf.putInt(2)
                FfiConverterString.write(value.`object`, buf)
                FfiConverterString.write(value.`name`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class NonFungibleLocalId {
    data class Integer(
        val `value`: ULong
        ) : NonFungibleLocalId()
    data class Str(
        val `value`: String
        ) : NonFungibleLocalId()
    data class Bytes(
        val `value`: List<UByte>
        ) : NonFungibleLocalId()
    data class Ruid(
        val `value`: List<UByte>
        ) : NonFungibleLocalId()
    

    
}

public object FfiConverterTypeNonFungibleLocalId : FfiConverterRustBuffer<NonFungibleLocalId>{
    override fun read(buf: ByteBuffer): NonFungibleLocalId {
        return when(buf.getInt()) {
            1 -> NonFungibleLocalId.Integer(
                FfiConverterULong.read(buf),
                )
            2 -> NonFungibleLocalId.Str(
                FfiConverterString.read(buf),
                )
            3 -> NonFungibleLocalId.Bytes(
                FfiConverterSequenceUByte.read(buf),
                )
            4 -> NonFungibleLocalId.Ruid(
                FfiConverterSequenceUByte.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: NonFungibleLocalId) = when(value) {
        is NonFungibleLocalId.Integer -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterULong.allocationSize(value.`value`)
            )
        }
        is NonFungibleLocalId.Str -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
        is NonFungibleLocalId.Bytes -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceUByte.allocationSize(value.`value`)
            )
        }
        is NonFungibleLocalId.Ruid -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceUByte.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: NonFungibleLocalId, buf: ByteBuffer) {
        when(value) {
            is NonFungibleLocalId.Integer -> {
                buf.putInt(1)
                FfiConverterULong.write(value.`value`, buf)
                Unit
            }
            is NonFungibleLocalId.Str -> {
                buf.putInt(2)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
            is NonFungibleLocalId.Bytes -> {
                buf.putInt(3)
                FfiConverterSequenceUByte.write(value.`value`, buf)
                Unit
            }
            is NonFungibleLocalId.Ruid -> {
                buf.putInt(4)
                FfiConverterSequenceUByte.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class NonFungibleLocalIdVecSource {
    data class Guaranteed(
        val `value`: List<NonFungibleLocalId>
        ) : NonFungibleLocalIdVecSource()
    data class Predicted(
        val `instructionIndex`: ULong, 
        val `value`: List<NonFungibleLocalId>
        ) : NonFungibleLocalIdVecSource()
    

    
}

public object FfiConverterTypeNonFungibleLocalIdVecSource : FfiConverterRustBuffer<NonFungibleLocalIdVecSource>{
    override fun read(buf: ByteBuffer): NonFungibleLocalIdVecSource {
        return when(buf.getInt()) {
            1 -> NonFungibleLocalIdVecSource.Guaranteed(
                FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
                )
            2 -> NonFungibleLocalIdVecSource.Predicted(
                FfiConverterULong.read(buf),
                FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: NonFungibleLocalIdVecSource) = when(value) {
        is NonFungibleLocalIdVecSource.Guaranteed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`value`)
            )
        }
        is NonFungibleLocalIdVecSource.Predicted -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterULong.allocationSize(value.`instructionIndex`)
                + FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: NonFungibleLocalIdVecSource, buf: ByteBuffer) {
        when(value) {
            is NonFungibleLocalIdVecSource.Guaranteed -> {
                buf.putInt(1)
                FfiConverterSequenceTypeNonFungibleLocalId.write(value.`value`, buf)
                Unit
            }
            is NonFungibleLocalIdVecSource.Predicted -> {
                buf.putInt(2)
                FfiConverterULong.write(value.`instructionIndex`, buf)
                FfiConverterSequenceTypeNonFungibleLocalId.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class ObjectModuleId {
    MAIN,METADATA,ROYALTY,ROLE_ASSIGNMENT;
}

public object FfiConverterTypeObjectModuleId: FfiConverterRustBuffer<ObjectModuleId> {
    override fun read(buf: ByteBuffer) = try {
        ObjectModuleId.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ObjectModuleId) = 4

    override fun write(value: ObjectModuleId, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class OlympiaNetwork {
    MAINNET,STOKENET,RELEASENET,RC_NET,MILESTONENET,DEVOPSNET,SANDPITNET,LOCALNET;
}

public object FfiConverterTypeOlympiaNetwork: FfiConverterRustBuffer<OlympiaNetwork> {
    override fun read(buf: ByteBuffer) = try {
        OlympiaNetwork.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: OlympiaNetwork) = 4

    override fun write(value: OlympiaNetwork, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






sealed class OwnerRole: Disposable  {
    object None : OwnerRole()
    
    data class Fixed(
        val `value`: AccessRule
        ) : OwnerRole()
    data class Updatable(
        val `value`: AccessRule
        ) : OwnerRole()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is OwnerRole.None -> {// Nothing to destroy
            }
            is OwnerRole.Fixed -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is OwnerRole.Updatable -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeOwnerRole : FfiConverterRustBuffer<OwnerRole>{
    override fun read(buf: ByteBuffer): OwnerRole {
        return when(buf.getInt()) {
            1 -> OwnerRole.None
            2 -> OwnerRole.Fixed(
                FfiConverterTypeAccessRule.read(buf),
                )
            3 -> OwnerRole.Updatable(
                FfiConverterTypeAccessRule.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: OwnerRole) = when(value) {
        is OwnerRole.None -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is OwnerRole.Fixed -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAccessRule.allocationSize(value.`value`)
            )
        }
        is OwnerRole.Updatable -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAccessRule.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: OwnerRole, buf: ByteBuffer) {
        when(value) {
            is OwnerRole.None -> {
                buf.putInt(1)
                Unit
            }
            is OwnerRole.Fixed -> {
                buf.putInt(2)
                FfiConverterTypeAccessRule.write(value.`value`, buf)
                Unit
            }
            is OwnerRole.Updatable -> {
                buf.putInt(3)
                FfiConverterTypeAccessRule.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class Proposer {
    PRIMARY,RECOVERY;
}

public object FfiConverterTypeProposer: FfiConverterRustBuffer<Proposer> {
    override fun read(buf: ByteBuffer) = try {
        Proposer.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: Proposer) = 4

    override fun write(value: Proposer, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






sealed class PublicKey {
    data class Secp256k1(
        val `value`: List<UByte>
        ) : PublicKey()
    data class Ed25519(
        val `value`: List<UByte>
        ) : PublicKey()
    

    
}

public object FfiConverterTypePublicKey : FfiConverterRustBuffer<PublicKey>{
    override fun read(buf: ByteBuffer): PublicKey {
        return when(buf.getInt()) {
            1 -> PublicKey.Secp256k1(
                FfiConverterSequenceUByte.read(buf),
                )
            2 -> PublicKey.Ed25519(
                FfiConverterSequenceUByte.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PublicKey) = when(value) {
        is PublicKey.Secp256k1 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceUByte.allocationSize(value.`value`)
            )
        }
        is PublicKey.Ed25519 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceUByte.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: PublicKey, buf: ByteBuffer) {
        when(value) {
            is PublicKey.Secp256k1 -> {
                buf.putInt(1)
                FfiConverterSequenceUByte.write(value.`value`, buf)
                Unit
            }
            is PublicKey.Ed25519 -> {
                buf.putInt(2)
                FfiConverterSequenceUByte.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class PublicKeyHash {
    data class Secp256k1(
        val `value`: List<UByte>
        ) : PublicKeyHash()
    data class Ed25519(
        val `value`: List<UByte>
        ) : PublicKeyHash()
    

    
}

public object FfiConverterTypePublicKeyHash : FfiConverterRustBuffer<PublicKeyHash>{
    override fun read(buf: ByteBuffer): PublicKeyHash {
        return when(buf.getInt()) {
            1 -> PublicKeyHash.Secp256k1(
                FfiConverterSequenceUByte.read(buf),
                )
            2 -> PublicKeyHash.Ed25519(
                FfiConverterSequenceUByte.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: PublicKeyHash) = when(value) {
        is PublicKeyHash.Secp256k1 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceUByte.allocationSize(value.`value`)
            )
        }
        is PublicKeyHash.Ed25519 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceUByte.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: PublicKeyHash, buf: ByteBuffer) {
        when(value) {
            is PublicKeyHash.Secp256k1 -> {
                buf.putInt(1)
                FfiConverterSequenceUByte.write(value.`value`, buf)
                Unit
            }
            is PublicKeyHash.Ed25519 -> {
                buf.putInt(2)
                FfiConverterSequenceUByte.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class RadixEngineToolkitException: Exception() {
    // Each variant is a nested class
    
    class InvalidLength(
        val `expected`: ULong, 
        val `actual`: ULong, 
        val `data`: List<UByte>
        ) : RadixEngineToolkitException() {
        override val message
            get() = "expected=${ `expected` }, actual=${ `actual` }, data=${ `data` }"
    }
    
    class FailedToExtractNetwork(
        val `address`: String
        ) : RadixEngineToolkitException() {
        override val message
            get() = "address=${ `address` }"
    }
    
    class Bech32DecodeException(
        val `error`: String
        ) : RadixEngineToolkitException() {
        override val message
            get() = "error=${ `error` }"
    }
    
    class ParseException(
        val `typeName`: String, 
        val `error`: String
        ) : RadixEngineToolkitException() {
        override val message
            get() = "typeName=${ `typeName` }, error=${ `error` }"
    }
    
    class NonFungibleContentValidationException(
        val `error`: String
        ) : RadixEngineToolkitException() {
        override val message
            get() = "error=${ `error` }"
    }
    
    class EntityTypeMismatchException(
        val `expected`: List<EntityType>, 
        val `actual`: EntityType
        ) : RadixEngineToolkitException() {
        override val message
            get() = "expected=${ `expected` }, actual=${ `actual` }"
    }
    
    class DerivationException(
        val `error`: String
        ) : RadixEngineToolkitException() {
        override val message
            get() = "error=${ `error` }"
    }
    
    class InvalidPublicKey(
        ) : RadixEngineToolkitException() {
        override val message
            get() = ""
    }
    
    class CompileException(
        val `error`: String
        ) : RadixEngineToolkitException() {
        override val message
            get() = "error=${ `error` }"
    }
    
    class DecompileException(
        val `error`: String
        ) : RadixEngineToolkitException() {
        override val message
            get() = "error=${ `error` }"
    }
    
    class PrepareException(
        val `error`: String
        ) : RadixEngineToolkitException() {
        override val message
            get() = "error=${ `error` }"
    }
    
    class EncodeException(
        val `error`: String
        ) : RadixEngineToolkitException() {
        override val message
            get() = "error=${ `error` }"
    }
    
    class DecodeException(
        val `error`: String
        ) : RadixEngineToolkitException() {
        override val message
            get() = "error=${ `error` }"
    }
    
    class TransactionValidationFailed(
        val `error`: String
        ) : RadixEngineToolkitException() {
        override val message
            get() = "error=${ `error` }"
    }
    
    class ExecutionModuleException(
        val `error`: String
        ) : RadixEngineToolkitException() {
        override val message
            get() = "error=${ `error` }"
    }
    
    class ManifestSborException(
        val `error`: String
        ) : RadixEngineToolkitException() {
        override val message
            get() = "error=${ `error` }"
    }
    
    class ScryptoSborException(
        val `error`: String
        ) : RadixEngineToolkitException() {
        override val message
            get() = "error=${ `error` }"
    }
    
    class TypedNativeEventException(
        val `error`: String
        ) : RadixEngineToolkitException() {
        override val message
            get() = "error=${ `error` }"
    }
    
    class FailedToDecodeTransactionHash(
        ) : RadixEngineToolkitException() {
        override val message
            get() = ""
    }
    
    class ManifestBuilderNameRecordException(
        val `error`: NameRecordError
        ) : RadixEngineToolkitException() {
        override val message
            get() = "error=${ `error` }"
    }
    
    class ManifestModificationException(
        val `error`: String
        ) : RadixEngineToolkitException() {
        override val message
            get() = "error=${ `error` }"
    }
    
    class InvalidEntityTypeIdException(
        val `error`: String
        ) : RadixEngineToolkitException() {
        override val message
            get() = "error=${ `error` }"
    }
    
    class DecimalException(
        ) : RadixEngineToolkitException() {
        override val message
            get() = ""
    }
    

    companion object ErrorHandler : CallStatusErrorHandler<RadixEngineToolkitException> {
        override fun lift(error_buf: RustBuffer.ByValue): RadixEngineToolkitException = FfiConverterTypeRadixEngineToolkitError.lift(error_buf)
    }

    
}

public object FfiConverterTypeRadixEngineToolkitError : FfiConverterRustBuffer<RadixEngineToolkitException> {
    override fun read(buf: ByteBuffer): RadixEngineToolkitException {
        

        return when(buf.getInt()) {
            1 -> RadixEngineToolkitException.InvalidLength(
                FfiConverterULong.read(buf),
                FfiConverterULong.read(buf),
                FfiConverterSequenceUByte.read(buf),
                )
            2 -> RadixEngineToolkitException.FailedToExtractNetwork(
                FfiConverterString.read(buf),
                )
            3 -> RadixEngineToolkitException.Bech32DecodeException(
                FfiConverterString.read(buf),
                )
            4 -> RadixEngineToolkitException.ParseException(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                )
            5 -> RadixEngineToolkitException.NonFungibleContentValidationException(
                FfiConverterString.read(buf),
                )
            6 -> RadixEngineToolkitException.EntityTypeMismatchException(
                FfiConverterSequenceTypeEntityType.read(buf),
                FfiConverterTypeEntityType.read(buf),
                )
            7 -> RadixEngineToolkitException.DerivationException(
                FfiConverterString.read(buf),
                )
            8 -> RadixEngineToolkitException.InvalidPublicKey()
            9 -> RadixEngineToolkitException.CompileException(
                FfiConverterString.read(buf),
                )
            10 -> RadixEngineToolkitException.DecompileException(
                FfiConverterString.read(buf),
                )
            11 -> RadixEngineToolkitException.PrepareException(
                FfiConverterString.read(buf),
                )
            12 -> RadixEngineToolkitException.EncodeException(
                FfiConverterString.read(buf),
                )
            13 -> RadixEngineToolkitException.DecodeException(
                FfiConverterString.read(buf),
                )
            14 -> RadixEngineToolkitException.TransactionValidationFailed(
                FfiConverterString.read(buf),
                )
            15 -> RadixEngineToolkitException.ExecutionModuleException(
                FfiConverterString.read(buf),
                )
            16 -> RadixEngineToolkitException.ManifestSborException(
                FfiConverterString.read(buf),
                )
            17 -> RadixEngineToolkitException.ScryptoSborException(
                FfiConverterString.read(buf),
                )
            18 -> RadixEngineToolkitException.TypedNativeEventException(
                FfiConverterString.read(buf),
                )
            19 -> RadixEngineToolkitException.FailedToDecodeTransactionHash()
            20 -> RadixEngineToolkitException.ManifestBuilderNameRecordException(
                FfiConverterTypeNameRecordError.read(buf),
                )
            21 -> RadixEngineToolkitException.ManifestModificationException(
                FfiConverterString.read(buf),
                )
            22 -> RadixEngineToolkitException.InvalidEntityTypeIdException(
                FfiConverterString.read(buf),
                )
            23 -> RadixEngineToolkitException.DecimalException()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RadixEngineToolkitException): Int {
        return when(value) {
            is RadixEngineToolkitException.InvalidLength -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterULong.allocationSize(value.`expected`)
                + FfiConverterULong.allocationSize(value.`actual`)
                + FfiConverterSequenceUByte.allocationSize(value.`data`)
            )
            is RadixEngineToolkitException.FailedToExtractNetwork -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`address`)
            )
            is RadixEngineToolkitException.Bech32DecodeException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`error`)
            )
            is RadixEngineToolkitException.ParseException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`typeName`)
                + FfiConverterString.allocationSize(value.`error`)
            )
            is RadixEngineToolkitException.NonFungibleContentValidationException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`error`)
            )
            is RadixEngineToolkitException.EntityTypeMismatchException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterSequenceTypeEntityType.allocationSize(value.`expected`)
                + FfiConverterTypeEntityType.allocationSize(value.`actual`)
            )
            is RadixEngineToolkitException.DerivationException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`error`)
            )
            is RadixEngineToolkitException.InvalidPublicKey -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
            )
            is RadixEngineToolkitException.CompileException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`error`)
            )
            is RadixEngineToolkitException.DecompileException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`error`)
            )
            is RadixEngineToolkitException.PrepareException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`error`)
            )
            is RadixEngineToolkitException.EncodeException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`error`)
            )
            is RadixEngineToolkitException.DecodeException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`error`)
            )
            is RadixEngineToolkitException.TransactionValidationFailed -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`error`)
            )
            is RadixEngineToolkitException.ExecutionModuleException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`error`)
            )
            is RadixEngineToolkitException.ManifestSborException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`error`)
            )
            is RadixEngineToolkitException.ScryptoSborException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`error`)
            )
            is RadixEngineToolkitException.TypedNativeEventException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`error`)
            )
            is RadixEngineToolkitException.FailedToDecodeTransactionHash -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
            )
            is RadixEngineToolkitException.ManifestBuilderNameRecordException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterTypeNameRecordError.allocationSize(value.`error`)
            )
            is RadixEngineToolkitException.ManifestModificationException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`error`)
            )
            is RadixEngineToolkitException.InvalidEntityTypeIdException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
                + FfiConverterString.allocationSize(value.`error`)
            )
            is RadixEngineToolkitException.DecimalException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4
            )
        }
    }

    override fun write(value: RadixEngineToolkitException, buf: ByteBuffer) {
        when(value) {
            is RadixEngineToolkitException.InvalidLength -> {
                buf.putInt(1)
                FfiConverterULong.write(value.`expected`, buf)
                FfiConverterULong.write(value.`actual`, buf)
                FfiConverterSequenceUByte.write(value.`data`, buf)
                Unit
            }
            is RadixEngineToolkitException.FailedToExtractNetwork -> {
                buf.putInt(2)
                FfiConverterString.write(value.`address`, buf)
                Unit
            }
            is RadixEngineToolkitException.Bech32DecodeException -> {
                buf.putInt(3)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is RadixEngineToolkitException.ParseException -> {
                buf.putInt(4)
                FfiConverterString.write(value.`typeName`, buf)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is RadixEngineToolkitException.NonFungibleContentValidationException -> {
                buf.putInt(5)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is RadixEngineToolkitException.EntityTypeMismatchException -> {
                buf.putInt(6)
                FfiConverterSequenceTypeEntityType.write(value.`expected`, buf)
                FfiConverterTypeEntityType.write(value.`actual`, buf)
                Unit
            }
            is RadixEngineToolkitException.DerivationException -> {
                buf.putInt(7)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is RadixEngineToolkitException.InvalidPublicKey -> {
                buf.putInt(8)
                Unit
            }
            is RadixEngineToolkitException.CompileException -> {
                buf.putInt(9)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is RadixEngineToolkitException.DecompileException -> {
                buf.putInt(10)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is RadixEngineToolkitException.PrepareException -> {
                buf.putInt(11)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is RadixEngineToolkitException.EncodeException -> {
                buf.putInt(12)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is RadixEngineToolkitException.DecodeException -> {
                buf.putInt(13)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is RadixEngineToolkitException.TransactionValidationFailed -> {
                buf.putInt(14)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is RadixEngineToolkitException.ExecutionModuleException -> {
                buf.putInt(15)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is RadixEngineToolkitException.ManifestSborException -> {
                buf.putInt(16)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is RadixEngineToolkitException.ScryptoSborException -> {
                buf.putInt(17)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is RadixEngineToolkitException.TypedNativeEventException -> {
                buf.putInt(18)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is RadixEngineToolkitException.FailedToDecodeTransactionHash -> {
                buf.putInt(19)
                Unit
            }
            is RadixEngineToolkitException.ManifestBuilderNameRecordException -> {
                buf.putInt(20)
                FfiConverterTypeNameRecordError.write(value.`error`, buf)
                Unit
            }
            is RadixEngineToolkitException.ManifestModificationException -> {
                buf.putInt(21)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is RadixEngineToolkitException.InvalidEntityTypeIdException -> {
                buf.putInt(22)
                FfiConverterString.write(value.`error`, buf)
                Unit
            }
            is RadixEngineToolkitException.DecimalException -> {
                buf.putInt(23)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




sealed class RecallResourceEvent: Disposable  {
    data class Amount(
        val `value`: Decimal
        ) : RecallResourceEvent()
    data class Ids(
        val `value`: List<NonFungibleLocalId>
        ) : RecallResourceEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is RecallResourceEvent.Amount -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is RecallResourceEvent.Ids -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeRecallResourceEvent : FfiConverterRustBuffer<RecallResourceEvent>{
    override fun read(buf: ByteBuffer): RecallResourceEvent {
        return when(buf.getInt()) {
            1 -> RecallResourceEvent.Amount(
                FfiConverterTypeDecimal.read(buf),
                )
            2 -> RecallResourceEvent.Ids(
                FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: RecallResourceEvent) = when(value) {
        is RecallResourceEvent.Amount -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeDecimal.allocationSize(value.`value`)
            )
        }
        is RecallResourceEvent.Ids -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: RecallResourceEvent, buf: ByteBuffer) {
        when(value) {
            is RecallResourceEvent.Amount -> {
                buf.putInt(1)
                FfiConverterTypeDecimal.write(value.`value`, buf)
                Unit
            }
            is RecallResourceEvent.Ids -> {
                buf.putInt(2)
                FfiConverterSequenceTypeNonFungibleLocalId.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class ReservedInstruction {
    ACCOUNT_LOCK_FEE,ACCOUNT_SECURIFY,IDENTITY_SECURIFY,ACCOUNT_UPDATE_SETTINGS,ACCESS_CONTROLLER;
}

public object FfiConverterTypeReservedInstruction: FfiConverterRustBuffer<ReservedInstruction> {
    override fun read(buf: ByteBuffer) = try {
        ReservedInstruction.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ReservedInstruction) = 4

    override fun write(value: ReservedInstruction, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






sealed class ResourceOrNonFungible: Disposable  {
    data class NonFungible(
        val `value`: NonFungibleGlobalId
        ) : ResourceOrNonFungible()
    data class Resource(
        val `value`: Address
        ) : ResourceOrNonFungible()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is ResourceOrNonFungible.NonFungible -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is ResourceOrNonFungible.Resource -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeResourceOrNonFungible : FfiConverterRustBuffer<ResourceOrNonFungible>{
    override fun read(buf: ByteBuffer): ResourceOrNonFungible {
        return when(buf.getInt()) {
            1 -> ResourceOrNonFungible.NonFungible(
                FfiConverterTypeNonFungibleGlobalId.read(buf),
                )
            2 -> ResourceOrNonFungible.Resource(
                FfiConverterTypeAddress.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ResourceOrNonFungible) = when(value) {
        is ResourceOrNonFungible.NonFungible -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeNonFungibleGlobalId.allocationSize(value.`value`)
            )
        }
        is ResourceOrNonFungible.Resource -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: ResourceOrNonFungible, buf: ByteBuffer) {
        when(value) {
            is ResourceOrNonFungible.NonFungible -> {
                buf.putInt(1)
                FfiConverterTypeNonFungibleGlobalId.write(value.`value`, buf)
                Unit
            }
            is ResourceOrNonFungible.Resource -> {
                buf.putInt(2)
                FfiConverterTypeAddress.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class ResourcePreference {
    ALLOWED,DISALLOWED;
}

public object FfiConverterTypeResourcePreference: FfiConverterRustBuffer<ResourcePreference> {
    override fun read(buf: ByteBuffer) = try {
        ResourcePreference.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ResourcePreference) = 4

    override fun write(value: ResourcePreference, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






sealed class ResourcePreferenceAction {
    data class Set(
        val `value`: ResourcePreference
        ) : ResourcePreferenceAction()
    object Remove : ResourcePreferenceAction()
    
    

    
}

public object FfiConverterTypeResourcePreferenceAction : FfiConverterRustBuffer<ResourcePreferenceAction>{
    override fun read(buf: ByteBuffer): ResourcePreferenceAction {
        return when(buf.getInt()) {
            1 -> ResourcePreferenceAction.Set(
                FfiConverterTypeResourcePreference.read(buf),
                )
            2 -> ResourcePreferenceAction.Remove
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ResourcePreferenceAction) = when(value) {
        is ResourcePreferenceAction.Set -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeResourcePreference.allocationSize(value.`value`)
            )
        }
        is ResourcePreferenceAction.Remove -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
    }

    override fun write(value: ResourcePreferenceAction, buf: ByteBuffer) {
        when(value) {
            is ResourcePreferenceAction.Set -> {
                buf.putInt(1)
                FfiConverterTypeResourcePreference.write(value.`value`, buf)
                Unit
            }
            is ResourcePreferenceAction.Remove -> {
                buf.putInt(2)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class ResourceSpecifier: Disposable  {
    data class Amount(
        val `resourceAddress`: Address, 
        val `amount`: Decimal
        ) : ResourceSpecifier()
    data class Ids(
        val `resourceAddress`: Address, 
        val `ids`: List<NonFungibleLocalId>
        ) : ResourceSpecifier()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is ResourceSpecifier.Amount -> {
                
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`amount`)
                
            }
            is ResourceSpecifier.Ids -> {
                
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`ids`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeResourceSpecifier : FfiConverterRustBuffer<ResourceSpecifier>{
    override fun read(buf: ByteBuffer): ResourceSpecifier {
        return when(buf.getInt()) {
            1 -> ResourceSpecifier.Amount(
                FfiConverterTypeAddress.read(buf),
                FfiConverterTypeDecimal.read(buf),
                )
            2 -> ResourceSpecifier.Ids(
                FfiConverterTypeAddress.read(buf),
                FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ResourceSpecifier) = when(value) {
        is ResourceSpecifier.Amount -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
                + FfiConverterTypeDecimal.allocationSize(value.`amount`)
            )
        }
        is ResourceSpecifier.Ids -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
                + FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`ids`)
            )
        }
    }

    override fun write(value: ResourceSpecifier, buf: ByteBuffer) {
        when(value) {
            is ResourceSpecifier.Amount -> {
                buf.putInt(1)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                FfiConverterTypeDecimal.write(value.`amount`, buf)
                Unit
            }
            is ResourceSpecifier.Ids -> {
                buf.putInt(2)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                FfiConverterSequenceTypeNonFungibleLocalId.write(value.`ids`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class ResourceTracker: Disposable  {
    data class Fungible(
        val `resourceAddress`: Address, 
        val `amount`: DecimalSource
        ) : ResourceTracker()
    data class NonFungible(
        val `resourceAddress`: Address, 
        val `amount`: DecimalSource, 
        val `ids`: NonFungibleLocalIdVecSource
        ) : ResourceTracker()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is ResourceTracker.Fungible -> {
                
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`amount`)
                
            }
            is ResourceTracker.NonFungible -> {
                
    Disposable.destroy(
        this.`resourceAddress`, 
        this.`amount`, 
        this.`ids`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeResourceTracker : FfiConverterRustBuffer<ResourceTracker>{
    override fun read(buf: ByteBuffer): ResourceTracker {
        return when(buf.getInt()) {
            1 -> ResourceTracker.Fungible(
                FfiConverterTypeAddress.read(buf),
                FfiConverterTypeDecimalSource.read(buf),
                )
            2 -> ResourceTracker.NonFungible(
                FfiConverterTypeAddress.read(buf),
                FfiConverterTypeDecimalSource.read(buf),
                FfiConverterTypeNonFungibleLocalIdVecSource.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ResourceTracker) = when(value) {
        is ResourceTracker.Fungible -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
                + FfiConverterTypeDecimalSource.allocationSize(value.`amount`)
            )
        }
        is ResourceTracker.NonFungible -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`resourceAddress`)
                + FfiConverterTypeDecimalSource.allocationSize(value.`amount`)
                + FfiConverterTypeNonFungibleLocalIdVecSource.allocationSize(value.`ids`)
            )
        }
    }

    override fun write(value: ResourceTracker, buf: ByteBuffer) {
        when(value) {
            is ResourceTracker.Fungible -> {
                buf.putInt(1)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                FfiConverterTypeDecimalSource.write(value.`amount`, buf)
                Unit
            }
            is ResourceTracker.NonFungible -> {
                buf.putInt(2)
                FfiConverterTypeAddress.write(value.`resourceAddress`, buf)
                FfiConverterTypeDecimalSource.write(value.`amount`, buf)
                FfiConverterTypeNonFungibleLocalIdVecSource.write(value.`ids`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class Resources: Disposable  {
    data class Amount(
        val `amount`: Decimal
        ) : Resources()
    data class Ids(
        val `ids`: List<NonFungibleLocalId>
        ) : Resources()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is Resources.Amount -> {
                
    Disposable.destroy(
        this.`amount`)
                
            }
            is Resources.Ids -> {
                
    Disposable.destroy(
        this.`ids`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeResources : FfiConverterRustBuffer<Resources>{
    override fun read(buf: ByteBuffer): Resources {
        return when(buf.getInt()) {
            1 -> Resources.Amount(
                FfiConverterTypeDecimal.read(buf),
                )
            2 -> Resources.Ids(
                FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: Resources) = when(value) {
        is Resources.Amount -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeDecimal.allocationSize(value.`amount`)
            )
        }
        is Resources.Ids -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`ids`)
            )
        }
    }

    override fun write(value: Resources, buf: ByteBuffer) {
        when(value) {
            is Resources.Amount -> {
                buf.putInt(1)
                FfiConverterTypeDecimal.write(value.`amount`, buf)
                Unit
            }
            is Resources.Ids -> {
                buf.putInt(2)
                FfiConverterSequenceTypeNonFungibleLocalId.write(value.`ids`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class Role {
    PRIMARY,RECOVERY,CONFIRMATION;
}

public object FfiConverterTypeRole: FfiConverterRustBuffer<Role> {
    override fun read(buf: ByteBuffer) = try {
        Role.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: Role) = 4

    override fun write(value: Role, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class RoundingMode {
    TO_POSITIVE_INFINITY,TO_NEGATIVE_INFINITY,TO_ZERO,AWAY_FROM_ZERO,TO_NEAREST_MIDPOINT_TOWARD_ZERO,TO_NEAREST_MIDPOINT_AWAY_FROM_ZERO,TO_NEAREST_MIDPOINT_TO_EVEN;
}

public object FfiConverterTypeRoundingMode: FfiConverterRustBuffer<RoundingMode> {
    override fun read(buf: ByteBuffer) = try {
        RoundingMode.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: RoundingMode) = 4

    override fun write(value: RoundingMode, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






sealed class ScryptoSborString {
    data class ProgrammaticJson(
        val `value`: String
        ) : ScryptoSborString()
    

    
}

public object FfiConverterTypeScryptoSborString : FfiConverterRustBuffer<ScryptoSborString>{
    override fun read(buf: ByteBuffer): ScryptoSborString {
        return when(buf.getInt()) {
            1 -> ScryptoSborString.ProgrammaticJson(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ScryptoSborString) = when(value) {
        is ScryptoSborString.ProgrammaticJson -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: ScryptoSborString, buf: ByteBuffer) {
        when(value) {
            is ScryptoSborString.ProgrammaticJson -> {
                buf.putInt(1)
                FfiConverterString.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






enum class SerializationMode {
    PROGRAMMATIC,NATURAL;
}

public object FfiConverterTypeSerializationMode: FfiConverterRustBuffer<SerializationMode> {
    override fun read(buf: ByteBuffer) = try {
        SerializationMode.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: SerializationMode) = 4

    override fun write(value: SerializationMode, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






sealed class Signature {
    data class Secp256k1(
        val `value`: List<UByte>
        ) : Signature()
    data class Ed25519(
        val `value`: List<UByte>
        ) : Signature()
    

    
}

public object FfiConverterTypeSignature : FfiConverterRustBuffer<Signature>{
    override fun read(buf: ByteBuffer): Signature {
        return when(buf.getInt()) {
            1 -> Signature.Secp256k1(
                FfiConverterSequenceUByte.read(buf),
                )
            2 -> Signature.Ed25519(
                FfiConverterSequenceUByte.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: Signature) = when(value) {
        is Signature.Secp256k1 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceUByte.allocationSize(value.`value`)
            )
        }
        is Signature.Ed25519 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceUByte.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: Signature, buf: ByteBuffer) {
        when(value) {
            is Signature.Secp256k1 -> {
                buf.putInt(1)
                FfiConverterSequenceUByte.write(value.`value`, buf)
                Unit
            }
            is Signature.Ed25519 -> {
                buf.putInt(2)
                FfiConverterSequenceUByte.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class SignatureWithPublicKey {
    data class Secp256k1(
        val `signature`: List<UByte>
        ) : SignatureWithPublicKey()
    data class Ed25519(
        val `signature`: List<UByte>, 
        val `publicKey`: List<UByte>
        ) : SignatureWithPublicKey()
    

    
}

public object FfiConverterTypeSignatureWithPublicKey : FfiConverterRustBuffer<SignatureWithPublicKey>{
    override fun read(buf: ByteBuffer): SignatureWithPublicKey {
        return when(buf.getInt()) {
            1 -> SignatureWithPublicKey.Secp256k1(
                FfiConverterSequenceUByte.read(buf),
                )
            2 -> SignatureWithPublicKey.Ed25519(
                FfiConverterSequenceUByte.read(buf),
                FfiConverterSequenceUByte.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SignatureWithPublicKey) = when(value) {
        is SignatureWithPublicKey.Secp256k1 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceUByte.allocationSize(value.`signature`)
            )
        }
        is SignatureWithPublicKey.Ed25519 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceUByte.allocationSize(value.`signature`)
                + FfiConverterSequenceUByte.allocationSize(value.`publicKey`)
            )
        }
    }

    override fun write(value: SignatureWithPublicKey, buf: ByteBuffer) {
        when(value) {
            is SignatureWithPublicKey.Secp256k1 -> {
                buf.putInt(1)
                FfiConverterSequenceUByte.write(value.`signature`, buf)
                Unit
            }
            is SignatureWithPublicKey.Ed25519 -> {
                buf.putInt(2)
                FfiConverterSequenceUByte.write(value.`signature`, buf)
                FfiConverterSequenceUByte.write(value.`publicKey`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TransactionType: Disposable  {
    data class SimpleTransfer(
        val `from`: Address, 
        val `to`: Address, 
        val `transferred`: ResourceSpecifier
        ) : TransactionType()
    data class Transfer(
        val `from`: Address, 
        val `transfers`: Map<String, Map<String, Resources>>
        ) : TransactionType()
    data class AccountDepositSettings(
        val `resourcePreferenceChanges`: Map<String, Map<String, ResourcePreferenceAction>>, 
        val `defaultDepositRuleChanges`: Map<String, AccountDefaultDepositRule>, 
        val `authorizedDepositorsChanges`: Map<String, AuthorizedDepositorsChanges>
        ) : TransactionType()
    data class StakeTransaction(
        val `stakes`: List<StakeInformation>
        ) : TransactionType()
    data class UnstakeTransaction(
        val `unstakes`: List<UnstakeInformation>
        ) : TransactionType()
    data class ClaimStakeTransaction(
        val `claims`: List<ClaimStakeInformation>
        ) : TransactionType()
    data class GeneralTransaction(
        val `accountProofs`: List<Address>, 
        val `accountWithdraws`: Map<String, List<ResourceTracker>>, 
        val `accountDeposits`: Map<String, List<ResourceTracker>>, 
        val `addressesInManifest`: Map<EntityType, List<Address>>, 
        val `metadataOfNewlyCreatedEntities`: Map<String, Map<String, MetadataValue?>>, 
        val `dataOfNewlyMintedNonFungibles`: Map<String, Map<NonFungibleLocalId, List<UByte>>>, 
        val `addressesOfNewlyCreatedEntities`: List<Address>
        ) : TransactionType()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TransactionType.SimpleTransfer -> {
                
    Disposable.destroy(
        this.`from`, 
        this.`to`, 
        this.`transferred`)
                
            }
            is TransactionType.Transfer -> {
                
    Disposable.destroy(
        this.`from`, 
        this.`transfers`)
                
            }
            is TransactionType.AccountDepositSettings -> {
                
    Disposable.destroy(
        this.`resourcePreferenceChanges`, 
        this.`defaultDepositRuleChanges`, 
        this.`authorizedDepositorsChanges`)
                
            }
            is TransactionType.StakeTransaction -> {
                
    Disposable.destroy(
        this.`stakes`)
                
            }
            is TransactionType.UnstakeTransaction -> {
                
    Disposable.destroy(
        this.`unstakes`)
                
            }
            is TransactionType.ClaimStakeTransaction -> {
                
    Disposable.destroy(
        this.`claims`)
                
            }
            is TransactionType.GeneralTransaction -> {
                
    Disposable.destroy(
        this.`accountProofs`, 
        this.`accountWithdraws`, 
        this.`accountDeposits`, 
        this.`addressesInManifest`, 
        this.`metadataOfNewlyCreatedEntities`, 
        this.`dataOfNewlyMintedNonFungibles`, 
        this.`addressesOfNewlyCreatedEntities`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTransactionType : FfiConverterRustBuffer<TransactionType>{
    override fun read(buf: ByteBuffer): TransactionType {
        return when(buf.getInt()) {
            1 -> TransactionType.SimpleTransfer(
                FfiConverterTypeAddress.read(buf),
                FfiConverterTypeAddress.read(buf),
                FfiConverterTypeResourceSpecifier.read(buf),
                )
            2 -> TransactionType.Transfer(
                FfiConverterTypeAddress.read(buf),
                FfiConverterMapStringMapStringTypeResources.read(buf),
                )
            3 -> TransactionType.AccountDepositSettings(
                FfiConverterMapStringMapStringTypeResourcePreferenceAction.read(buf),
                FfiConverterMapStringTypeAccountDefaultDepositRule.read(buf),
                FfiConverterMapStringTypeAuthorizedDepositorsChanges.read(buf),
                )
            4 -> TransactionType.StakeTransaction(
                FfiConverterSequenceTypeStakeInformation.read(buf),
                )
            5 -> TransactionType.UnstakeTransaction(
                FfiConverterSequenceTypeUnstakeInformation.read(buf),
                )
            6 -> TransactionType.ClaimStakeTransaction(
                FfiConverterSequenceTypeClaimStakeInformation.read(buf),
                )
            7 -> TransactionType.GeneralTransaction(
                FfiConverterSequenceTypeAddress.read(buf),
                FfiConverterMapStringSequenceTypeResourceTracker.read(buf),
                FfiConverterMapStringSequenceTypeResourceTracker.read(buf),
                FfiConverterMapTypeEntityTypeSequenceTypeAddress.read(buf),
                FfiConverterMapStringMapStringOptionalTypeMetadataValue.read(buf),
                FfiConverterMapStringMapTypeNonFungibleLocalIdSequenceUByte.read(buf),
                FfiConverterSequenceTypeAddress.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TransactionType) = when(value) {
        is TransactionType.SimpleTransfer -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`from`)
                + FfiConverterTypeAddress.allocationSize(value.`to`)
                + FfiConverterTypeResourceSpecifier.allocationSize(value.`transferred`)
            )
        }
        is TransactionType.Transfer -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAddress.allocationSize(value.`from`)
                + FfiConverterMapStringMapStringTypeResources.allocationSize(value.`transfers`)
            )
        }
        is TransactionType.AccountDepositSettings -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterMapStringMapStringTypeResourcePreferenceAction.allocationSize(value.`resourcePreferenceChanges`)
                + FfiConverterMapStringTypeAccountDefaultDepositRule.allocationSize(value.`defaultDepositRuleChanges`)
                + FfiConverterMapStringTypeAuthorizedDepositorsChanges.allocationSize(value.`authorizedDepositorsChanges`)
            )
        }
        is TransactionType.StakeTransaction -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceTypeStakeInformation.allocationSize(value.`stakes`)
            )
        }
        is TransactionType.UnstakeTransaction -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceTypeUnstakeInformation.allocationSize(value.`unstakes`)
            )
        }
        is TransactionType.ClaimStakeTransaction -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceTypeClaimStakeInformation.allocationSize(value.`claims`)
            )
        }
        is TransactionType.GeneralTransaction -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceTypeAddress.allocationSize(value.`accountProofs`)
                + FfiConverterMapStringSequenceTypeResourceTracker.allocationSize(value.`accountWithdraws`)
                + FfiConverterMapStringSequenceTypeResourceTracker.allocationSize(value.`accountDeposits`)
                + FfiConverterMapTypeEntityTypeSequenceTypeAddress.allocationSize(value.`addressesInManifest`)
                + FfiConverterMapStringMapStringOptionalTypeMetadataValue.allocationSize(value.`metadataOfNewlyCreatedEntities`)
                + FfiConverterMapStringMapTypeNonFungibleLocalIdSequenceUByte.allocationSize(value.`dataOfNewlyMintedNonFungibles`)
                + FfiConverterSequenceTypeAddress.allocationSize(value.`addressesOfNewlyCreatedEntities`)
            )
        }
    }

    override fun write(value: TransactionType, buf: ByteBuffer) {
        when(value) {
            is TransactionType.SimpleTransfer -> {
                buf.putInt(1)
                FfiConverterTypeAddress.write(value.`from`, buf)
                FfiConverterTypeAddress.write(value.`to`, buf)
                FfiConverterTypeResourceSpecifier.write(value.`transferred`, buf)
                Unit
            }
            is TransactionType.Transfer -> {
                buf.putInt(2)
                FfiConverterTypeAddress.write(value.`from`, buf)
                FfiConverterMapStringMapStringTypeResources.write(value.`transfers`, buf)
                Unit
            }
            is TransactionType.AccountDepositSettings -> {
                buf.putInt(3)
                FfiConverterMapStringMapStringTypeResourcePreferenceAction.write(value.`resourcePreferenceChanges`, buf)
                FfiConverterMapStringTypeAccountDefaultDepositRule.write(value.`defaultDepositRuleChanges`, buf)
                FfiConverterMapStringTypeAuthorizedDepositorsChanges.write(value.`authorizedDepositorsChanges`, buf)
                Unit
            }
            is TransactionType.StakeTransaction -> {
                buf.putInt(4)
                FfiConverterSequenceTypeStakeInformation.write(value.`stakes`, buf)
                Unit
            }
            is TransactionType.UnstakeTransaction -> {
                buf.putInt(5)
                FfiConverterSequenceTypeUnstakeInformation.write(value.`unstakes`, buf)
                Unit
            }
            is TransactionType.ClaimStakeTransaction -> {
                buf.putInt(6)
                FfiConverterSequenceTypeClaimStakeInformation.write(value.`claims`, buf)
                Unit
            }
            is TransactionType.GeneralTransaction -> {
                buf.putInt(7)
                FfiConverterSequenceTypeAddress.write(value.`accountProofs`, buf)
                FfiConverterMapStringSequenceTypeResourceTracker.write(value.`accountWithdraws`, buf)
                FfiConverterMapStringSequenceTypeResourceTracker.write(value.`accountDeposits`, buf)
                FfiConverterMapTypeEntityTypeSequenceTypeAddress.write(value.`addressesInManifest`, buf)
                FfiConverterMapStringMapStringOptionalTypeMetadataValue.write(value.`metadataOfNewlyCreatedEntities`, buf)
                FfiConverterMapStringMapTypeNonFungibleLocalIdSequenceUByte.write(value.`dataOfNewlyMintedNonFungibles`, buf)
                FfiConverterSequenceTypeAddress.write(value.`addressesOfNewlyCreatedEntities`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedAccessControllerBlueprintEvent: Disposable  {
    data class InitiateRecoveryEventValue(
        val `value`: InitiateRecoveryEvent
        ) : TypedAccessControllerBlueprintEvent()
    data class InitiateBadgeWithdrawAttemptEventValue(
        val `value`: InitiateBadgeWithdrawAttemptEvent
        ) : TypedAccessControllerBlueprintEvent()
    data class RuleSetUpdateEventValue(
        val `value`: RuleSetUpdateEvent
        ) : TypedAccessControllerBlueprintEvent()
    data class BadgeWithdrawEventValue(
        val `value`: BadgeWithdrawEvent
        ) : TypedAccessControllerBlueprintEvent()
    data class CancelRecoveryProposalEventValue(
        val `value`: CancelRecoveryProposalEvent
        ) : TypedAccessControllerBlueprintEvent()
    data class CancelBadgeWithdrawAttemptEventValue(
        val `value`: CancelBadgeWithdrawAttemptEvent
        ) : TypedAccessControllerBlueprintEvent()
    data class LockPrimaryRoleEventValue(
        val `value`: LockPrimaryRoleEvent
        ) : TypedAccessControllerBlueprintEvent()
    data class UnlockPrimaryRoleEventValue(
        val `value`: UnlockPrimaryRoleEvent
        ) : TypedAccessControllerBlueprintEvent()
    data class StopTimedRecoveryEventValue(
        val `value`: StopTimedRecoveryEvent
        ) : TypedAccessControllerBlueprintEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TypedAccessControllerBlueprintEvent.InitiateRecoveryEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedAccessControllerBlueprintEvent.InitiateBadgeWithdrawAttemptEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedAccessControllerBlueprintEvent.RuleSetUpdateEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedAccessControllerBlueprintEvent.BadgeWithdrawEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedAccessControllerBlueprintEvent.CancelRecoveryProposalEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedAccessControllerBlueprintEvent.CancelBadgeWithdrawAttemptEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedAccessControllerBlueprintEvent.LockPrimaryRoleEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedAccessControllerBlueprintEvent.UnlockPrimaryRoleEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedAccessControllerBlueprintEvent.StopTimedRecoveryEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTypedAccessControllerBlueprintEvent : FfiConverterRustBuffer<TypedAccessControllerBlueprintEvent>{
    override fun read(buf: ByteBuffer): TypedAccessControllerBlueprintEvent {
        return when(buf.getInt()) {
            1 -> TypedAccessControllerBlueprintEvent.InitiateRecoveryEventValue(
                FfiConverterTypeInitiateRecoveryEvent.read(buf),
                )
            2 -> TypedAccessControllerBlueprintEvent.InitiateBadgeWithdrawAttemptEventValue(
                FfiConverterTypeInitiateBadgeWithdrawAttemptEvent.read(buf),
                )
            3 -> TypedAccessControllerBlueprintEvent.RuleSetUpdateEventValue(
                FfiConverterTypeRuleSetUpdateEvent.read(buf),
                )
            4 -> TypedAccessControllerBlueprintEvent.BadgeWithdrawEventValue(
                FfiConverterTypeBadgeWithdrawEvent.read(buf),
                )
            5 -> TypedAccessControllerBlueprintEvent.CancelRecoveryProposalEventValue(
                FfiConverterTypeCancelRecoveryProposalEvent.read(buf),
                )
            6 -> TypedAccessControllerBlueprintEvent.CancelBadgeWithdrawAttemptEventValue(
                FfiConverterTypeCancelBadgeWithdrawAttemptEvent.read(buf),
                )
            7 -> TypedAccessControllerBlueprintEvent.LockPrimaryRoleEventValue(
                FfiConverterTypeLockPrimaryRoleEvent.read(buf),
                )
            8 -> TypedAccessControllerBlueprintEvent.UnlockPrimaryRoleEventValue(
                FfiConverterTypeUnlockPrimaryRoleEvent.read(buf),
                )
            9 -> TypedAccessControllerBlueprintEvent.StopTimedRecoveryEventValue(
                FfiConverterTypeStopTimedRecoveryEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedAccessControllerBlueprintEvent) = when(value) {
        is TypedAccessControllerBlueprintEvent.InitiateRecoveryEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeInitiateRecoveryEvent.allocationSize(value.`value`)
            )
        }
        is TypedAccessControllerBlueprintEvent.InitiateBadgeWithdrawAttemptEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeInitiateBadgeWithdrawAttemptEvent.allocationSize(value.`value`)
            )
        }
        is TypedAccessControllerBlueprintEvent.RuleSetUpdateEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeRuleSetUpdateEvent.allocationSize(value.`value`)
            )
        }
        is TypedAccessControllerBlueprintEvent.BadgeWithdrawEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeBadgeWithdrawEvent.allocationSize(value.`value`)
            )
        }
        is TypedAccessControllerBlueprintEvent.CancelRecoveryProposalEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeCancelRecoveryProposalEvent.allocationSize(value.`value`)
            )
        }
        is TypedAccessControllerBlueprintEvent.CancelBadgeWithdrawAttemptEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeCancelBadgeWithdrawAttemptEvent.allocationSize(value.`value`)
            )
        }
        is TypedAccessControllerBlueprintEvent.LockPrimaryRoleEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeLockPrimaryRoleEvent.allocationSize(value.`value`)
            )
        }
        is TypedAccessControllerBlueprintEvent.UnlockPrimaryRoleEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeUnlockPrimaryRoleEvent.allocationSize(value.`value`)
            )
        }
        is TypedAccessControllerBlueprintEvent.StopTimedRecoveryEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeStopTimedRecoveryEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedAccessControllerBlueprintEvent, buf: ByteBuffer) {
        when(value) {
            is TypedAccessControllerBlueprintEvent.InitiateRecoveryEventValue -> {
                buf.putInt(1)
                FfiConverterTypeInitiateRecoveryEvent.write(value.`value`, buf)
                Unit
            }
            is TypedAccessControllerBlueprintEvent.InitiateBadgeWithdrawAttemptEventValue -> {
                buf.putInt(2)
                FfiConverterTypeInitiateBadgeWithdrawAttemptEvent.write(value.`value`, buf)
                Unit
            }
            is TypedAccessControllerBlueprintEvent.RuleSetUpdateEventValue -> {
                buf.putInt(3)
                FfiConverterTypeRuleSetUpdateEvent.write(value.`value`, buf)
                Unit
            }
            is TypedAccessControllerBlueprintEvent.BadgeWithdrawEventValue -> {
                buf.putInt(4)
                FfiConverterTypeBadgeWithdrawEvent.write(value.`value`, buf)
                Unit
            }
            is TypedAccessControllerBlueprintEvent.CancelRecoveryProposalEventValue -> {
                buf.putInt(5)
                FfiConverterTypeCancelRecoveryProposalEvent.write(value.`value`, buf)
                Unit
            }
            is TypedAccessControllerBlueprintEvent.CancelBadgeWithdrawAttemptEventValue -> {
                buf.putInt(6)
                FfiConverterTypeCancelBadgeWithdrawAttemptEvent.write(value.`value`, buf)
                Unit
            }
            is TypedAccessControllerBlueprintEvent.LockPrimaryRoleEventValue -> {
                buf.putInt(7)
                FfiConverterTypeLockPrimaryRoleEvent.write(value.`value`, buf)
                Unit
            }
            is TypedAccessControllerBlueprintEvent.UnlockPrimaryRoleEventValue -> {
                buf.putInt(8)
                FfiConverterTypeUnlockPrimaryRoleEvent.write(value.`value`, buf)
                Unit
            }
            is TypedAccessControllerBlueprintEvent.StopTimedRecoveryEventValue -> {
                buf.putInt(9)
                FfiConverterTypeStopTimedRecoveryEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedAccessControllerPackageEvent: Disposable  {
    data class AccessController(
        val `value`: TypedAccessControllerBlueprintEvent
        ) : TypedAccessControllerPackageEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TypedAccessControllerPackageEvent.AccessController -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTypedAccessControllerPackageEvent : FfiConverterRustBuffer<TypedAccessControllerPackageEvent>{
    override fun read(buf: ByteBuffer): TypedAccessControllerPackageEvent {
        return when(buf.getInt()) {
            1 -> TypedAccessControllerPackageEvent.AccessController(
                FfiConverterTypeTypedAccessControllerBlueprintEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedAccessControllerPackageEvent) = when(value) {
        is TypedAccessControllerPackageEvent.AccessController -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTypedAccessControllerBlueprintEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedAccessControllerPackageEvent, buf: ByteBuffer) {
        when(value) {
            is TypedAccessControllerPackageEvent.AccessController -> {
                buf.putInt(1)
                FfiConverterTypeTypedAccessControllerBlueprintEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedAccountBlueprintEvent: Disposable  {
    data class AccountWithdrawEventValue(
        val `value`: AccountWithdrawEvent
        ) : TypedAccountBlueprintEvent()
    data class AccountDepositEventValue(
        val `value`: AccountDepositEvent
        ) : TypedAccountBlueprintEvent()
    data class AccountRejectedDepositEventValue(
        val `value`: AccountRejectedDepositEvent
        ) : TypedAccountBlueprintEvent()
    data class AccountSetResourcePreferenceEventValue(
        val `value`: AccountSetResourcePreferenceEvent
        ) : TypedAccountBlueprintEvent()
    data class AccountRemoveResourcePreferenceEventValue(
        val `value`: AccountRemoveResourcePreferenceEvent
        ) : TypedAccountBlueprintEvent()
    data class AccountSetDefaultDepositRuleEventValue(
        val `value`: AccountSetDefaultDepositRuleEvent
        ) : TypedAccountBlueprintEvent()
    data class AccountAddAuthorizedDepositorEventValue(
        val `value`: AccountAddAuthorizedDepositorEvent
        ) : TypedAccountBlueprintEvent()
    data class AccountRemoveAuthorizedDepositorEventValue(
        val `value`: AccountRemoveAuthorizedDepositorEvent
        ) : TypedAccountBlueprintEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TypedAccountBlueprintEvent.AccountWithdrawEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedAccountBlueprintEvent.AccountDepositEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedAccountBlueprintEvent.AccountRejectedDepositEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedAccountBlueprintEvent.AccountSetResourcePreferenceEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedAccountBlueprintEvent.AccountRemoveResourcePreferenceEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedAccountBlueprintEvent.AccountSetDefaultDepositRuleEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedAccountBlueprintEvent.AccountAddAuthorizedDepositorEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedAccountBlueprintEvent.AccountRemoveAuthorizedDepositorEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTypedAccountBlueprintEvent : FfiConverterRustBuffer<TypedAccountBlueprintEvent>{
    override fun read(buf: ByteBuffer): TypedAccountBlueprintEvent {
        return when(buf.getInt()) {
            1 -> TypedAccountBlueprintEvent.AccountWithdrawEventValue(
                FfiConverterTypeAccountWithdrawEvent.read(buf),
                )
            2 -> TypedAccountBlueprintEvent.AccountDepositEventValue(
                FfiConverterTypeAccountDepositEvent.read(buf),
                )
            3 -> TypedAccountBlueprintEvent.AccountRejectedDepositEventValue(
                FfiConverterTypeAccountRejectedDepositEvent.read(buf),
                )
            4 -> TypedAccountBlueprintEvent.AccountSetResourcePreferenceEventValue(
                FfiConverterTypeAccountSetResourcePreferenceEvent.read(buf),
                )
            5 -> TypedAccountBlueprintEvent.AccountRemoveResourcePreferenceEventValue(
                FfiConverterTypeAccountRemoveResourcePreferenceEvent.read(buf),
                )
            6 -> TypedAccountBlueprintEvent.AccountSetDefaultDepositRuleEventValue(
                FfiConverterTypeAccountSetDefaultDepositRuleEvent.read(buf),
                )
            7 -> TypedAccountBlueprintEvent.AccountAddAuthorizedDepositorEventValue(
                FfiConverterTypeAccountAddAuthorizedDepositorEvent.read(buf),
                )
            8 -> TypedAccountBlueprintEvent.AccountRemoveAuthorizedDepositorEventValue(
                FfiConverterTypeAccountRemoveAuthorizedDepositorEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedAccountBlueprintEvent) = when(value) {
        is TypedAccountBlueprintEvent.AccountWithdrawEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAccountWithdrawEvent.allocationSize(value.`value`)
            )
        }
        is TypedAccountBlueprintEvent.AccountDepositEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAccountDepositEvent.allocationSize(value.`value`)
            )
        }
        is TypedAccountBlueprintEvent.AccountRejectedDepositEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAccountRejectedDepositEvent.allocationSize(value.`value`)
            )
        }
        is TypedAccountBlueprintEvent.AccountSetResourcePreferenceEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAccountSetResourcePreferenceEvent.allocationSize(value.`value`)
            )
        }
        is TypedAccountBlueprintEvent.AccountRemoveResourcePreferenceEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAccountRemoveResourcePreferenceEvent.allocationSize(value.`value`)
            )
        }
        is TypedAccountBlueprintEvent.AccountSetDefaultDepositRuleEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAccountSetDefaultDepositRuleEvent.allocationSize(value.`value`)
            )
        }
        is TypedAccountBlueprintEvent.AccountAddAuthorizedDepositorEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAccountAddAuthorizedDepositorEvent.allocationSize(value.`value`)
            )
        }
        is TypedAccountBlueprintEvent.AccountRemoveAuthorizedDepositorEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeAccountRemoveAuthorizedDepositorEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedAccountBlueprintEvent, buf: ByteBuffer) {
        when(value) {
            is TypedAccountBlueprintEvent.AccountWithdrawEventValue -> {
                buf.putInt(1)
                FfiConverterTypeAccountWithdrawEvent.write(value.`value`, buf)
                Unit
            }
            is TypedAccountBlueprintEvent.AccountDepositEventValue -> {
                buf.putInt(2)
                FfiConverterTypeAccountDepositEvent.write(value.`value`, buf)
                Unit
            }
            is TypedAccountBlueprintEvent.AccountRejectedDepositEventValue -> {
                buf.putInt(3)
                FfiConverterTypeAccountRejectedDepositEvent.write(value.`value`, buf)
                Unit
            }
            is TypedAccountBlueprintEvent.AccountSetResourcePreferenceEventValue -> {
                buf.putInt(4)
                FfiConverterTypeAccountSetResourcePreferenceEvent.write(value.`value`, buf)
                Unit
            }
            is TypedAccountBlueprintEvent.AccountRemoveResourcePreferenceEventValue -> {
                buf.putInt(5)
                FfiConverterTypeAccountRemoveResourcePreferenceEvent.write(value.`value`, buf)
                Unit
            }
            is TypedAccountBlueprintEvent.AccountSetDefaultDepositRuleEventValue -> {
                buf.putInt(6)
                FfiConverterTypeAccountSetDefaultDepositRuleEvent.write(value.`value`, buf)
                Unit
            }
            is TypedAccountBlueprintEvent.AccountAddAuthorizedDepositorEventValue -> {
                buf.putInt(7)
                FfiConverterTypeAccountAddAuthorizedDepositorEvent.write(value.`value`, buf)
                Unit
            }
            is TypedAccountBlueprintEvent.AccountRemoveAuthorizedDepositorEventValue -> {
                buf.putInt(8)
                FfiConverterTypeAccountRemoveAuthorizedDepositorEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedAccountPackageEvent: Disposable  {
    data class Account(
        val `value`: TypedAccountBlueprintEvent
        ) : TypedAccountPackageEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TypedAccountPackageEvent.Account -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTypedAccountPackageEvent : FfiConverterRustBuffer<TypedAccountPackageEvent>{
    override fun read(buf: ByteBuffer): TypedAccountPackageEvent {
        return when(buf.getInt()) {
            1 -> TypedAccountPackageEvent.Account(
                FfiConverterTypeTypedAccountBlueprintEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedAccountPackageEvent) = when(value) {
        is TypedAccountPackageEvent.Account -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTypedAccountBlueprintEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedAccountPackageEvent, buf: ByteBuffer) {
        when(value) {
            is TypedAccountPackageEvent.Account -> {
                buf.putInt(1)
                FfiConverterTypeTypedAccountBlueprintEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedConsensusManagerBlueprintEvent: Disposable  {
    data class RoundChangeEventValue(
        val `value`: RoundChangeEvent
        ) : TypedConsensusManagerBlueprintEvent()
    data class EpochChangeEventValue(
        val `value`: EpochChangeEvent
        ) : TypedConsensusManagerBlueprintEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TypedConsensusManagerBlueprintEvent.RoundChangeEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedConsensusManagerBlueprintEvent.EpochChangeEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTypedConsensusManagerBlueprintEvent : FfiConverterRustBuffer<TypedConsensusManagerBlueprintEvent>{
    override fun read(buf: ByteBuffer): TypedConsensusManagerBlueprintEvent {
        return when(buf.getInt()) {
            1 -> TypedConsensusManagerBlueprintEvent.RoundChangeEventValue(
                FfiConverterTypeRoundChangeEvent.read(buf),
                )
            2 -> TypedConsensusManagerBlueprintEvent.EpochChangeEventValue(
                FfiConverterTypeEpochChangeEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedConsensusManagerBlueprintEvent) = when(value) {
        is TypedConsensusManagerBlueprintEvent.RoundChangeEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeRoundChangeEvent.allocationSize(value.`value`)
            )
        }
        is TypedConsensusManagerBlueprintEvent.EpochChangeEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeEpochChangeEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedConsensusManagerBlueprintEvent, buf: ByteBuffer) {
        when(value) {
            is TypedConsensusManagerBlueprintEvent.RoundChangeEventValue -> {
                buf.putInt(1)
                FfiConverterTypeRoundChangeEvent.write(value.`value`, buf)
                Unit
            }
            is TypedConsensusManagerBlueprintEvent.EpochChangeEventValue -> {
                buf.putInt(2)
                FfiConverterTypeEpochChangeEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedConsensusManagerPackageEvent: Disposable  {
    data class ConsensusManager(
        val `value`: TypedConsensusManagerBlueprintEvent
        ) : TypedConsensusManagerPackageEvent()
    data class Validator(
        val `value`: TypedValidatorBlueprintEvent
        ) : TypedConsensusManagerPackageEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TypedConsensusManagerPackageEvent.ConsensusManager -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedConsensusManagerPackageEvent.Validator -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTypedConsensusManagerPackageEvent : FfiConverterRustBuffer<TypedConsensusManagerPackageEvent>{
    override fun read(buf: ByteBuffer): TypedConsensusManagerPackageEvent {
        return when(buf.getInt()) {
            1 -> TypedConsensusManagerPackageEvent.ConsensusManager(
                FfiConverterTypeTypedConsensusManagerBlueprintEvent.read(buf),
                )
            2 -> TypedConsensusManagerPackageEvent.Validator(
                FfiConverterTypeTypedValidatorBlueprintEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedConsensusManagerPackageEvent) = when(value) {
        is TypedConsensusManagerPackageEvent.ConsensusManager -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTypedConsensusManagerBlueprintEvent.allocationSize(value.`value`)
            )
        }
        is TypedConsensusManagerPackageEvent.Validator -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTypedValidatorBlueprintEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedConsensusManagerPackageEvent, buf: ByteBuffer) {
        when(value) {
            is TypedConsensusManagerPackageEvent.ConsensusManager -> {
                buf.putInt(1)
                FfiConverterTypeTypedConsensusManagerBlueprintEvent.write(value.`value`, buf)
                Unit
            }
            is TypedConsensusManagerPackageEvent.Validator -> {
                buf.putInt(2)
                FfiConverterTypeTypedValidatorBlueprintEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedFungibleResourceManagerBlueprintEvent: Disposable  {
    data class VaultCreationEventValue(
        val `value`: VaultCreationEvent
        ) : TypedFungibleResourceManagerBlueprintEvent()
    data class MintFungibleResourceEventValue(
        val `value`: MintFungibleResourceEvent
        ) : TypedFungibleResourceManagerBlueprintEvent()
    data class BurnFungibleResourceEventValue(
        val `value`: BurnFungibleResourceEvent
        ) : TypedFungibleResourceManagerBlueprintEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TypedFungibleResourceManagerBlueprintEvent.VaultCreationEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedFungibleResourceManagerBlueprintEvent.MintFungibleResourceEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedFungibleResourceManagerBlueprintEvent.BurnFungibleResourceEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTypedFungibleResourceManagerBlueprintEvent : FfiConverterRustBuffer<TypedFungibleResourceManagerBlueprintEvent>{
    override fun read(buf: ByteBuffer): TypedFungibleResourceManagerBlueprintEvent {
        return when(buf.getInt()) {
            1 -> TypedFungibleResourceManagerBlueprintEvent.VaultCreationEventValue(
                FfiConverterTypeVaultCreationEvent.read(buf),
                )
            2 -> TypedFungibleResourceManagerBlueprintEvent.MintFungibleResourceEventValue(
                FfiConverterTypeMintFungibleResourceEvent.read(buf),
                )
            3 -> TypedFungibleResourceManagerBlueprintEvent.BurnFungibleResourceEventValue(
                FfiConverterTypeBurnFungibleResourceEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedFungibleResourceManagerBlueprintEvent) = when(value) {
        is TypedFungibleResourceManagerBlueprintEvent.VaultCreationEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeVaultCreationEvent.allocationSize(value.`value`)
            )
        }
        is TypedFungibleResourceManagerBlueprintEvent.MintFungibleResourceEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeMintFungibleResourceEvent.allocationSize(value.`value`)
            )
        }
        is TypedFungibleResourceManagerBlueprintEvent.BurnFungibleResourceEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeBurnFungibleResourceEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedFungibleResourceManagerBlueprintEvent, buf: ByteBuffer) {
        when(value) {
            is TypedFungibleResourceManagerBlueprintEvent.VaultCreationEventValue -> {
                buf.putInt(1)
                FfiConverterTypeVaultCreationEvent.write(value.`value`, buf)
                Unit
            }
            is TypedFungibleResourceManagerBlueprintEvent.MintFungibleResourceEventValue -> {
                buf.putInt(2)
                FfiConverterTypeMintFungibleResourceEvent.write(value.`value`, buf)
                Unit
            }
            is TypedFungibleResourceManagerBlueprintEvent.BurnFungibleResourceEventValue -> {
                buf.putInt(3)
                FfiConverterTypeBurnFungibleResourceEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedFungibleVaultBlueprintEvent: Disposable  {
    data class FungibleVaultLockFeeEventValue(
        val `value`: FungibleVaultLockFeeEvent
        ) : TypedFungibleVaultBlueprintEvent()
    data class FungibleVaultWithdrawEventValue(
        val `value`: FungibleVaultWithdrawEvent
        ) : TypedFungibleVaultBlueprintEvent()
    data class FungibleVaultDepositEventValue(
        val `value`: FungibleVaultDepositEvent
        ) : TypedFungibleVaultBlueprintEvent()
    data class FungibleVaultRecallEventValue(
        val `value`: FungibleVaultRecallEvent
        ) : TypedFungibleVaultBlueprintEvent()
    data class FungibleVaultPayFeeEventValue(
        val `value`: FungibleVaultPayFeeEvent
        ) : TypedFungibleVaultBlueprintEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TypedFungibleVaultBlueprintEvent.FungibleVaultLockFeeEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedFungibleVaultBlueprintEvent.FungibleVaultWithdrawEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedFungibleVaultBlueprintEvent.FungibleVaultDepositEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedFungibleVaultBlueprintEvent.FungibleVaultRecallEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedFungibleVaultBlueprintEvent.FungibleVaultPayFeeEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTypedFungibleVaultBlueprintEvent : FfiConverterRustBuffer<TypedFungibleVaultBlueprintEvent>{
    override fun read(buf: ByteBuffer): TypedFungibleVaultBlueprintEvent {
        return when(buf.getInt()) {
            1 -> TypedFungibleVaultBlueprintEvent.FungibleVaultLockFeeEventValue(
                FfiConverterTypeFungibleVaultLockFeeEvent.read(buf),
                )
            2 -> TypedFungibleVaultBlueprintEvent.FungibleVaultWithdrawEventValue(
                FfiConverterTypeFungibleVaultWithdrawEvent.read(buf),
                )
            3 -> TypedFungibleVaultBlueprintEvent.FungibleVaultDepositEventValue(
                FfiConverterTypeFungibleVaultDepositEvent.read(buf),
                )
            4 -> TypedFungibleVaultBlueprintEvent.FungibleVaultRecallEventValue(
                FfiConverterTypeFungibleVaultRecallEvent.read(buf),
                )
            5 -> TypedFungibleVaultBlueprintEvent.FungibleVaultPayFeeEventValue(
                FfiConverterTypeFungibleVaultPayFeeEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedFungibleVaultBlueprintEvent) = when(value) {
        is TypedFungibleVaultBlueprintEvent.FungibleVaultLockFeeEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeFungibleVaultLockFeeEvent.allocationSize(value.`value`)
            )
        }
        is TypedFungibleVaultBlueprintEvent.FungibleVaultWithdrawEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeFungibleVaultWithdrawEvent.allocationSize(value.`value`)
            )
        }
        is TypedFungibleVaultBlueprintEvent.FungibleVaultDepositEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeFungibleVaultDepositEvent.allocationSize(value.`value`)
            )
        }
        is TypedFungibleVaultBlueprintEvent.FungibleVaultRecallEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeFungibleVaultRecallEvent.allocationSize(value.`value`)
            )
        }
        is TypedFungibleVaultBlueprintEvent.FungibleVaultPayFeeEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeFungibleVaultPayFeeEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedFungibleVaultBlueprintEvent, buf: ByteBuffer) {
        when(value) {
            is TypedFungibleVaultBlueprintEvent.FungibleVaultLockFeeEventValue -> {
                buf.putInt(1)
                FfiConverterTypeFungibleVaultLockFeeEvent.write(value.`value`, buf)
                Unit
            }
            is TypedFungibleVaultBlueprintEvent.FungibleVaultWithdrawEventValue -> {
                buf.putInt(2)
                FfiConverterTypeFungibleVaultWithdrawEvent.write(value.`value`, buf)
                Unit
            }
            is TypedFungibleVaultBlueprintEvent.FungibleVaultDepositEventValue -> {
                buf.putInt(3)
                FfiConverterTypeFungibleVaultDepositEvent.write(value.`value`, buf)
                Unit
            }
            is TypedFungibleVaultBlueprintEvent.FungibleVaultRecallEventValue -> {
                buf.putInt(4)
                FfiConverterTypeFungibleVaultRecallEvent.write(value.`value`, buf)
                Unit
            }
            is TypedFungibleVaultBlueprintEvent.FungibleVaultPayFeeEventValue -> {
                buf.putInt(5)
                FfiConverterTypeFungibleVaultPayFeeEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedMetadataBlueprintEvent: Disposable  {
    data class SetMetadataEventValue(
        val `value`: SetMetadataEvent
        ) : TypedMetadataBlueprintEvent()
    data class RemoveMetadataEventValue(
        val `value`: RemoveMetadataEvent
        ) : TypedMetadataBlueprintEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TypedMetadataBlueprintEvent.SetMetadataEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedMetadataBlueprintEvent.RemoveMetadataEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTypedMetadataBlueprintEvent : FfiConverterRustBuffer<TypedMetadataBlueprintEvent>{
    override fun read(buf: ByteBuffer): TypedMetadataBlueprintEvent {
        return when(buf.getInt()) {
            1 -> TypedMetadataBlueprintEvent.SetMetadataEventValue(
                FfiConverterTypeSetMetadataEvent.read(buf),
                )
            2 -> TypedMetadataBlueprintEvent.RemoveMetadataEventValue(
                FfiConverterTypeRemoveMetadataEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedMetadataBlueprintEvent) = when(value) {
        is TypedMetadataBlueprintEvent.SetMetadataEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeSetMetadataEvent.allocationSize(value.`value`)
            )
        }
        is TypedMetadataBlueprintEvent.RemoveMetadataEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeRemoveMetadataEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedMetadataBlueprintEvent, buf: ByteBuffer) {
        when(value) {
            is TypedMetadataBlueprintEvent.SetMetadataEventValue -> {
                buf.putInt(1)
                FfiConverterTypeSetMetadataEvent.write(value.`value`, buf)
                Unit
            }
            is TypedMetadataBlueprintEvent.RemoveMetadataEventValue -> {
                buf.putInt(2)
                FfiConverterTypeRemoveMetadataEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedMetadataPackageEvent: Disposable  {
    data class Metadata(
        val `value`: TypedMetadataBlueprintEvent
        ) : TypedMetadataPackageEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TypedMetadataPackageEvent.Metadata -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTypedMetadataPackageEvent : FfiConverterRustBuffer<TypedMetadataPackageEvent>{
    override fun read(buf: ByteBuffer): TypedMetadataPackageEvent {
        return when(buf.getInt()) {
            1 -> TypedMetadataPackageEvent.Metadata(
                FfiConverterTypeTypedMetadataBlueprintEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedMetadataPackageEvent) = when(value) {
        is TypedMetadataPackageEvent.Metadata -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTypedMetadataBlueprintEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedMetadataPackageEvent, buf: ByteBuffer) {
        when(value) {
            is TypedMetadataPackageEvent.Metadata -> {
                buf.putInt(1)
                FfiConverterTypeTypedMetadataBlueprintEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedMultiResourcePoolBlueprintEvent: Disposable  {
    data class MultiResourcePoolContributionEventValue(
        val `value`: MultiResourcePoolContributionEvent
        ) : TypedMultiResourcePoolBlueprintEvent()
    data class MultiResourcePoolRedemptionEventValue(
        val `value`: MultiResourcePoolRedemptionEvent
        ) : TypedMultiResourcePoolBlueprintEvent()
    data class MultiResourcePoolWithdrawEventValue(
        val `value`: MultiResourcePoolWithdrawEvent
        ) : TypedMultiResourcePoolBlueprintEvent()
    data class MultiResourcePoolDepositEventValue(
        val `value`: MultiResourcePoolDepositEvent
        ) : TypedMultiResourcePoolBlueprintEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TypedMultiResourcePoolBlueprintEvent.MultiResourcePoolContributionEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedMultiResourcePoolBlueprintEvent.MultiResourcePoolRedemptionEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedMultiResourcePoolBlueprintEvent.MultiResourcePoolWithdrawEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedMultiResourcePoolBlueprintEvent.MultiResourcePoolDepositEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTypedMultiResourcePoolBlueprintEvent : FfiConverterRustBuffer<TypedMultiResourcePoolBlueprintEvent>{
    override fun read(buf: ByteBuffer): TypedMultiResourcePoolBlueprintEvent {
        return when(buf.getInt()) {
            1 -> TypedMultiResourcePoolBlueprintEvent.MultiResourcePoolContributionEventValue(
                FfiConverterTypeMultiResourcePoolContributionEvent.read(buf),
                )
            2 -> TypedMultiResourcePoolBlueprintEvent.MultiResourcePoolRedemptionEventValue(
                FfiConverterTypeMultiResourcePoolRedemptionEvent.read(buf),
                )
            3 -> TypedMultiResourcePoolBlueprintEvent.MultiResourcePoolWithdrawEventValue(
                FfiConverterTypeMultiResourcePoolWithdrawEvent.read(buf),
                )
            4 -> TypedMultiResourcePoolBlueprintEvent.MultiResourcePoolDepositEventValue(
                FfiConverterTypeMultiResourcePoolDepositEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedMultiResourcePoolBlueprintEvent) = when(value) {
        is TypedMultiResourcePoolBlueprintEvent.MultiResourcePoolContributionEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeMultiResourcePoolContributionEvent.allocationSize(value.`value`)
            )
        }
        is TypedMultiResourcePoolBlueprintEvent.MultiResourcePoolRedemptionEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeMultiResourcePoolRedemptionEvent.allocationSize(value.`value`)
            )
        }
        is TypedMultiResourcePoolBlueprintEvent.MultiResourcePoolWithdrawEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeMultiResourcePoolWithdrawEvent.allocationSize(value.`value`)
            )
        }
        is TypedMultiResourcePoolBlueprintEvent.MultiResourcePoolDepositEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeMultiResourcePoolDepositEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedMultiResourcePoolBlueprintEvent, buf: ByteBuffer) {
        when(value) {
            is TypedMultiResourcePoolBlueprintEvent.MultiResourcePoolContributionEventValue -> {
                buf.putInt(1)
                FfiConverterTypeMultiResourcePoolContributionEvent.write(value.`value`, buf)
                Unit
            }
            is TypedMultiResourcePoolBlueprintEvent.MultiResourcePoolRedemptionEventValue -> {
                buf.putInt(2)
                FfiConverterTypeMultiResourcePoolRedemptionEvent.write(value.`value`, buf)
                Unit
            }
            is TypedMultiResourcePoolBlueprintEvent.MultiResourcePoolWithdrawEventValue -> {
                buf.putInt(3)
                FfiConverterTypeMultiResourcePoolWithdrawEvent.write(value.`value`, buf)
                Unit
            }
            is TypedMultiResourcePoolBlueprintEvent.MultiResourcePoolDepositEventValue -> {
                buf.putInt(4)
                FfiConverterTypeMultiResourcePoolDepositEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedNativeEvent: Disposable  {
    data class AccessController(
        val `value`: TypedAccessControllerPackageEvent
        ) : TypedNativeEvent()
    data class Account(
        val `value`: TypedAccountPackageEvent
        ) : TypedNativeEvent()
    data class ConsensusManager(
        val `value`: TypedConsensusManagerPackageEvent
        ) : TypedNativeEvent()
    data class Pool(
        val `value`: TypedPoolPackageEvent
        ) : TypedNativeEvent()
    data class Resource(
        val `value`: TypedResourcePackageEvent
        ) : TypedNativeEvent()
    data class RoleAssignment(
        val `value`: TypedRoleAssignmentPackageEvent
        ) : TypedNativeEvent()
    data class Metadata(
        val `value`: TypedMetadataPackageEvent
        ) : TypedNativeEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TypedNativeEvent.AccessController -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedNativeEvent.Account -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedNativeEvent.ConsensusManager -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedNativeEvent.Pool -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedNativeEvent.Resource -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedNativeEvent.RoleAssignment -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedNativeEvent.Metadata -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTypedNativeEvent : FfiConverterRustBuffer<TypedNativeEvent>{
    override fun read(buf: ByteBuffer): TypedNativeEvent {
        return when(buf.getInt()) {
            1 -> TypedNativeEvent.AccessController(
                FfiConverterTypeTypedAccessControllerPackageEvent.read(buf),
                )
            2 -> TypedNativeEvent.Account(
                FfiConverterTypeTypedAccountPackageEvent.read(buf),
                )
            3 -> TypedNativeEvent.ConsensusManager(
                FfiConverterTypeTypedConsensusManagerPackageEvent.read(buf),
                )
            4 -> TypedNativeEvent.Pool(
                FfiConverterTypeTypedPoolPackageEvent.read(buf),
                )
            5 -> TypedNativeEvent.Resource(
                FfiConverterTypeTypedResourcePackageEvent.read(buf),
                )
            6 -> TypedNativeEvent.RoleAssignment(
                FfiConverterTypeTypedRoleAssignmentPackageEvent.read(buf),
                )
            7 -> TypedNativeEvent.Metadata(
                FfiConverterTypeTypedMetadataPackageEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedNativeEvent) = when(value) {
        is TypedNativeEvent.AccessController -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTypedAccessControllerPackageEvent.allocationSize(value.`value`)
            )
        }
        is TypedNativeEvent.Account -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTypedAccountPackageEvent.allocationSize(value.`value`)
            )
        }
        is TypedNativeEvent.ConsensusManager -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTypedConsensusManagerPackageEvent.allocationSize(value.`value`)
            )
        }
        is TypedNativeEvent.Pool -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTypedPoolPackageEvent.allocationSize(value.`value`)
            )
        }
        is TypedNativeEvent.Resource -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTypedResourcePackageEvent.allocationSize(value.`value`)
            )
        }
        is TypedNativeEvent.RoleAssignment -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTypedRoleAssignmentPackageEvent.allocationSize(value.`value`)
            )
        }
        is TypedNativeEvent.Metadata -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTypedMetadataPackageEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedNativeEvent, buf: ByteBuffer) {
        when(value) {
            is TypedNativeEvent.AccessController -> {
                buf.putInt(1)
                FfiConverterTypeTypedAccessControllerPackageEvent.write(value.`value`, buf)
                Unit
            }
            is TypedNativeEvent.Account -> {
                buf.putInt(2)
                FfiConverterTypeTypedAccountPackageEvent.write(value.`value`, buf)
                Unit
            }
            is TypedNativeEvent.ConsensusManager -> {
                buf.putInt(3)
                FfiConverterTypeTypedConsensusManagerPackageEvent.write(value.`value`, buf)
                Unit
            }
            is TypedNativeEvent.Pool -> {
                buf.putInt(4)
                FfiConverterTypeTypedPoolPackageEvent.write(value.`value`, buf)
                Unit
            }
            is TypedNativeEvent.Resource -> {
                buf.putInt(5)
                FfiConverterTypeTypedResourcePackageEvent.write(value.`value`, buf)
                Unit
            }
            is TypedNativeEvent.RoleAssignment -> {
                buf.putInt(6)
                FfiConverterTypeTypedRoleAssignmentPackageEvent.write(value.`value`, buf)
                Unit
            }
            is TypedNativeEvent.Metadata -> {
                buf.putInt(7)
                FfiConverterTypeTypedMetadataPackageEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedNonFungibleResourceManagerBlueprintEvent: Disposable  {
    data class VaultCreationEventValue(
        val `value`: VaultCreationEvent
        ) : TypedNonFungibleResourceManagerBlueprintEvent()
    data class MintNonFungibleResourceEventValue(
        val `value`: MintNonFungibleResourceEvent
        ) : TypedNonFungibleResourceManagerBlueprintEvent()
    data class BurnNonFungibleResourceEventValue(
        val `value`: BurnNonFungibleResourceEvent
        ) : TypedNonFungibleResourceManagerBlueprintEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TypedNonFungibleResourceManagerBlueprintEvent.VaultCreationEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedNonFungibleResourceManagerBlueprintEvent.MintNonFungibleResourceEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedNonFungibleResourceManagerBlueprintEvent.BurnNonFungibleResourceEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent : FfiConverterRustBuffer<TypedNonFungibleResourceManagerBlueprintEvent>{
    override fun read(buf: ByteBuffer): TypedNonFungibleResourceManagerBlueprintEvent {
        return when(buf.getInt()) {
            1 -> TypedNonFungibleResourceManagerBlueprintEvent.VaultCreationEventValue(
                FfiConverterTypeVaultCreationEvent.read(buf),
                )
            2 -> TypedNonFungibleResourceManagerBlueprintEvent.MintNonFungibleResourceEventValue(
                FfiConverterTypeMintNonFungibleResourceEvent.read(buf),
                )
            3 -> TypedNonFungibleResourceManagerBlueprintEvent.BurnNonFungibleResourceEventValue(
                FfiConverterTypeBurnNonFungibleResourceEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedNonFungibleResourceManagerBlueprintEvent) = when(value) {
        is TypedNonFungibleResourceManagerBlueprintEvent.VaultCreationEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeVaultCreationEvent.allocationSize(value.`value`)
            )
        }
        is TypedNonFungibleResourceManagerBlueprintEvent.MintNonFungibleResourceEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeMintNonFungibleResourceEvent.allocationSize(value.`value`)
            )
        }
        is TypedNonFungibleResourceManagerBlueprintEvent.BurnNonFungibleResourceEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeBurnNonFungibleResourceEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedNonFungibleResourceManagerBlueprintEvent, buf: ByteBuffer) {
        when(value) {
            is TypedNonFungibleResourceManagerBlueprintEvent.VaultCreationEventValue -> {
                buf.putInt(1)
                FfiConverterTypeVaultCreationEvent.write(value.`value`, buf)
                Unit
            }
            is TypedNonFungibleResourceManagerBlueprintEvent.MintNonFungibleResourceEventValue -> {
                buf.putInt(2)
                FfiConverterTypeMintNonFungibleResourceEvent.write(value.`value`, buf)
                Unit
            }
            is TypedNonFungibleResourceManagerBlueprintEvent.BurnNonFungibleResourceEventValue -> {
                buf.putInt(3)
                FfiConverterTypeBurnNonFungibleResourceEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedNonFungibleVaultBlueprintEvent {
    data class NonFungibleVaultWithdrawEventValue(
        val `value`: NonFungibleVaultWithdrawEvent
        ) : TypedNonFungibleVaultBlueprintEvent()
    data class NonFungibleVaultDepositEventValue(
        val `value`: NonFungibleVaultDepositEvent
        ) : TypedNonFungibleVaultBlueprintEvent()
    data class NonFungibleVaultRecallEventValue(
        val `value`: NonFungibleVaultRecallEvent
        ) : TypedNonFungibleVaultBlueprintEvent()
    

    
}

public object FfiConverterTypeTypedNonFungibleVaultBlueprintEvent : FfiConverterRustBuffer<TypedNonFungibleVaultBlueprintEvent>{
    override fun read(buf: ByteBuffer): TypedNonFungibleVaultBlueprintEvent {
        return when(buf.getInt()) {
            1 -> TypedNonFungibleVaultBlueprintEvent.NonFungibleVaultWithdrawEventValue(
                FfiConverterTypeNonFungibleVaultWithdrawEvent.read(buf),
                )
            2 -> TypedNonFungibleVaultBlueprintEvent.NonFungibleVaultDepositEventValue(
                FfiConverterTypeNonFungibleVaultDepositEvent.read(buf),
                )
            3 -> TypedNonFungibleVaultBlueprintEvent.NonFungibleVaultRecallEventValue(
                FfiConverterTypeNonFungibleVaultRecallEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedNonFungibleVaultBlueprintEvent) = when(value) {
        is TypedNonFungibleVaultBlueprintEvent.NonFungibleVaultWithdrawEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeNonFungibleVaultWithdrawEvent.allocationSize(value.`value`)
            )
        }
        is TypedNonFungibleVaultBlueprintEvent.NonFungibleVaultDepositEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeNonFungibleVaultDepositEvent.allocationSize(value.`value`)
            )
        }
        is TypedNonFungibleVaultBlueprintEvent.NonFungibleVaultRecallEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeNonFungibleVaultRecallEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedNonFungibleVaultBlueprintEvent, buf: ByteBuffer) {
        when(value) {
            is TypedNonFungibleVaultBlueprintEvent.NonFungibleVaultWithdrawEventValue -> {
                buf.putInt(1)
                FfiConverterTypeNonFungibleVaultWithdrawEvent.write(value.`value`, buf)
                Unit
            }
            is TypedNonFungibleVaultBlueprintEvent.NonFungibleVaultDepositEventValue -> {
                buf.putInt(2)
                FfiConverterTypeNonFungibleVaultDepositEvent.write(value.`value`, buf)
                Unit
            }
            is TypedNonFungibleVaultBlueprintEvent.NonFungibleVaultRecallEventValue -> {
                buf.putInt(3)
                FfiConverterTypeNonFungibleVaultRecallEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedOneResourcePoolBlueprintEvent: Disposable  {
    data class OneResourcePoolContributionEventValue(
        val `value`: OneResourcePoolContributionEvent
        ) : TypedOneResourcePoolBlueprintEvent()
    data class OneResourcePoolRedemptionEventValue(
        val `value`: OneResourcePoolRedemptionEvent
        ) : TypedOneResourcePoolBlueprintEvent()
    data class OneResourcePoolWithdrawEventValue(
        val `value`: OneResourcePoolWithdrawEvent
        ) : TypedOneResourcePoolBlueprintEvent()
    data class OneResourcePoolDepositEventValue(
        val `value`: OneResourcePoolDepositEvent
        ) : TypedOneResourcePoolBlueprintEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TypedOneResourcePoolBlueprintEvent.OneResourcePoolContributionEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedOneResourcePoolBlueprintEvent.OneResourcePoolRedemptionEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedOneResourcePoolBlueprintEvent.OneResourcePoolWithdrawEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedOneResourcePoolBlueprintEvent.OneResourcePoolDepositEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTypedOneResourcePoolBlueprintEvent : FfiConverterRustBuffer<TypedOneResourcePoolBlueprintEvent>{
    override fun read(buf: ByteBuffer): TypedOneResourcePoolBlueprintEvent {
        return when(buf.getInt()) {
            1 -> TypedOneResourcePoolBlueprintEvent.OneResourcePoolContributionEventValue(
                FfiConverterTypeOneResourcePoolContributionEvent.read(buf),
                )
            2 -> TypedOneResourcePoolBlueprintEvent.OneResourcePoolRedemptionEventValue(
                FfiConverterTypeOneResourcePoolRedemptionEvent.read(buf),
                )
            3 -> TypedOneResourcePoolBlueprintEvent.OneResourcePoolWithdrawEventValue(
                FfiConverterTypeOneResourcePoolWithdrawEvent.read(buf),
                )
            4 -> TypedOneResourcePoolBlueprintEvent.OneResourcePoolDepositEventValue(
                FfiConverterTypeOneResourcePoolDepositEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedOneResourcePoolBlueprintEvent) = when(value) {
        is TypedOneResourcePoolBlueprintEvent.OneResourcePoolContributionEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeOneResourcePoolContributionEvent.allocationSize(value.`value`)
            )
        }
        is TypedOneResourcePoolBlueprintEvent.OneResourcePoolRedemptionEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeOneResourcePoolRedemptionEvent.allocationSize(value.`value`)
            )
        }
        is TypedOneResourcePoolBlueprintEvent.OneResourcePoolWithdrawEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeOneResourcePoolWithdrawEvent.allocationSize(value.`value`)
            )
        }
        is TypedOneResourcePoolBlueprintEvent.OneResourcePoolDepositEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeOneResourcePoolDepositEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedOneResourcePoolBlueprintEvent, buf: ByteBuffer) {
        when(value) {
            is TypedOneResourcePoolBlueprintEvent.OneResourcePoolContributionEventValue -> {
                buf.putInt(1)
                FfiConverterTypeOneResourcePoolContributionEvent.write(value.`value`, buf)
                Unit
            }
            is TypedOneResourcePoolBlueprintEvent.OneResourcePoolRedemptionEventValue -> {
                buf.putInt(2)
                FfiConverterTypeOneResourcePoolRedemptionEvent.write(value.`value`, buf)
                Unit
            }
            is TypedOneResourcePoolBlueprintEvent.OneResourcePoolWithdrawEventValue -> {
                buf.putInt(3)
                FfiConverterTypeOneResourcePoolWithdrawEvent.write(value.`value`, buf)
                Unit
            }
            is TypedOneResourcePoolBlueprintEvent.OneResourcePoolDepositEventValue -> {
                buf.putInt(4)
                FfiConverterTypeOneResourcePoolDepositEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedPoolPackageEvent: Disposable  {
    data class OneResourcePool(
        val `value`: TypedOneResourcePoolBlueprintEvent
        ) : TypedPoolPackageEvent()
    data class TwoResourcePool(
        val `value`: TypedTwoResourcePoolBlueprintEvent
        ) : TypedPoolPackageEvent()
    data class MultiResourcePool(
        val `value`: TypedMultiResourcePoolBlueprintEvent
        ) : TypedPoolPackageEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TypedPoolPackageEvent.OneResourcePool -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedPoolPackageEvent.TwoResourcePool -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedPoolPackageEvent.MultiResourcePool -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTypedPoolPackageEvent : FfiConverterRustBuffer<TypedPoolPackageEvent>{
    override fun read(buf: ByteBuffer): TypedPoolPackageEvent {
        return when(buf.getInt()) {
            1 -> TypedPoolPackageEvent.OneResourcePool(
                FfiConverterTypeTypedOneResourcePoolBlueprintEvent.read(buf),
                )
            2 -> TypedPoolPackageEvent.TwoResourcePool(
                FfiConverterTypeTypedTwoResourcePoolBlueprintEvent.read(buf),
                )
            3 -> TypedPoolPackageEvent.MultiResourcePool(
                FfiConverterTypeTypedMultiResourcePoolBlueprintEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedPoolPackageEvent) = when(value) {
        is TypedPoolPackageEvent.OneResourcePool -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTypedOneResourcePoolBlueprintEvent.allocationSize(value.`value`)
            )
        }
        is TypedPoolPackageEvent.TwoResourcePool -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTypedTwoResourcePoolBlueprintEvent.allocationSize(value.`value`)
            )
        }
        is TypedPoolPackageEvent.MultiResourcePool -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTypedMultiResourcePoolBlueprintEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedPoolPackageEvent, buf: ByteBuffer) {
        when(value) {
            is TypedPoolPackageEvent.OneResourcePool -> {
                buf.putInt(1)
                FfiConverterTypeTypedOneResourcePoolBlueprintEvent.write(value.`value`, buf)
                Unit
            }
            is TypedPoolPackageEvent.TwoResourcePool -> {
                buf.putInt(2)
                FfiConverterTypeTypedTwoResourcePoolBlueprintEvent.write(value.`value`, buf)
                Unit
            }
            is TypedPoolPackageEvent.MultiResourcePool -> {
                buf.putInt(3)
                FfiConverterTypeTypedMultiResourcePoolBlueprintEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedResourcePackageEvent: Disposable  {
    data class FungibleVault(
        val `value`: TypedFungibleVaultBlueprintEvent
        ) : TypedResourcePackageEvent()
    data class NonFungibleVault(
        val `value`: TypedNonFungibleVaultBlueprintEvent
        ) : TypedResourcePackageEvent()
    data class FungibleResourceManager(
        val `value`: TypedFungibleResourceManagerBlueprintEvent
        ) : TypedResourcePackageEvent()
    data class NonFungibleResourceManager(
        val `value`: TypedNonFungibleResourceManagerBlueprintEvent
        ) : TypedResourcePackageEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TypedResourcePackageEvent.FungibleVault -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedResourcePackageEvent.NonFungibleVault -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedResourcePackageEvent.FungibleResourceManager -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedResourcePackageEvent.NonFungibleResourceManager -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTypedResourcePackageEvent : FfiConverterRustBuffer<TypedResourcePackageEvent>{
    override fun read(buf: ByteBuffer): TypedResourcePackageEvent {
        return when(buf.getInt()) {
            1 -> TypedResourcePackageEvent.FungibleVault(
                FfiConverterTypeTypedFungibleVaultBlueprintEvent.read(buf),
                )
            2 -> TypedResourcePackageEvent.NonFungibleVault(
                FfiConverterTypeTypedNonFungibleVaultBlueprintEvent.read(buf),
                )
            3 -> TypedResourcePackageEvent.FungibleResourceManager(
                FfiConverterTypeTypedFungibleResourceManagerBlueprintEvent.read(buf),
                )
            4 -> TypedResourcePackageEvent.NonFungibleResourceManager(
                FfiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedResourcePackageEvent) = when(value) {
        is TypedResourcePackageEvent.FungibleVault -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTypedFungibleVaultBlueprintEvent.allocationSize(value.`value`)
            )
        }
        is TypedResourcePackageEvent.NonFungibleVault -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTypedNonFungibleVaultBlueprintEvent.allocationSize(value.`value`)
            )
        }
        is TypedResourcePackageEvent.FungibleResourceManager -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTypedFungibleResourceManagerBlueprintEvent.allocationSize(value.`value`)
            )
        }
        is TypedResourcePackageEvent.NonFungibleResourceManager -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedResourcePackageEvent, buf: ByteBuffer) {
        when(value) {
            is TypedResourcePackageEvent.FungibleVault -> {
                buf.putInt(1)
                FfiConverterTypeTypedFungibleVaultBlueprintEvent.write(value.`value`, buf)
                Unit
            }
            is TypedResourcePackageEvent.NonFungibleVault -> {
                buf.putInt(2)
                FfiConverterTypeTypedNonFungibleVaultBlueprintEvent.write(value.`value`, buf)
                Unit
            }
            is TypedResourcePackageEvent.FungibleResourceManager -> {
                buf.putInt(3)
                FfiConverterTypeTypedFungibleResourceManagerBlueprintEvent.write(value.`value`, buf)
                Unit
            }
            is TypedResourcePackageEvent.NonFungibleResourceManager -> {
                buf.putInt(4)
                FfiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedRoleAssignmentBlueprintEvent: Disposable  {
    data class SetRoleEventValue(
        val `value`: SetRoleEvent
        ) : TypedRoleAssignmentBlueprintEvent()
    data class SetOwnerRoleEventValue(
        val `value`: SetOwnerRoleEvent
        ) : TypedRoleAssignmentBlueprintEvent()
    data class LockOwnerRoleEventValue(
        val `value`: LockOwnerRoleEvent
        ) : TypedRoleAssignmentBlueprintEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TypedRoleAssignmentBlueprintEvent.SetRoleEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedRoleAssignmentBlueprintEvent.SetOwnerRoleEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedRoleAssignmentBlueprintEvent.LockOwnerRoleEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTypedRoleAssignmentBlueprintEvent : FfiConverterRustBuffer<TypedRoleAssignmentBlueprintEvent>{
    override fun read(buf: ByteBuffer): TypedRoleAssignmentBlueprintEvent {
        return when(buf.getInt()) {
            1 -> TypedRoleAssignmentBlueprintEvent.SetRoleEventValue(
                FfiConverterTypeSetRoleEvent.read(buf),
                )
            2 -> TypedRoleAssignmentBlueprintEvent.SetOwnerRoleEventValue(
                FfiConverterTypeSetOwnerRoleEvent.read(buf),
                )
            3 -> TypedRoleAssignmentBlueprintEvent.LockOwnerRoleEventValue(
                FfiConverterTypeLockOwnerRoleEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedRoleAssignmentBlueprintEvent) = when(value) {
        is TypedRoleAssignmentBlueprintEvent.SetRoleEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeSetRoleEvent.allocationSize(value.`value`)
            )
        }
        is TypedRoleAssignmentBlueprintEvent.SetOwnerRoleEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeSetOwnerRoleEvent.allocationSize(value.`value`)
            )
        }
        is TypedRoleAssignmentBlueprintEvent.LockOwnerRoleEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeLockOwnerRoleEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedRoleAssignmentBlueprintEvent, buf: ByteBuffer) {
        when(value) {
            is TypedRoleAssignmentBlueprintEvent.SetRoleEventValue -> {
                buf.putInt(1)
                FfiConverterTypeSetRoleEvent.write(value.`value`, buf)
                Unit
            }
            is TypedRoleAssignmentBlueprintEvent.SetOwnerRoleEventValue -> {
                buf.putInt(2)
                FfiConverterTypeSetOwnerRoleEvent.write(value.`value`, buf)
                Unit
            }
            is TypedRoleAssignmentBlueprintEvent.LockOwnerRoleEventValue -> {
                buf.putInt(3)
                FfiConverterTypeLockOwnerRoleEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedRoleAssignmentPackageEvent: Disposable  {
    data class RoleAssignment(
        val `value`: TypedRoleAssignmentBlueprintEvent
        ) : TypedRoleAssignmentPackageEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TypedRoleAssignmentPackageEvent.RoleAssignment -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTypedRoleAssignmentPackageEvent : FfiConverterRustBuffer<TypedRoleAssignmentPackageEvent>{
    override fun read(buf: ByteBuffer): TypedRoleAssignmentPackageEvent {
        return when(buf.getInt()) {
            1 -> TypedRoleAssignmentPackageEvent.RoleAssignment(
                FfiConverterTypeTypedRoleAssignmentBlueprintEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedRoleAssignmentPackageEvent) = when(value) {
        is TypedRoleAssignmentPackageEvent.RoleAssignment -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTypedRoleAssignmentBlueprintEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedRoleAssignmentPackageEvent, buf: ByteBuffer) {
        when(value) {
            is TypedRoleAssignmentPackageEvent.RoleAssignment -> {
                buf.putInt(1)
                FfiConverterTypeTypedRoleAssignmentBlueprintEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedTwoResourcePoolBlueprintEvent: Disposable  {
    data class TwoResourcePoolContributionEventValue(
        val `value`: TwoResourcePoolContributionEvent
        ) : TypedTwoResourcePoolBlueprintEvent()
    data class TwoResourcePoolRedemptionEventValue(
        val `value`: TwoResourcePoolRedemptionEvent
        ) : TypedTwoResourcePoolBlueprintEvent()
    data class TwoResourcePoolWithdrawEventValue(
        val `value`: TwoResourcePoolWithdrawEvent
        ) : TypedTwoResourcePoolBlueprintEvent()
    data class TwoResourcePoolDepositEventValue(
        val `value`: TwoResourcePoolDepositEvent
        ) : TypedTwoResourcePoolBlueprintEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TypedTwoResourcePoolBlueprintEvent.TwoResourcePoolContributionEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedTwoResourcePoolBlueprintEvent.TwoResourcePoolRedemptionEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedTwoResourcePoolBlueprintEvent.TwoResourcePoolWithdrawEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedTwoResourcePoolBlueprintEvent.TwoResourcePoolDepositEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTypedTwoResourcePoolBlueprintEvent : FfiConverterRustBuffer<TypedTwoResourcePoolBlueprintEvent>{
    override fun read(buf: ByteBuffer): TypedTwoResourcePoolBlueprintEvent {
        return when(buf.getInt()) {
            1 -> TypedTwoResourcePoolBlueprintEvent.TwoResourcePoolContributionEventValue(
                FfiConverterTypeTwoResourcePoolContributionEvent.read(buf),
                )
            2 -> TypedTwoResourcePoolBlueprintEvent.TwoResourcePoolRedemptionEventValue(
                FfiConverterTypeTwoResourcePoolRedemptionEvent.read(buf),
                )
            3 -> TypedTwoResourcePoolBlueprintEvent.TwoResourcePoolWithdrawEventValue(
                FfiConverterTypeTwoResourcePoolWithdrawEvent.read(buf),
                )
            4 -> TypedTwoResourcePoolBlueprintEvent.TwoResourcePoolDepositEventValue(
                FfiConverterTypeTwoResourcePoolDepositEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedTwoResourcePoolBlueprintEvent) = when(value) {
        is TypedTwoResourcePoolBlueprintEvent.TwoResourcePoolContributionEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTwoResourcePoolContributionEvent.allocationSize(value.`value`)
            )
        }
        is TypedTwoResourcePoolBlueprintEvent.TwoResourcePoolRedemptionEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTwoResourcePoolRedemptionEvent.allocationSize(value.`value`)
            )
        }
        is TypedTwoResourcePoolBlueprintEvent.TwoResourcePoolWithdrawEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTwoResourcePoolWithdrawEvent.allocationSize(value.`value`)
            )
        }
        is TypedTwoResourcePoolBlueprintEvent.TwoResourcePoolDepositEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeTwoResourcePoolDepositEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedTwoResourcePoolBlueprintEvent, buf: ByteBuffer) {
        when(value) {
            is TypedTwoResourcePoolBlueprintEvent.TwoResourcePoolContributionEventValue -> {
                buf.putInt(1)
                FfiConverterTypeTwoResourcePoolContributionEvent.write(value.`value`, buf)
                Unit
            }
            is TypedTwoResourcePoolBlueprintEvent.TwoResourcePoolRedemptionEventValue -> {
                buf.putInt(2)
                FfiConverterTypeTwoResourcePoolRedemptionEvent.write(value.`value`, buf)
                Unit
            }
            is TypedTwoResourcePoolBlueprintEvent.TwoResourcePoolWithdrawEventValue -> {
                buf.putInt(3)
                FfiConverterTypeTwoResourcePoolWithdrawEvent.write(value.`value`, buf)
                Unit
            }
            is TypedTwoResourcePoolBlueprintEvent.TwoResourcePoolDepositEventValue -> {
                buf.putInt(4)
                FfiConverterTypeTwoResourcePoolDepositEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class TypedValidatorBlueprintEvent: Disposable  {
    data class RegisterValidatorEventValue(
        val `value`: RegisterValidatorEvent
        ) : TypedValidatorBlueprintEvent()
    data class UnregisterValidatorEventValue(
        val `value`: UnregisterValidatorEvent
        ) : TypedValidatorBlueprintEvent()
    data class StakeEventValue(
        val `value`: StakeEvent
        ) : TypedValidatorBlueprintEvent()
    data class UnstakeEventValue(
        val `value`: UnstakeEvent
        ) : TypedValidatorBlueprintEvent()
    data class ClaimXrdEventValue(
        val `value`: ClaimXrdEvent
        ) : TypedValidatorBlueprintEvent()
    data class UpdateAcceptingStakeDelegationStateEventValue(
        val `value`: UpdateAcceptingStakeDelegationStateEvent
        ) : TypedValidatorBlueprintEvent()
    data class ProtocolUpdateReadinessSignalEventValue(
        val `value`: ProtocolUpdateReadinessSignalEvent
        ) : TypedValidatorBlueprintEvent()
    data class ValidatorEmissionAppliedEventValue(
        val `value`: ValidatorEmissionAppliedEvent
        ) : TypedValidatorBlueprintEvent()
    data class ValidatorRewardAppliedEventValue(
        val `value`: ValidatorRewardAppliedEvent
        ) : TypedValidatorBlueprintEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is TypedValidatorBlueprintEvent.RegisterValidatorEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedValidatorBlueprintEvent.UnregisterValidatorEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedValidatorBlueprintEvent.StakeEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedValidatorBlueprintEvent.UnstakeEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedValidatorBlueprintEvent.ClaimXrdEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedValidatorBlueprintEvent.UpdateAcceptingStakeDelegationStateEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedValidatorBlueprintEvent.ProtocolUpdateReadinessSignalEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedValidatorBlueprintEvent.ValidatorEmissionAppliedEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is TypedValidatorBlueprintEvent.ValidatorRewardAppliedEventValue -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeTypedValidatorBlueprintEvent : FfiConverterRustBuffer<TypedValidatorBlueprintEvent>{
    override fun read(buf: ByteBuffer): TypedValidatorBlueprintEvent {
        return when(buf.getInt()) {
            1 -> TypedValidatorBlueprintEvent.RegisterValidatorEventValue(
                FfiConverterTypeRegisterValidatorEvent.read(buf),
                )
            2 -> TypedValidatorBlueprintEvent.UnregisterValidatorEventValue(
                FfiConverterTypeUnregisterValidatorEvent.read(buf),
                )
            3 -> TypedValidatorBlueprintEvent.StakeEventValue(
                FfiConverterTypeStakeEvent.read(buf),
                )
            4 -> TypedValidatorBlueprintEvent.UnstakeEventValue(
                FfiConverterTypeUnstakeEvent.read(buf),
                )
            5 -> TypedValidatorBlueprintEvent.ClaimXrdEventValue(
                FfiConverterTypeClaimXrdEvent.read(buf),
                )
            6 -> TypedValidatorBlueprintEvent.UpdateAcceptingStakeDelegationStateEventValue(
                FfiConverterTypeUpdateAcceptingStakeDelegationStateEvent.read(buf),
                )
            7 -> TypedValidatorBlueprintEvent.ProtocolUpdateReadinessSignalEventValue(
                FfiConverterTypeProtocolUpdateReadinessSignalEvent.read(buf),
                )
            8 -> TypedValidatorBlueprintEvent.ValidatorEmissionAppliedEventValue(
                FfiConverterTypeValidatorEmissionAppliedEvent.read(buf),
                )
            9 -> TypedValidatorBlueprintEvent.ValidatorRewardAppliedEventValue(
                FfiConverterTypeValidatorRewardAppliedEvent.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TypedValidatorBlueprintEvent) = when(value) {
        is TypedValidatorBlueprintEvent.RegisterValidatorEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeRegisterValidatorEvent.allocationSize(value.`value`)
            )
        }
        is TypedValidatorBlueprintEvent.UnregisterValidatorEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeUnregisterValidatorEvent.allocationSize(value.`value`)
            )
        }
        is TypedValidatorBlueprintEvent.StakeEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeStakeEvent.allocationSize(value.`value`)
            )
        }
        is TypedValidatorBlueprintEvent.UnstakeEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeUnstakeEvent.allocationSize(value.`value`)
            )
        }
        is TypedValidatorBlueprintEvent.ClaimXrdEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeClaimXrdEvent.allocationSize(value.`value`)
            )
        }
        is TypedValidatorBlueprintEvent.UpdateAcceptingStakeDelegationStateEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeUpdateAcceptingStakeDelegationStateEvent.allocationSize(value.`value`)
            )
        }
        is TypedValidatorBlueprintEvent.ProtocolUpdateReadinessSignalEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeProtocolUpdateReadinessSignalEvent.allocationSize(value.`value`)
            )
        }
        is TypedValidatorBlueprintEvent.ValidatorEmissionAppliedEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeValidatorEmissionAppliedEvent.allocationSize(value.`value`)
            )
        }
        is TypedValidatorBlueprintEvent.ValidatorRewardAppliedEventValue -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeValidatorRewardAppliedEvent.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: TypedValidatorBlueprintEvent, buf: ByteBuffer) {
        when(value) {
            is TypedValidatorBlueprintEvent.RegisterValidatorEventValue -> {
                buf.putInt(1)
                FfiConverterTypeRegisterValidatorEvent.write(value.`value`, buf)
                Unit
            }
            is TypedValidatorBlueprintEvent.UnregisterValidatorEventValue -> {
                buf.putInt(2)
                FfiConverterTypeUnregisterValidatorEvent.write(value.`value`, buf)
                Unit
            }
            is TypedValidatorBlueprintEvent.StakeEventValue -> {
                buf.putInt(3)
                FfiConverterTypeStakeEvent.write(value.`value`, buf)
                Unit
            }
            is TypedValidatorBlueprintEvent.UnstakeEventValue -> {
                buf.putInt(4)
                FfiConverterTypeUnstakeEvent.write(value.`value`, buf)
                Unit
            }
            is TypedValidatorBlueprintEvent.ClaimXrdEventValue -> {
                buf.putInt(5)
                FfiConverterTypeClaimXrdEvent.write(value.`value`, buf)
                Unit
            }
            is TypedValidatorBlueprintEvent.UpdateAcceptingStakeDelegationStateEventValue -> {
                buf.putInt(6)
                FfiConverterTypeUpdateAcceptingStakeDelegationStateEvent.write(value.`value`, buf)
                Unit
            }
            is TypedValidatorBlueprintEvent.ProtocolUpdateReadinessSignalEventValue -> {
                buf.putInt(7)
                FfiConverterTypeProtocolUpdateReadinessSignalEvent.write(value.`value`, buf)
                Unit
            }
            is TypedValidatorBlueprintEvent.ValidatorEmissionAppliedEventValue -> {
                buf.putInt(8)
                FfiConverterTypeValidatorEmissionAppliedEvent.write(value.`value`, buf)
                Unit
            }
            is TypedValidatorBlueprintEvent.ValidatorRewardAppliedEventValue -> {
                buf.putInt(9)
                FfiConverterTypeValidatorRewardAppliedEvent.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






sealed class WithdrawResourceEvent: Disposable  {
    data class Amount(
        val `value`: Decimal
        ) : WithdrawResourceEvent()
    data class Ids(
        val `value`: List<NonFungibleLocalId>
        ) : WithdrawResourceEvent()
    

    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        when(this) {
            is WithdrawResourceEvent.Amount -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
            is WithdrawResourceEvent.Ids -> {
                
    Disposable.destroy(
        this.`value`)
                
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
    
}

public object FfiConverterTypeWithdrawResourceEvent : FfiConverterRustBuffer<WithdrawResourceEvent>{
    override fun read(buf: ByteBuffer): WithdrawResourceEvent {
        return when(buf.getInt()) {
            1 -> WithdrawResourceEvent.Amount(
                FfiConverterTypeDecimal.read(buf),
                )
            2 -> WithdrawResourceEvent.Ids(
                FfiConverterSequenceTypeNonFungibleLocalId.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: WithdrawResourceEvent) = when(value) {
        is WithdrawResourceEvent.Amount -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeDecimal.allocationSize(value.`value`)
            )
        }
        is WithdrawResourceEvent.Ids -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceTypeNonFungibleLocalId.allocationSize(value.`value`)
            )
        }
    }

    override fun write(value: WithdrawResourceEvent, buf: ByteBuffer) {
        when(value) {
            is WithdrawResourceEvent.Amount -> {
                buf.putInt(1)
                FfiConverterTypeDecimal.write(value.`value`, buf)
                Unit
            }
            is WithdrawResourceEvent.Ids -> {
                buf.putInt(2)
                FfiConverterSequenceTypeNonFungibleLocalId.write(value.`value`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






internal typealias Handle = Long
internal class ConcurrentHandleMap<T>(
    private val leftMap: MutableMap<Handle, T> = mutableMapOf(),
    private val rightMap: MutableMap<T, Handle> = mutableMapOf()
) {
    private val lock = java.util.concurrent.locks.ReentrantLock()
    private val currentHandle = AtomicLong(0L)
    private val stride = 1L

    fun insert(obj: T): Handle =
        lock.withLock {
            rightMap[obj] ?:
                currentHandle.getAndAdd(stride)
                    .also { handle ->
                        leftMap[handle] = obj
                        rightMap[obj] = handle
                    }
            }

    fun get(handle: Handle) = lock.withLock {
        leftMap[handle]
    }

    fun delete(handle: Handle) {
        this.remove(handle)
    }

    fun remove(handle: Handle): T? =
        lock.withLock {
            leftMap.remove(handle)?.let { obj ->
                rightMap.remove(obj)
                obj
            }
        }
}

interface ForeignCallback : com.sun.jna.Callback {
    public fun invoke(handle: Handle, method: Int, argsData: Pointer, argsLen: Int, outBuf: RustBufferByReference): Int
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
internal const val IDX_CALLBACK_FREE = 0
// Callback return codes
internal const val UNIFFI_CALLBACK_SUCCESS = 0
internal const val UNIFFI_CALLBACK_ERROR = 1
internal const val UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

public abstract class FfiConverterCallbackInterface<CallbackInterface>(
    protected val foreignCallback: ForeignCallback
): FfiConverter<CallbackInterface, Handle> {
    private val handleMap = ConcurrentHandleMap<CallbackInterface>()

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    internal abstract fun register(lib: _UniFFILib)

    fun drop(handle: Handle): RustBuffer.ByValue {
        return handleMap.remove(handle).let { RustBuffer.ByValue() }
    }

    override fun lift(value: Handle): CallbackInterface {
        return handleMap.get(value) ?: throw InternalException("No callback in handlemap; this is a Uniffi bug")
    }

    override fun read(buf: ByteBuffer) = lift(buf.getLong())

    override fun lower(value: CallbackInterface) =
        handleMap.insert(value).also {
            assert(handleMap.get(it) === value) { "Handle map is not returning the object we just placed there. This is a bug in the HandleMap." }
        }

    override fun allocationSize(value: CallbackInterface) = 8

    override fun write(value: CallbackInterface, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}

// Declaration and FfiConverters for Signer Callback Interface

public interface Signer {
    fun `sign`(`hash`: Hash): List<UByte>
    fun `signToSignature`(`hash`: Hash): Signature
    fun `signToSignatureWithPublicKey`(`hash`: Hash): SignatureWithPublicKey
    fun `publicKey`(): PublicKey
    
}

// The ForeignCallback that is passed to Rust.
internal class ForeignCallbackTypeSigner : ForeignCallback {
    @Suppress("TooGenericExceptionCaught")
    override fun invoke(handle: Handle, method: Int, argsData: Pointer, argsLen: Int, outBuf: RustBufferByReference): Int {
        val cb = FfiConverterTypeSigner.lift(handle)
        return when (method) {
            IDX_CALLBACK_FREE -> {
                FfiConverterTypeSigner.drop(handle)
                // Successful return
                // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
                UNIFFI_CALLBACK_SUCCESS
            }
            1 -> {
                // Call the method, write to outBuf and return a status code
                // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for info
                try {
                    this.`invokeSign`(cb, argsData, argsLen, outBuf)
                } catch (e: Throwable) {
                    // Unexpected error
                    try {
                        // Try to serialize the error into a string
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                        // If that fails, then it's time to give up and just return
                    }
                    UNIFFI_CALLBACK_UNEXPECTED_ERROR
                }
            }
            2 -> {
                // Call the method, write to outBuf and return a status code
                // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for info
                try {
                    this.`invokeSignToSignature`(cb, argsData, argsLen, outBuf)
                } catch (e: Throwable) {
                    // Unexpected error
                    try {
                        // Try to serialize the error into a string
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                        // If that fails, then it's time to give up and just return
                    }
                    UNIFFI_CALLBACK_UNEXPECTED_ERROR
                }
            }
            3 -> {
                // Call the method, write to outBuf and return a status code
                // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for info
                try {
                    this.`invokeSignToSignatureWithPublicKey`(cb, argsData, argsLen, outBuf)
                } catch (e: Throwable) {
                    // Unexpected error
                    try {
                        // Try to serialize the error into a string
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                        // If that fails, then it's time to give up and just return
                    }
                    UNIFFI_CALLBACK_UNEXPECTED_ERROR
                }
            }
            4 -> {
                // Call the method, write to outBuf and return a status code
                // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for info
                try {
                    this.`invokePublicKey`(cb, argsData, argsLen, outBuf)
                } catch (e: Throwable) {
                    // Unexpected error
                    try {
                        // Try to serialize the error into a string
                        outBuf.setValue(FfiConverterString.lower(e.toString()))
                    } catch (e: Throwable) {
                        // If that fails, then it's time to give up and just return
                    }
                    UNIFFI_CALLBACK_UNEXPECTED_ERROR
                }
            }
            
            else -> {
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
                try {
                    // Try to serialize the error into a string
                    outBuf.setValue(FfiConverterString.lower("Invalid Callback index"))
                } catch (e: Throwable) {
                    // If that fails, then it's time to give up and just return
                }
                UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        }
    }

    
    @Suppress("UNUSED_PARAMETER")
    private fun `invokeSign`(kotlinCallbackInterface: Signer, argsData: Pointer, argsLen: Int, outBuf: RustBufferByReference): Int {
        val argsBuf = argsData.getByteBuffer(0, argsLen.toLong()).also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
        fun makeCall() : Int {
            val returnValue = kotlinCallbackInterface.`sign`(
                FfiConverterTypeHash.read(argsBuf)
                
            )
            outBuf.setValue(FfiConverterSequenceUByte.lowerIntoRustBuffer(returnValue))
            return UNIFFI_CALLBACK_SUCCESS
        }
        fun makeCallAndHandleError() : Int = makeCall()

        return makeCallAndHandleError()
    }
    
    @Suppress("UNUSED_PARAMETER")
    private fun `invokeSignToSignature`(kotlinCallbackInterface: Signer, argsData: Pointer, argsLen: Int, outBuf: RustBufferByReference): Int {
        val argsBuf = argsData.getByteBuffer(0, argsLen.toLong()).also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
        fun makeCall() : Int {
            val returnValue = kotlinCallbackInterface.`signToSignature`(
                FfiConverterTypeHash.read(argsBuf)
                
            )
            outBuf.setValue(FfiConverterTypeSignature.lowerIntoRustBuffer(returnValue))
            return UNIFFI_CALLBACK_SUCCESS
        }
        fun makeCallAndHandleError() : Int = makeCall()

        return makeCallAndHandleError()
    }
    
    @Suppress("UNUSED_PARAMETER")
    private fun `invokeSignToSignatureWithPublicKey`(kotlinCallbackInterface: Signer, argsData: Pointer, argsLen: Int, outBuf: RustBufferByReference): Int {
        val argsBuf = argsData.getByteBuffer(0, argsLen.toLong()).also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
        fun makeCall() : Int {
            val returnValue = kotlinCallbackInterface.`signToSignatureWithPublicKey`(
                FfiConverterTypeHash.read(argsBuf)
                
            )
            outBuf.setValue(FfiConverterTypeSignatureWithPublicKey.lowerIntoRustBuffer(returnValue))
            return UNIFFI_CALLBACK_SUCCESS
        }
        fun makeCallAndHandleError() : Int = makeCall()

        return makeCallAndHandleError()
    }
    
    @Suppress("UNUSED_PARAMETER")
    private fun `invokePublicKey`(kotlinCallbackInterface: Signer, argsData: Pointer, argsLen: Int, outBuf: RustBufferByReference): Int {
        fun makeCall() : Int {
            val returnValue = kotlinCallbackInterface.`publicKey`(
            )
            outBuf.setValue(FfiConverterTypePublicKey.lowerIntoRustBuffer(returnValue))
            return UNIFFI_CALLBACK_SUCCESS
        }
        fun makeCallAndHandleError() : Int = makeCall()

        return makeCallAndHandleError()
    }
    
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
public object FfiConverterTypeSigner: FfiConverterCallbackInterface<Signer>(
    foreignCallback = ForeignCallbackTypeSigner()
) {
    override fun register(lib: _UniFFILib) {
        rustCall() { status ->
            lib.uniffi_radix_engine_toolkit_uniffi_fn_init_callback_signer(this.foreignCallback, status)
        }
    }
}




public object FfiConverterOptionalUInt: FfiConverterRustBuffer<UInt?> {
    override fun read(buf: ByteBuffer): UInt? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterUInt.read(buf)
    }

    override fun allocationSize(value: UInt?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterUInt.allocationSize(value)
        }
    }

    override fun write(value: UInt?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterUInt.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeAccessRule: FfiConverterRustBuffer<AccessRule?> {
    override fun read(buf: ByteBuffer): AccessRule? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeAccessRule.read(buf)
    }

    override fun allocationSize(value: AccessRule?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeAccessRule.allocationSize(value)
        }
    }

    override fun write(value: AccessRule?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeAccessRule.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeDecimal: FfiConverterRustBuffer<Decimal?> {
    override fun read(buf: ByteBuffer): Decimal? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeDecimal.read(buf)
    }

    override fun allocationSize(value: Decimal?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeDecimal.allocationSize(value)
        }
    }

    override fun write(value: Decimal?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeDecimal.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypePreciseDecimal: FfiConverterRustBuffer<PreciseDecimal?> {
    override fun read(buf: ByteBuffer): PreciseDecimal? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePreciseDecimal.read(buf)
    }

    override fun allocationSize(value: PreciseDecimal?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypePreciseDecimal.allocationSize(value)
        }
    }

    override fun write(value: PreciseDecimal?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePreciseDecimal.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeLockFeeModification: FfiConverterRustBuffer<LockFeeModification?> {
    override fun read(buf: ByteBuffer): LockFeeModification? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeLockFeeModification.read(buf)
    }

    override fun allocationSize(value: LockFeeModification?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeLockFeeModification.allocationSize(value)
        }
    }

    override fun write(value: LockFeeModification?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeLockFeeModification.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeManifestBuilderAddressReservation: FfiConverterRustBuffer<ManifestBuilderAddressReservation?> {
    override fun read(buf: ByteBuffer): ManifestBuilderAddressReservation? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeManifestBuilderAddressReservation.read(buf)
    }

    override fun allocationSize(value: ManifestBuilderAddressReservation?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeManifestBuilderAddressReservation.allocationSize(value)
        }
    }

    override fun write(value: ManifestBuilderAddressReservation?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeManifestBuilderAddressReservation.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeResourceManagerRole: FfiConverterRustBuffer<ResourceManagerRole?> {
    override fun read(buf: ByteBuffer): ResourceManagerRole? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeResourceManagerRole.read(buf)
    }

    override fun allocationSize(value: ResourceManagerRole?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeResourceManagerRole.allocationSize(value)
        }
    }

    override fun write(value: ResourceManagerRole?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeResourceManagerRole.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeSchema: FfiConverterRustBuffer<Schema?> {
    override fun read(buf: ByteBuffer): Schema? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeSchema.read(buf)
    }

    override fun allocationSize(value: Schema?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeSchema.allocationSize(value)
        }
    }

    override fun write(value: Schema?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeSchema.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeTransferTransactionType: FfiConverterRustBuffer<TransferTransactionType?> {
    override fun read(buf: ByteBuffer): TransferTransactionType? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeTransferTransactionType.read(buf)
    }

    override fun allocationSize(value: TransferTransactionType?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeTransferTransactionType.allocationSize(value)
        }
    }

    override fun write(value: TransferTransactionType?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeTransferTransactionType.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeMetadataValue: FfiConverterRustBuffer<MetadataValue?> {
    override fun read(buf: ByteBuffer): MetadataValue? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeMetadataValue.read(buf)
    }

    override fun allocationSize(value: MetadataValue?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeMetadataValue.allocationSize(value)
        }
    }

    override fun write(value: MetadataValue?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeMetadataValue.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeResourceOrNonFungible: FfiConverterRustBuffer<ResourceOrNonFungible?> {
    override fun read(buf: ByteBuffer): ResourceOrNonFungible? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeResourceOrNonFungible.read(buf)
    }

    override fun allocationSize(value: ResourceOrNonFungible?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeResourceOrNonFungible.allocationSize(value)
        }
    }

    override fun write(value: ResourceOrNonFungible?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeResourceOrNonFungible.write(value, buf)
        }
    }
}




public object FfiConverterSequenceUByte: FfiConverterRustBuffer<List<UByte>> {
    override fun read(buf: ByteBuffer): List<UByte> {
        val len = buf.getInt()
        return List<UByte>(len) {
            FfiConverterUByte.read(buf)
        }
    }

    override fun allocationSize(value: List<UByte>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterUByte.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<UByte>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterUByte.write(it, buf)
        }
    }
}




public object FfiConverterSequenceUInt: FfiConverterRustBuffer<List<UInt>> {
    override fun read(buf: ByteBuffer): List<UInt> {
        val len = buf.getInt()
        return List<UInt>(len) {
            FfiConverterUInt.read(buf)
        }
    }

    override fun allocationSize(value: List<UInt>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterUInt.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<UInt>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterUInt.write(it, buf)
        }
    }
}




public object FfiConverterSequenceInt: FfiConverterRustBuffer<List<Int>> {
    override fun read(buf: ByteBuffer): List<Int> {
        val len = buf.getInt()
        return List<Int>(len) {
            FfiConverterInt.read(buf)
        }
    }

    override fun allocationSize(value: List<Int>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterInt.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Int>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterInt.write(it, buf)
        }
    }
}




public object FfiConverterSequenceULong: FfiConverterRustBuffer<List<ULong>> {
    override fun read(buf: ByteBuffer): List<ULong> {
        val len = buf.getInt()
        return List<ULong>(len) {
            FfiConverterULong.read(buf)
        }
    }

    override fun allocationSize(value: List<ULong>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterULong.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ULong>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterULong.write(it, buf)
        }
    }
}




public object FfiConverterSequenceLong: FfiConverterRustBuffer<List<Long>> {
    override fun read(buf: ByteBuffer): List<Long> {
        val len = buf.getInt()
        return List<Long>(len) {
            FfiConverterLong.read(buf)
        }
    }

    override fun allocationSize(value: List<Long>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterLong.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Long>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterLong.write(it, buf)
        }
    }
}




public object FfiConverterSequenceBoolean: FfiConverterRustBuffer<List<Boolean>> {
    override fun read(buf: ByteBuffer): List<Boolean> {
        val len = buf.getInt()
        return List<Boolean>(len) {
            FfiConverterBoolean.read(buf)
        }
    }

    override fun allocationSize(value: List<Boolean>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterBoolean.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Boolean>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterBoolean.write(it, buf)
        }
    }
}




public object FfiConverterSequenceString: FfiConverterRustBuffer<List<String>> {
    override fun read(buf: ByteBuffer): List<String> {
        val len = buf.getInt()
        return List<String>(len) {
            FfiConverterString.read(buf)
        }
    }

    override fun allocationSize(value: List<String>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterString.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<String>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterString.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeAddress: FfiConverterRustBuffer<List<Address>> {
    override fun read(buf: ByteBuffer): List<Address> {
        val len = buf.getInt()
        return List<Address>(len) {
            FfiConverterTypeAddress.read(buf)
        }
    }

    override fun allocationSize(value: List<Address>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeAddress.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Address>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeAddress.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeDecimal: FfiConverterRustBuffer<List<Decimal>> {
    override fun read(buf: ByteBuffer): List<Decimal> {
        val len = buf.getInt()
        return List<Decimal>(len) {
            FfiConverterTypeDecimal.read(buf)
        }
    }

    override fun allocationSize(value: List<Decimal>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeDecimal.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Decimal>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeDecimal.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeNonFungibleGlobalId: FfiConverterRustBuffer<List<NonFungibleGlobalId>> {
    override fun read(buf: ByteBuffer): List<NonFungibleGlobalId> {
        val len = buf.getInt()
        return List<NonFungibleGlobalId>(len) {
            FfiConverterTypeNonFungibleGlobalId.read(buf)
        }
    }

    override fun allocationSize(value: List<NonFungibleGlobalId>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeNonFungibleGlobalId.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<NonFungibleGlobalId>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeNonFungibleGlobalId.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeClaimStakeInformation: FfiConverterRustBuffer<List<ClaimStakeInformation>> {
    override fun read(buf: ByteBuffer): List<ClaimStakeInformation> {
        val len = buf.getInt()
        return List<ClaimStakeInformation>(len) {
            FfiConverterTypeClaimStakeInformation.read(buf)
        }
    }

    override fun allocationSize(value: List<ClaimStakeInformation>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeClaimStakeInformation.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ClaimStakeInformation>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeClaimStakeInformation.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeIndexedAssertion: FfiConverterRustBuffer<List<IndexedAssertion>> {
    override fun read(buf: ByteBuffer): List<IndexedAssertion> {
        val len = buf.getInt()
        return List<IndexedAssertion>(len) {
            FfiConverterTypeIndexedAssertion.read(buf)
        }
    }

    override fun allocationSize(value: List<IndexedAssertion>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeIndexedAssertion.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<IndexedAssertion>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeIndexedAssertion.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeManifestBuilderMapEntry: FfiConverterRustBuffer<List<ManifestBuilderMapEntry>> {
    override fun read(buf: ByteBuffer): List<ManifestBuilderMapEntry> {
        val len = buf.getInt()
        return List<ManifestBuilderMapEntry>(len) {
            FfiConverterTypeManifestBuilderMapEntry.read(buf)
        }
    }

    override fun allocationSize(value: List<ManifestBuilderMapEntry>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeManifestBuilderMapEntry.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ManifestBuilderMapEntry>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeManifestBuilderMapEntry.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeMapEntry: FfiConverterRustBuffer<List<MapEntry>> {
    override fun read(buf: ByteBuffer): List<MapEntry> {
        val len = buf.getInt()
        return List<MapEntry>(len) {
            FfiConverterTypeMapEntry.read(buf)
        }
    }

    override fun allocationSize(value: List<MapEntry>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeMapEntry.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<MapEntry>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeMapEntry.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeStakeInformation: FfiConverterRustBuffer<List<StakeInformation>> {
    override fun read(buf: ByteBuffer): List<StakeInformation> {
        val len = buf.getInt()
        return List<StakeInformation>(len) {
            FfiConverterTypeStakeInformation.read(buf)
        }
    }

    override fun allocationSize(value: List<StakeInformation>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeStakeInformation.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<StakeInformation>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeStakeInformation.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeUnstakeInformation: FfiConverterRustBuffer<List<UnstakeInformation>> {
    override fun read(buf: ByteBuffer): List<UnstakeInformation> {
        val len = buf.getInt()
        return List<UnstakeInformation>(len) {
            FfiConverterTypeUnstakeInformation.read(buf)
        }
    }

    override fun allocationSize(value: List<UnstakeInformation>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeUnstakeInformation.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<UnstakeInformation>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeUnstakeInformation.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeEntityType: FfiConverterRustBuffer<List<EntityType>> {
    override fun read(buf: ByteBuffer): List<EntityType> {
        val len = buf.getInt()
        return List<EntityType>(len) {
            FfiConverterTypeEntityType.read(buf)
        }
    }

    override fun allocationSize(value: List<EntityType>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeEntityType.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<EntityType>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeEntityType.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeInstruction: FfiConverterRustBuffer<List<Instruction>> {
    override fun read(buf: ByteBuffer): List<Instruction> {
        val len = buf.getInt()
        return List<Instruction>(len) {
            FfiConverterTypeInstruction.read(buf)
        }
    }

    override fun allocationSize(value: List<Instruction>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeInstruction.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Instruction>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeInstruction.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeManifestBuilderValue: FfiConverterRustBuffer<List<ManifestBuilderValue>> {
    override fun read(buf: ByteBuffer): List<ManifestBuilderValue> {
        val len = buf.getInt()
        return List<ManifestBuilderValue>(len) {
            FfiConverterTypeManifestBuilderValue.read(buf)
        }
    }

    override fun allocationSize(value: List<ManifestBuilderValue>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeManifestBuilderValue.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ManifestBuilderValue>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeManifestBuilderValue.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeManifestValue: FfiConverterRustBuffer<List<ManifestValue>> {
    override fun read(buf: ByteBuffer): List<ManifestValue> {
        val len = buf.getInt()
        return List<ManifestValue>(len) {
            FfiConverterTypeManifestValue.read(buf)
        }
    }

    override fun allocationSize(value: List<ManifestValue>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeManifestValue.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ManifestValue>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeManifestValue.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeNonFungibleLocalId: FfiConverterRustBuffer<List<NonFungibleLocalId>> {
    override fun read(buf: ByteBuffer): List<NonFungibleLocalId> {
        val len = buf.getInt()
        return List<NonFungibleLocalId>(len) {
            FfiConverterTypeNonFungibleLocalId.read(buf)
        }
    }

    override fun allocationSize(value: List<NonFungibleLocalId>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeNonFungibleLocalId.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<NonFungibleLocalId>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeNonFungibleLocalId.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypePublicKey: FfiConverterRustBuffer<List<PublicKey>> {
    override fun read(buf: ByteBuffer): List<PublicKey> {
        val len = buf.getInt()
        return List<PublicKey>(len) {
            FfiConverterTypePublicKey.read(buf)
        }
    }

    override fun allocationSize(value: List<PublicKey>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypePublicKey.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PublicKey>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypePublicKey.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypePublicKeyHash: FfiConverterRustBuffer<List<PublicKeyHash>> {
    override fun read(buf: ByteBuffer): List<PublicKeyHash> {
        val len = buf.getInt()
        return List<PublicKeyHash>(len) {
            FfiConverterTypePublicKeyHash.read(buf)
        }
    }

    override fun allocationSize(value: List<PublicKeyHash>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypePublicKeyHash.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<PublicKeyHash>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypePublicKeyHash.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeReservedInstruction: FfiConverterRustBuffer<List<ReservedInstruction>> {
    override fun read(buf: ByteBuffer): List<ReservedInstruction> {
        val len = buf.getInt()
        return List<ReservedInstruction>(len) {
            FfiConverterTypeReservedInstruction.read(buf)
        }
    }

    override fun allocationSize(value: List<ReservedInstruction>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeReservedInstruction.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ReservedInstruction>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeReservedInstruction.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeResourceOrNonFungible: FfiConverterRustBuffer<List<ResourceOrNonFungible>> {
    override fun read(buf: ByteBuffer): List<ResourceOrNonFungible> {
        val len = buf.getInt()
        return List<ResourceOrNonFungible>(len) {
            FfiConverterTypeResourceOrNonFungible.read(buf)
        }
    }

    override fun allocationSize(value: List<ResourceOrNonFungible>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeResourceOrNonFungible.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ResourceOrNonFungible>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeResourceOrNonFungible.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeResourceTracker: FfiConverterRustBuffer<List<ResourceTracker>> {
    override fun read(buf: ByteBuffer): List<ResourceTracker> {
        val len = buf.getInt()
        return List<ResourceTracker>(len) {
            FfiConverterTypeResourceTracker.read(buf)
        }
    }

    override fun allocationSize(value: List<ResourceTracker>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeResourceTracker.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ResourceTracker>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeResourceTracker.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeSignatureWithPublicKey: FfiConverterRustBuffer<List<SignatureWithPublicKey>> {
    override fun read(buf: ByteBuffer): List<SignatureWithPublicKey> {
        val len = buf.getInt()
        return List<SignatureWithPublicKey>(len) {
            FfiConverterTypeSignatureWithPublicKey.read(buf)
        }
    }

    override fun allocationSize(value: List<SignatureWithPublicKey>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeSignatureWithPublicKey.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<SignatureWithPublicKey>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeSignatureWithPublicKey.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeTransactionType: FfiConverterRustBuffer<List<TransactionType>> {
    override fun read(buf: ByteBuffer): List<TransactionType> {
        val len = buf.getInt()
        return List<TransactionType>(len) {
            FfiConverterTypeTransactionType.read(buf)
        }
    }

    override fun allocationSize(value: List<TransactionType>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeTransactionType.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<TransactionType>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeTransactionType.write(it, buf)
        }
    }
}




public object FfiConverterSequenceSequenceUByte: FfiConverterRustBuffer<List<List<UByte>>> {
    override fun read(buf: ByteBuffer): List<List<UByte>> {
        val len = buf.getInt()
        return List<List<UByte>>(len) {
            FfiConverterSequenceUByte.read(buf)
        }
    }

    override fun allocationSize(value: List<List<UByte>>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterSequenceUByte.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<List<UByte>>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterSequenceUByte.write(it, buf)
        }
    }
}



public object FfiConverterMapStringTypeDecimal: FfiConverterRustBuffer<Map<String, Decimal>> {
    override fun read(buf: ByteBuffer): Map<String, Decimal> {
        // TODO: Once Kotlin's `buildMap` API is stabilized we should use it here.
        val items : MutableMap<String, Decimal> = mutableMapOf()
        val len = buf.getInt()
        repeat(len) {
            val k = FfiConverterString.read(buf)
            val v = FfiConverterTypeDecimal.read(buf)
            items[k] = v
        }
        return items
    }

    override fun allocationSize(value: Map<String, Decimal>): Int {
        val spaceForMapSize = 4
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterTypeDecimal.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<String, Decimal>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterTypeDecimal.write(v, buf)
        }
    }
}



public object FfiConverterMapStringTypeAuthorizedDepositorsChanges: FfiConverterRustBuffer<Map<String, AuthorizedDepositorsChanges>> {
    override fun read(buf: ByteBuffer): Map<String, AuthorizedDepositorsChanges> {
        // TODO: Once Kotlin's `buildMap` API is stabilized we should use it here.
        val items : MutableMap<String, AuthorizedDepositorsChanges> = mutableMapOf()
        val len = buf.getInt()
        repeat(len) {
            val k = FfiConverterString.read(buf)
            val v = FfiConverterTypeAuthorizedDepositorsChanges.read(buf)
            items[k] = v
        }
        return items
    }

    override fun allocationSize(value: Map<String, AuthorizedDepositorsChanges>): Int {
        val spaceForMapSize = 4
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterTypeAuthorizedDepositorsChanges.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<String, AuthorizedDepositorsChanges>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterTypeAuthorizedDepositorsChanges.write(v, buf)
        }
    }
}



public object FfiConverterMapStringTypeMetadataInitEntry: FfiConverterRustBuffer<Map<String, MetadataInitEntry>> {
    override fun read(buf: ByteBuffer): Map<String, MetadataInitEntry> {
        // TODO: Once Kotlin's `buildMap` API is stabilized we should use it here.
        val items : MutableMap<String, MetadataInitEntry> = mutableMapOf()
        val len = buf.getInt()
        repeat(len) {
            val k = FfiConverterString.read(buf)
            val v = FfiConverterTypeMetadataInitEntry.read(buf)
            items[k] = v
        }
        return items
    }

    override fun allocationSize(value: Map<String, MetadataInitEntry>): Int {
        val spaceForMapSize = 4
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterTypeMetadataInitEntry.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<String, MetadataInitEntry>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterTypeMetadataInitEntry.write(v, buf)
        }
    }
}



public object FfiConverterMapStringTypeValidatorInfo: FfiConverterRustBuffer<Map<String, ValidatorInfo>> {
    override fun read(buf: ByteBuffer): Map<String, ValidatorInfo> {
        // TODO: Once Kotlin's `buildMap` API is stabilized we should use it here.
        val items : MutableMap<String, ValidatorInfo> = mutableMapOf()
        val len = buf.getInt()
        repeat(len) {
            val k = FfiConverterString.read(buf)
            val v = FfiConverterTypeValidatorInfo.read(buf)
            items[k] = v
        }
        return items
    }

    override fun allocationSize(value: Map<String, ValidatorInfo>): Int {
        val spaceForMapSize = 4
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterTypeValidatorInfo.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<String, ValidatorInfo>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterTypeValidatorInfo.write(v, buf)
        }
    }
}



public object FfiConverterMapStringTypeAccountDefaultDepositRule: FfiConverterRustBuffer<Map<String, AccountDefaultDepositRule>> {
    override fun read(buf: ByteBuffer): Map<String, AccountDefaultDepositRule> {
        // TODO: Once Kotlin's `buildMap` API is stabilized we should use it here.
        val items : MutableMap<String, AccountDefaultDepositRule> = mutableMapOf()
        val len = buf.getInt()
        repeat(len) {
            val k = FfiConverterString.read(buf)
            val v = FfiConverterTypeAccountDefaultDepositRule.read(buf)
            items[k] = v
        }
        return items
    }

    override fun allocationSize(value: Map<String, AccountDefaultDepositRule>): Int {
        val spaceForMapSize = 4
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterTypeAccountDefaultDepositRule.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<String, AccountDefaultDepositRule>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterTypeAccountDefaultDepositRule.write(v, buf)
        }
    }
}



public object FfiConverterMapStringTypeResourcePreferenceAction: FfiConverterRustBuffer<Map<String, ResourcePreferenceAction>> {
    override fun read(buf: ByteBuffer): Map<String, ResourcePreferenceAction> {
        // TODO: Once Kotlin's `buildMap` API is stabilized we should use it here.
        val items : MutableMap<String, ResourcePreferenceAction> = mutableMapOf()
        val len = buf.getInt()
        repeat(len) {
            val k = FfiConverterString.read(buf)
            val v = FfiConverterTypeResourcePreferenceAction.read(buf)
            items[k] = v
        }
        return items
    }

    override fun allocationSize(value: Map<String, ResourcePreferenceAction>): Int {
        val spaceForMapSize = 4
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterTypeResourcePreferenceAction.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<String, ResourcePreferenceAction>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterTypeResourcePreferenceAction.write(v, buf)
        }
    }
}



public object FfiConverterMapStringTypeResources: FfiConverterRustBuffer<Map<String, Resources>> {
    override fun read(buf: ByteBuffer): Map<String, Resources> {
        // TODO: Once Kotlin's `buildMap` API is stabilized we should use it here.
        val items : MutableMap<String, Resources> = mutableMapOf()
        val len = buf.getInt()
        repeat(len) {
            val k = FfiConverterString.read(buf)
            val v = FfiConverterTypeResources.read(buf)
            items[k] = v
        }
        return items
    }

    override fun allocationSize(value: Map<String, Resources>): Int {
        val spaceForMapSize = 4
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterTypeResources.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<String, Resources>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterTypeResources.write(v, buf)
        }
    }
}



public object FfiConverterMapStringOptionalTypeAccessRule: FfiConverterRustBuffer<Map<String, AccessRule?>> {
    override fun read(buf: ByteBuffer): Map<String, AccessRule?> {
        // TODO: Once Kotlin's `buildMap` API is stabilized we should use it here.
        val items : MutableMap<String, AccessRule?> = mutableMapOf()
        val len = buf.getInt()
        repeat(len) {
            val k = FfiConverterString.read(buf)
            val v = FfiConverterOptionalTypeAccessRule.read(buf)
            items[k] = v
        }
        return items
    }

    override fun allocationSize(value: Map<String, AccessRule?>): Int {
        val spaceForMapSize = 4
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterOptionalTypeAccessRule.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<String, AccessRule?>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterOptionalTypeAccessRule.write(v, buf)
        }
    }
}



public object FfiConverterMapStringOptionalTypeMetadataValue: FfiConverterRustBuffer<Map<String, MetadataValue?>> {
    override fun read(buf: ByteBuffer): Map<String, MetadataValue?> {
        // TODO: Once Kotlin's `buildMap` API is stabilized we should use it here.
        val items : MutableMap<String, MetadataValue?> = mutableMapOf()
        val len = buf.getInt()
        repeat(len) {
            val k = FfiConverterString.read(buf)
            val v = FfiConverterOptionalTypeMetadataValue.read(buf)
            items[k] = v
        }
        return items
    }

    override fun allocationSize(value: Map<String, MetadataValue?>): Int {
        val spaceForMapSize = 4
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterOptionalTypeMetadataValue.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<String, MetadataValue?>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterOptionalTypeMetadataValue.write(v, buf)
        }
    }
}



public object FfiConverterMapStringSequenceTypeResourceTracker: FfiConverterRustBuffer<Map<String, List<ResourceTracker>>> {
    override fun read(buf: ByteBuffer): Map<String, List<ResourceTracker>> {
        // TODO: Once Kotlin's `buildMap` API is stabilized we should use it here.
        val items : MutableMap<String, List<ResourceTracker>> = mutableMapOf()
        val len = buf.getInt()
        repeat(len) {
            val k = FfiConverterString.read(buf)
            val v = FfiConverterSequenceTypeResourceTracker.read(buf)
            items[k] = v
        }
        return items
    }

    override fun allocationSize(value: Map<String, List<ResourceTracker>>): Int {
        val spaceForMapSize = 4
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterSequenceTypeResourceTracker.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<String, List<ResourceTracker>>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterSequenceTypeResourceTracker.write(v, buf)
        }
    }
}



public object FfiConverterMapStringMapStringTypeResourcePreferenceAction: FfiConverterRustBuffer<Map<String, Map<String, ResourcePreferenceAction>>> {
    override fun read(buf: ByteBuffer): Map<String, Map<String, ResourcePreferenceAction>> {
        // TODO: Once Kotlin's `buildMap` API is stabilized we should use it here.
        val items : MutableMap<String, Map<String, ResourcePreferenceAction>> = mutableMapOf()
        val len = buf.getInt()
        repeat(len) {
            val k = FfiConverterString.read(buf)
            val v = FfiConverterMapStringTypeResourcePreferenceAction.read(buf)
            items[k] = v
        }
        return items
    }

    override fun allocationSize(value: Map<String, Map<String, ResourcePreferenceAction>>): Int {
        val spaceForMapSize = 4
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterMapStringTypeResourcePreferenceAction.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<String, Map<String, ResourcePreferenceAction>>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterMapStringTypeResourcePreferenceAction.write(v, buf)
        }
    }
}



public object FfiConverterMapStringMapStringTypeResources: FfiConverterRustBuffer<Map<String, Map<String, Resources>>> {
    override fun read(buf: ByteBuffer): Map<String, Map<String, Resources>> {
        // TODO: Once Kotlin's `buildMap` API is stabilized we should use it here.
        val items : MutableMap<String, Map<String, Resources>> = mutableMapOf()
        val len = buf.getInt()
        repeat(len) {
            val k = FfiConverterString.read(buf)
            val v = FfiConverterMapStringTypeResources.read(buf)
            items[k] = v
        }
        return items
    }

    override fun allocationSize(value: Map<String, Map<String, Resources>>): Int {
        val spaceForMapSize = 4
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterMapStringTypeResources.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<String, Map<String, Resources>>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterMapStringTypeResources.write(v, buf)
        }
    }
}



public object FfiConverterMapStringMapStringOptionalTypeMetadataValue: FfiConverterRustBuffer<Map<String, Map<String, MetadataValue?>>> {
    override fun read(buf: ByteBuffer): Map<String, Map<String, MetadataValue?>> {
        // TODO: Once Kotlin's `buildMap` API is stabilized we should use it here.
        val items : MutableMap<String, Map<String, MetadataValue?>> = mutableMapOf()
        val len = buf.getInt()
        repeat(len) {
            val k = FfiConverterString.read(buf)
            val v = FfiConverterMapStringOptionalTypeMetadataValue.read(buf)
            items[k] = v
        }
        return items
    }

    override fun allocationSize(value: Map<String, Map<String, MetadataValue?>>): Int {
        val spaceForMapSize = 4
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterMapStringOptionalTypeMetadataValue.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<String, Map<String, MetadataValue?>>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterMapStringOptionalTypeMetadataValue.write(v, buf)
        }
    }
}



public object FfiConverterMapStringMapTypeNonFungibleLocalIdSequenceUByte: FfiConverterRustBuffer<Map<String, Map<NonFungibleLocalId, List<UByte>>>> {
    override fun read(buf: ByteBuffer): Map<String, Map<NonFungibleLocalId, List<UByte>>> {
        // TODO: Once Kotlin's `buildMap` API is stabilized we should use it here.
        val items : MutableMap<String, Map<NonFungibleLocalId, List<UByte>>> = mutableMapOf()
        val len = buf.getInt()
        repeat(len) {
            val k = FfiConverterString.read(buf)
            val v = FfiConverterMapTypeNonFungibleLocalIdSequenceUByte.read(buf)
            items[k] = v
        }
        return items
    }

    override fun allocationSize(value: Map<String, Map<NonFungibleLocalId, List<UByte>>>): Int {
        val spaceForMapSize = 4
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterString.allocationSize(k) +
            FfiConverterMapTypeNonFungibleLocalIdSequenceUByte.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<String, Map<NonFungibleLocalId, List<UByte>>>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterMapTypeNonFungibleLocalIdSequenceUByte.write(v, buf)
        }
    }
}



public object FfiConverterMapTypeCurveTypeTypeDecryptorsByCurve: FfiConverterRustBuffer<Map<CurveType, DecryptorsByCurve>> {
    override fun read(buf: ByteBuffer): Map<CurveType, DecryptorsByCurve> {
        // TODO: Once Kotlin's `buildMap` API is stabilized we should use it here.
        val items : MutableMap<CurveType, DecryptorsByCurve> = mutableMapOf()
        val len = buf.getInt()
        repeat(len) {
            val k = FfiConverterTypeCurveType.read(buf)
            val v = FfiConverterTypeDecryptorsByCurve.read(buf)
            items[k] = v
        }
        return items
    }

    override fun allocationSize(value: Map<CurveType, DecryptorsByCurve>): Int {
        val spaceForMapSize = 4
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterTypeCurveType.allocationSize(k) +
            FfiConverterTypeDecryptorsByCurve.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<CurveType, DecryptorsByCurve>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterTypeCurveType.write(k, buf)
            FfiConverterTypeDecryptorsByCurve.write(v, buf)
        }
    }
}



public object FfiConverterMapTypeEntityTypeSequenceTypeAddress: FfiConverterRustBuffer<Map<EntityType, List<Address>>> {
    override fun read(buf: ByteBuffer): Map<EntityType, List<Address>> {
        // TODO: Once Kotlin's `buildMap` API is stabilized we should use it here.
        val items : MutableMap<EntityType, List<Address>> = mutableMapOf()
        val len = buf.getInt()
        repeat(len) {
            val k = FfiConverterTypeEntityType.read(buf)
            val v = FfiConverterSequenceTypeAddress.read(buf)
            items[k] = v
        }
        return items
    }

    override fun allocationSize(value: Map<EntityType, List<Address>>): Int {
        val spaceForMapSize = 4
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterTypeEntityType.allocationSize(k) +
            FfiConverterSequenceTypeAddress.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<EntityType, List<Address>>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterTypeEntityType.write(k, buf)
            FfiConverterSequenceTypeAddress.write(v, buf)
        }
    }
}



public object FfiConverterMapTypeNonFungibleLocalIdSequenceUByte: FfiConverterRustBuffer<Map<NonFungibleLocalId, List<UByte>>> {
    override fun read(buf: ByteBuffer): Map<NonFungibleLocalId, List<UByte>> {
        // TODO: Once Kotlin's `buildMap` API is stabilized we should use it here.
        val items : MutableMap<NonFungibleLocalId, List<UByte>> = mutableMapOf()
        val len = buf.getInt()
        repeat(len) {
            val k = FfiConverterTypeNonFungibleLocalId.read(buf)
            val v = FfiConverterSequenceUByte.read(buf)
            items[k] = v
        }
        return items
    }

    override fun allocationSize(value: Map<NonFungibleLocalId, List<UByte>>): Int {
        val spaceForMapSize = 4
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterTypeNonFungibleLocalId.allocationSize(k) +
            FfiConverterSequenceUByte.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<NonFungibleLocalId, List<UByte>>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterTypeNonFungibleLocalId.write(k, buf)
            FfiConverterSequenceUByte.write(v, buf)
        }
    }
}



public object FfiConverterMapSequenceUByteSequenceUByte: FfiConverterRustBuffer<Map<List<UByte>, List<UByte>>> {
    override fun read(buf: ByteBuffer): Map<List<UByte>, List<UByte>> {
        // TODO: Once Kotlin's `buildMap` API is stabilized we should use it here.
        val items : MutableMap<List<UByte>, List<UByte>> = mutableMapOf()
        val len = buf.getInt()
        repeat(len) {
            val k = FfiConverterSequenceUByte.read(buf)
            val v = FfiConverterSequenceUByte.read(buf)
            items[k] = v
        }
        return items
    }

    override fun allocationSize(value: Map<List<UByte>, List<UByte>>): Int {
        val spaceForMapSize = 4
        val spaceForChildren = value.map { (k, v) ->
            FfiConverterSequenceUByte.allocationSize(k) +
            FfiConverterSequenceUByte.allocationSize(v)
        }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(value: Map<List<UByte>, List<UByte>>, buf: ByteBuffer) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterSequenceUByte.write(k, buf)
            FfiConverterSequenceUByte.write(v, buf)
        }
    }
}

fun `buildInformation`(): BuildInformation {
    return FfiConverterTypeBuildInformation.lift(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_build_information(_status)
})
}

@Throws(RadixEngineToolkitException::class)

fun `deriveOlympiaAccountAddressFromPublicKey`(`publicKey`: PublicKey, `olympiaNetwork`: OlympiaNetwork): OlympiaAddress {
    return FfiConverterTypeOlympiaAddress.lift(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_olympia_account_address_from_public_key(FfiConverterTypePublicKey.lower(`publicKey`),FfiConverterTypeOlympiaNetwork.lower(`olympiaNetwork`),_status)
})
}

@Throws(RadixEngineToolkitException::class)

fun `derivePublicKeyFromOlympiaAccountAddress`(`olympiaResourceAddress`: OlympiaAddress): PublicKey {
    return FfiConverterTypePublicKey.lift(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_public_key_from_olympia_account_address(FfiConverterTypeOlympiaAddress.lower(`olympiaResourceAddress`),_status)
})
}

@Throws(RadixEngineToolkitException::class)

fun `deriveResourceAddressFromOlympiaResourceAddress`(`olympiaResourceAddress`: OlympiaAddress, `networkId`: UByte): Address {
    return FfiConverterTypeAddress.lift(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_resource_address_from_olympia_resource_address(FfiConverterTypeOlympiaAddress.lower(`olympiaResourceAddress`),FfiConverterUByte.lower(`networkId`),_status)
})
}

@Throws(RadixEngineToolkitException::class)

fun `deriveVirtualAccountAddressFromOlympiaAccountAddress`(`olympiaAccountAddress`: OlympiaAddress, `networkId`: UByte): Address {
    return FfiConverterTypeAddress.lift(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_account_address_from_olympia_account_address(FfiConverterTypeOlympiaAddress.lower(`olympiaAccountAddress`),FfiConverterUByte.lower(`networkId`),_status)
})
}

@Throws(RadixEngineToolkitException::class)

fun `deriveVirtualAccountAddressFromPublicKey`(`publicKey`: PublicKey, `networkId`: UByte): Address {
    return FfiConverterTypeAddress.lift(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_account_address_from_public_key(FfiConverterTypePublicKey.lower(`publicKey`),FfiConverterUByte.lower(`networkId`),_status)
})
}

@Throws(RadixEngineToolkitException::class)

fun `deriveVirtualIdentityAddressFromPublicKey`(`publicKey`: PublicKey, `networkId`: UByte): Address {
    return FfiConverterTypeAddress.lift(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_identity_address_from_public_key(FfiConverterTypePublicKey.lower(`publicKey`),FfiConverterUByte.lower(`networkId`),_status)
})
}

@Throws(RadixEngineToolkitException::class)

fun `deriveVirtualSignatureNonFungibleGlobalIdFromPublicKey`(`publicKey`: PublicKey, `networkId`: UByte): NonFungibleGlobalId {
    return FfiConverterTypeNonFungibleGlobalId.lift(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_signature_non_fungible_global_id_from_public_key(FfiConverterTypePublicKey.lower(`publicKey`),FfiConverterUByte.lower(`networkId`),_status)
})
}


fun `hash`(`data`: List<UByte>): Hash {
    return FfiConverterTypeHash.lift(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_hash(FfiConverterSequenceUByte.lower(`data`),_status)
})
}


fun `knownAddresses`(`networkId`: UByte): KnownAddresses {
    return FfiConverterTypeKnownAddresses.lift(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_known_addresses(FfiConverterUByte.lower(`networkId`),_status)
})
}

@Throws(RadixEngineToolkitException::class)

fun `manifestSborDecodeToStringRepresentation`(`bytes`: List<UByte>, `representation`: ManifestSborStringRepresentation, `networkId`: UByte, `schema`: Schema?): String {
    return FfiConverterString.lift(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_manifest_sbor_decode_to_string_representation(FfiConverterSequenceUByte.lower(`bytes`),FfiConverterTypeManifestSborStringRepresentation.lower(`representation`),FfiConverterUByte.lower(`networkId`),FfiConverterOptionalTypeSchema.lower(`schema`),_status)
})
}

@Throws(RadixEngineToolkitException::class)

fun `metadataSborDecode`(`bytes`: List<UByte>, `networkId`: UByte): MetadataValue {
    return FfiConverterTypeMetadataValue.lift(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_metadata_sbor_decode(FfiConverterSequenceUByte.lower(`bytes`),FfiConverterUByte.lower(`networkId`),_status)
})
}

@Throws(RadixEngineToolkitException::class)

fun `metadataSborEncode`(`value`: MetadataValue): List<UByte> {
    return FfiConverterSequenceUByte.lift(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_metadata_sbor_encode(FfiConverterTypeMetadataValue.lower(`value`),_status)
})
}

@Throws(RadixEngineToolkitException::class)

fun `nonFungibleLocalIdAsStr`(`value`: NonFungibleLocalId): String {
    return FfiConverterString.lift(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_as_str(FfiConverterTypeNonFungibleLocalId.lower(`value`),_status)
})
}

@Throws(RadixEngineToolkitException::class)

fun `nonFungibleLocalIdFromStr`(`string`: String): NonFungibleLocalId {
    return FfiConverterTypeNonFungibleLocalId.lift(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_from_str(FfiConverterString.lower(`string`),_status)
})
}

@Throws(RadixEngineToolkitException::class)

fun `nonFungibleLocalIdSborDecode`(`bytes`: List<UByte>): NonFungibleLocalId {
    return FfiConverterTypeNonFungibleLocalId.lift(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_sbor_decode(FfiConverterSequenceUByte.lower(`bytes`),_status)
})
}

@Throws(RadixEngineToolkitException::class)

fun `nonFungibleLocalIdSborEncode`(`value`: NonFungibleLocalId): List<UByte> {
    return FfiConverterSequenceUByte.lift(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_sbor_encode(FfiConverterTypeNonFungibleLocalId.lower(`value`),_status)
})
}

@Throws(RadixEngineToolkitException::class)

fun `sborDecodeToStringRepresentation`(`bytes`: List<UByte>, `representation`: SerializationMode, `networkId`: UByte, `schema`: Schema?): String {
    return FfiConverterString.lift(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_string_representation(FfiConverterSequenceUByte.lower(`bytes`),FfiConverterTypeSerializationMode.lower(`representation`),FfiConverterUByte.lower(`networkId`),FfiConverterOptionalTypeSchema.lower(`schema`),_status)
})
}

@Throws(RadixEngineToolkitException::class)

fun `sborDecodeToTypedNativeEvent`(`eventTypeIdentifier`: EventTypeIdentifier, `eventData`: List<UByte>, `networkId`: UByte): TypedNativeEvent {
    return FfiConverterTypeTypedNativeEvent.lift(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_typed_native_event(FfiConverterTypeEventTypeIdentifier.lower(`eventTypeIdentifier`),FfiConverterSequenceUByte.lower(`eventData`),FfiConverterUByte.lower(`networkId`),_status)
})
}

@Throws(RadixEngineToolkitException::class)

fun `scryptoSborDecodeToStringRepresentation`(`bytes`: List<UByte>, `representation`: SerializationMode, `networkId`: UByte, `schema`: Schema?): String {
    return FfiConverterString.lift(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_scrypto_sbor_decode_to_string_representation(FfiConverterSequenceUByte.lower(`bytes`),FfiConverterTypeSerializationMode.lower(`representation`),FfiConverterUByte.lower(`networkId`),FfiConverterOptionalTypeSchema.lower(`schema`),_status)
})
}

@Throws(RadixEngineToolkitException::class)

fun `scryptoSborEncodeStringRepresentation`(`representation`: ScryptoSborString): List<UByte> {
    return FfiConverterSequenceUByte.lift(
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_scrypto_sbor_encode_string_representation(FfiConverterTypeScryptoSborString.lower(`representation`),_status)
})
}

@Throws(RadixEngineToolkitException::class)

fun `testPanic`(`message`: String) =
    
    rustCallWithError(RadixEngineToolkitException) { _status ->
    _UniFFILib.INSTANCE.uniffi_radix_engine_toolkit_uniffi_fn_func_test_panic(FfiConverterString.lower(`message`),_status)
}



