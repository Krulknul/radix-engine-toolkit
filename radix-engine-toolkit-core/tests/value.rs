// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at

//   http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

mod test_vectors;

use radix_engine_toolkit_core::{
    model::{Bech32Coder, Identifier, Value},
    traits::ValidateWithContext,
};
use scrypto::prelude::*;
pub use test_vectors::*;

#[test]
fn serialized_values_match_expected() {
    // Checking that the serialization of values matches
    for test_vector in VALUE_JSON_CONVERSION_TEST_VECTORS.iter() {
        // Act
        let expected_serialized_value: serde_json::Value =
            serde_json::from_str(&test_vector.json_representation)
                .expect("Failed to deserialize trusted value");
        let serialized_value =
            serde_json::to_value(&test_vector.value).expect("Failed to serialize trusted value");

        // Assert
        assert_eq!(expected_serialized_value, serialized_value);
    }
}

#[test]
fn deserialized_values_match_expected() {
    // Checking that the deserialization of values matches
    for test_vector in VALUE_JSON_CONVERSION_TEST_VECTORS.iter() {
        // Act
        let expected_value = &test_vector.value;
        let deserialized_value = serde_json::from_str(&test_vector.json_representation)
            .expect("Deserialization failed!");

        // Assert
        assert_eq!(*expected_value, deserialized_value)
    }
}

/// # Background
///
/// There are methods on the [Value] model to convert a [Value] to a
/// [radix_transaction::manifest::ast::Value]. This conversion requires some domain-specific
/// knowledge as to what the abstract syntax tree looks like.
///
/// As an example for a `ResourceAddress("some_address")` in the manifest we know that this is an
/// `AstValue::ResourceAddress` with a `AstValue::String` inside of it. Because of the
/// domain-knowledge requirement for this conversion, the transaction compiler could have a change
/// made to it which changes the expected structure of the AST. There would likely be no
/// compile-time errors as the AST uses an unstructured value model.
///
/// # Purpose
///
/// The purpose of this test is to check that the conversion of a [Value] to a
/// [radix_transaction::manifest::ast::Value] matches the abstract syntax tree that is generated by
/// the transaction compiler for an equivalent manifest string value.
#[test]
fn value_ast_conversions_match_that_produced_by_transaction_compiler() {
    // Arrange
    let bech32_coder = Bech32Coder::new(0xf2);

    // Testing that the Value -> AstValue conversion matches that obtained from parsing the manifest
    for test_vector in VALUE_AST_CONVERSIONS_TEST_VECTORS.iter() {
        let expected_ast_value = test_vector.manifest_representation_as_ast_value();

        // Act
        let ast_value = test_vector
            .value
            .to_ast_value(&bech32_coder)
            .expect("Value -> AstValue conversion of trusted value failed");

        // Assert
        assert_eq!(expected_ast_value, ast_value)
    }
}

#[test]
fn value_scrypto_value_conversion_match_that_produced_by_transaction_compiler() {
    // Arrange
    let bech32_coder = Bech32Coder::new(0xf2);

    for test_vector in VALUE_AST_CONVERSIONS_TEST_VECTORS.iter() {
        // This test will fail (as expected) for buckets and proofs with string identifiers. So,
        // we skip those tests
        if let Value::Bucket { ref identifier } = test_vector.value {
            if let Identifier::String(..) = identifier.0 {
                continue;
            }
        } else if let Value::Proof { ref identifier } = test_vector.value {
            if let Identifier::String(..) = identifier.0 {
                continue;
            }
        }

        let expected_scrypto_value =
            test_vector.manifest_representation_as_scrypto_value(&bech32_coder);

        // Act
        let scrypto_value = test_vector
            .value
            .to_scrypto_value()
            .expect("Failed to convert a trusted value to a scrypto value");

        // Assert
        assert_eq!(scrypto_value, expected_scrypto_value);
    }
}

#[test]
fn no_information_is_lost_when_converting_value_to_ast_value_and_back() {
    // Arrange
    let bech32_coder = Bech32Coder::new(0xf2);

    // Testing that the Value -> AstValue conversion matches that obtained from parsing the manifest
    for test_vector in VALUE_AST_CONVERSIONS_TEST_VECTORS.iter() {
        let expected_value = &test_vector.value;

        // Act
        let ast_value = Value::from_ast_value(
            &test_vector
                .value
                .to_ast_value(&bech32_coder)
                .expect("Value -> AstValue conversion of trusted value failed"),
            &bech32_coder,
        )
        .expect("AstValue -> Value for a trusted value failed");

        // Assert
        assert_eq!(*expected_value, ast_value)
    }
}

#[test]
fn no_information_is_lost_when_converting_value_to_scrypto_value_and_back() {
    // Arrange
    let bech32_coder = Bech32Coder::new(0xf2);

    // Testing that the Value -> AstValue conversion matches that obtained from parsing the manifest
    for test_vector in VALUE_AST_CONVERSIONS_TEST_VECTORS.iter() {
        // This test will fail (as expected) for buckets and proofs with string identifiers. So,
        // we skip those tests
        if let Value::Bucket { ref identifier } = test_vector.value {
            if let Identifier::String(..) = identifier.0 {
                continue;
            }
        } else if let Value::Proof { ref identifier } = test_vector.value {
            if let Identifier::String(..) = identifier.0 {
                continue;
            }
        } else if let Value::Bytes { .. } = test_vector.value {
            // TODO: Remove this. Currently we ignore this test because converting bytes to a
            // Scrypto value yields an Array<u8>. Converting an Array<u8> back to Value yields a
            // Array<u8>. So, converting back does not currently mean the same thing in manifest
            // land, but means the same thing in SBOR land.
            continue;
        }

        let expected_value = &test_vector.value;

        // Act
        let ast_value = Value::from_scrypto_value(
            &test_vector
                .value
                .to_scrypto_value()
                .expect("Value -> AstValue conversion of trusted value failed"),
            bech32_coder.network_id(),
        );

        // Assert
        assert_eq!(*expected_value, ast_value)
    }
}

#[test]
fn sbor_encoding_value_yields_expected_result() {
    // Arrange
    let bech32_coder = Bech32Coder::new(0xf2);

    // Testing that the Value -> AstValue conversion matches that obtained from parsing the manifest
    for test_vector in VALUE_AST_CONVERSIONS_TEST_VECTORS.iter() {
        // This test will fail (as expected) for buckets and proofs with string identifiers. So,
        // we skip those tests
        if let Value::Bucket { ref identifier } = test_vector.value {
            if let Identifier::String(..) = identifier.0 {
                continue;
            }
        } else if let Value::Proof { ref identifier } = test_vector.value {
            if let Identifier::String(..) = identifier.0 {
                continue;
            }
        }

        let expected_encoding =
            scrypto_encode(&test_vector.manifest_representation_as_scrypto_value(&bech32_coder))
                .unwrap();

        // Act
        let encoded_value = test_vector.value.encode().unwrap();

        // Assert
        assert_eq!(*expected_encoding, encoded_value)
    }
}

#[test]
fn sbor_decoding_value_yields_expected_result() {
    // Arrange
    let bech32_coder = Bech32Coder::new(0xf2);

    // Testing that the Value -> AstValue conversion matches that obtained from parsing the manifest
    for test_vector in VALUE_AST_CONVERSIONS_TEST_VECTORS.iter() {
        // This test will fail (as expected) for buckets and proofs with string identifiers. So,
        // we skip those tests
        if let Value::Bucket { ref identifier } = test_vector.value {
            if let Identifier::String(..) = identifier.0 {
                continue;
            }
        } else if let Value::Proof { ref identifier } = test_vector.value {
            if let Identifier::String(..) = identifier.0 {
                continue;
            }
        } else if let Value::Bytes { .. } = test_vector.value {
            // TODO: Remove this. Currently we ignore this test because converting bytes to a
            // Scrypto value yields an Array<u8>. Converting an Array<u8> back to Value yields a
            // Array<u8>. So, converting back does not currently mean the same thing in manifest
            // land, but means the same thing in SBOR land.
            continue;
        }

        let expected_value = &test_vector.value;
        let encoded_value =
            scrypto_encode(&test_vector.manifest_representation_as_scrypto_value(&bech32_coder))
                .unwrap();

        // Act
        let value =
            Value::decode(&encoded_value, 0xf2).expect("Failed to SBOR decode trusted value");

        // Assert
        assert_eq!(*expected_value, value)
    }
}

#[test]
fn validation_of_values_produces_expected_validation_response() {
    // Arrange
    let network_id = 0xf2;

    for test_vector in VALUE_VALIDATION_TEST_VECTORS.iter() {
        let expected_validation_result = &test_vector.validation_result;

        // Act
        let validation_result = test_vector
            .value
            .validate((network_id, Some(test_vector.value.kind())));

        // Assert
        assert_eq!(*expected_validation_result, validation_result);
    }

    for test_vector in VALUE_JSON_CONVERSION_TEST_VECTORS.iter() {
        // Act
        let validation_result = test_vector
            .value
            .validate((network_id, Some(test_vector.value.kind())));

        // Assert
        assert_eq!(validation_result, Ok(()))
    }
}

#[test]
fn value_has_expected_value_kind() {
    // Arrange
    for test_vector in VALUE_KIND_TEST_VECTORS.iter() {
        let expected_value_kind = test_vector.value_kind;

        // Act
        let value_kind = test_vector.value.kind();

        // Assert
        assert_eq!(expected_value_kind, value_kind);
    }
}

#[test]
fn value_has_expected_ast_value_kind() {
    // Arrange
    for test_vector in VALUE_KIND_TEST_VECTORS.iter() {
        let expected_value_kind = test_vector.ast_value_kind;

        // Act
        let value_kind = test_vector.value.kind().into();

        // Assert
        assert_eq!(expected_value_kind, value_kind);
    }
}

#[test]
fn value_kind_to_ast_value_kind_is_converted_as_expected() {
    // Arrange
    for test_vector in VALUE_KIND_TEST_VECTORS.iter() {
        let expected_value_kind = test_vector.ast_value_kind;

        // Act
        let value_kind = test_vector.value_kind.into();

        // Assert
        assert_eq!(expected_value_kind, value_kind);
    }
}
