// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at

//   http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

#[macro_use]
extern crate lazy_static;
use radix_engine_toolkit_core::{
    error::Error,
    model::{
        Bech32Coder, BucketId, Identifier, NetworkAwareComponentAddress,
        NetworkAwarePackageAddress, NetworkAwareResourceAddress, NetworkAwareSystemAddress,
        NonFungibleAddress, ProofId, Value, ValueKind,
    }, traits::ValidateWithContext,
};
use radix_transaction::manifest::{
    generator::{generate_value, NameResolver},
    lexer::tokenize,
};
use sbor::rust::collections::IndexMap;
use scrypto::prelude::*;

#[test]
fn serialized_values_match_expected() {
    // Checking that the serialization of values matches
    for test_vector in JSON_CONVERSION_TEST_VECTORS.iter() {
        // Act
        let expected_serialized_value: serde_json::Value =
            serde_json::from_str(&test_vector.json_representation)
                .expect("Failed to deserialize trusted value");
        let serialized_value =
            serde_json::to_value(&test_vector.value).expect("Failed to serialize trusted value");

        // Assert
        assert_eq!(expected_serialized_value, serialized_value);
    }
}

#[test]
fn deserialized_values_match_expected() {
    // Checking that the deserialization of values matches
    for test_vector in JSON_CONVERSION_TEST_VECTORS.iter() {
        // Act
        let expected_value = &test_vector.value;
        let deserialized_value: Value = serde_json::from_str(&test_vector.json_representation)
            .expect("Deserialization failed!");

        // Assert
        assert_eq!(*expected_value, deserialized_value)
    }
}

/// # Background
///
/// There are methods on the [Value] model to convert a [Value] to a
/// [radix_transaction::manifest::ast::Value]. This conversion requires some domain-specific
/// knowledge as to what the abstract syntax tree looks like.
///
/// As an example for a `ResourceAddress("some_address")` in the manifest we know that this is an
/// `AstValue::ResourceAddress` with a `AstValue::String` inside of it. Because of the
/// domain-knowledge requirement for this conversion, the transaction compiler could have a change
/// made to it which changes the expected structure of the AST. There would likely be no
/// compile-time errors as the AST uses an unstructured value model.
///
/// # Purpose
///
/// The purpose of this test is to check that the conversion of a [Value] to a
/// [radix_transaction::manifest::ast::Value] matches the abstract syntax tree that is generated by
/// the transaction compiler for an equivalent manifest string value.
#[test]
fn value_ast_conversions_match_that_produced_by_transaction_compiler() {
    // Arrange
    let bech32_coder = Bech32Coder::new(0xf2);

    // Testing that the Value -> AstValue conversion matches that obtained from parsing the manifest
    for test_vector in VALUE_AST_CONVERSIONS_TEST_VECTORS.iter() {
        let expected_ast_value = test_vector.manifest_representation_as_ast_value();

        // Act
        let ast_value = test_vector
            .value
            .to_ast_value(&bech32_coder)
            .expect("Value -> AstValue conversion of trusted value failed");

        // Assert
        assert_eq!(expected_ast_value, ast_value)
    }
}

#[test]
fn value_scrypto_value_conversion_match_that_produced_by_transaction_compiler() {
    // Arrange
    let bech32_coder = Bech32Coder::new(0xf2);

    for test_vector in VALUE_AST_CONVERSIONS_TEST_VECTORS.iter() {
        // This test will fail (as expected) for buckets and proofs with string identifiers. So,
        // we skip those tests
        if let Value::Bucket { ref identifier } = test_vector.value {
            if let Identifier::String(..) = identifier.0 {
                continue;
            }
        } else if let Value::Proof { ref identifier } = test_vector.value {
            if let Identifier::String(..) = identifier.0 {
                continue;
            }
        }

        let expected_scrypto_value =
            test_vector.manifest_representation_as_scrypto_value(&bech32_coder);

        // Act
        let scrypto_value = test_vector
            .value
            .to_scrypto_value()
            .expect("Failed to convert a trusted value to a scrypto value");

        // Assert
        assert_eq!(scrypto_value, expected_scrypto_value);
    }
}

#[test]
fn no_information_is_lost_when_converting_value_to_ast_value_and_back() {
    // Arrange
    let bech32_coder = Bech32Coder::new(0xf2);

    // Testing that the Value -> AstValue conversion matches that obtained from parsing the manifest
    for test_vector in VALUE_AST_CONVERSIONS_TEST_VECTORS.iter() {
        let expected_value = &test_vector.value;

        // Act
        let ast_value = Value::from_ast_value(
            &test_vector
                .value
                .to_ast_value(&bech32_coder)
                .expect("Value -> AstValue conversion of trusted value failed"),
            &bech32_coder,
        )
        .expect("AstValue -> Value for a trusted value failed");

        // Assert
        assert_eq!(*expected_value, ast_value)
    }
}

#[test]
fn no_information_is_lost_when_converting_value_to_scrypto_value_and_back() {
    // Arrange
    let bech32_coder = Bech32Coder::new(0xf2);

    // Testing that the Value -> AstValue conversion matches that obtained from parsing the manifest
    for test_vector in VALUE_AST_CONVERSIONS_TEST_VECTORS.iter() {
        // This test will fail (as expected) for buckets and proofs with string identifiers. So,
        // we skip those tests
        if let Value::Bucket { ref identifier } = test_vector.value {
            if let Identifier::String(..) = identifier.0 {
                continue;
            }
        } else if let Value::Proof { ref identifier } = test_vector.value {
            if let Identifier::String(..) = identifier.0 {
                continue;
            }
        } else if let Value::Bytes { .. } = test_vector.value {
            // TODO: Remove this. Currently we ignore this test because converting bytes to a
            // Scrypto value yields an Array<u8>. Converting an Array<u8> back to Value yields a
            // Array<u8>. So, converting back does not currently mean the same thing in manifest
            // land, but means the same thing in SBOR land.
            continue;
        }

        let expected_value = &test_vector.value;

        // Act
        let ast_value = Value::from_scrypto_value(
            &test_vector
                .value
                .to_scrypto_value()
                .expect("Value -> AstValue conversion of trusted value failed"),
            bech32_coder.network_id(),
        );

        // Assert
        assert_eq!(*expected_value, ast_value)
    }
}

#[test]
fn sbor_encoding_value_yields_expected_result() {
    // Arrange
    let bech32_coder = Bech32Coder::new(0xf2);

    // Testing that the Value -> AstValue conversion matches that obtained from parsing the manifest
    for test_vector in VALUE_AST_CONVERSIONS_TEST_VECTORS.iter() {
        // This test will fail (as expected) for buckets and proofs with string identifiers. So,
        // we skip those tests
        if let Value::Bucket { ref identifier } = test_vector.value {
            if let Identifier::String(..) = identifier.0 {
                continue;
            }
        } else if let Value::Proof { ref identifier } = test_vector.value {
            if let Identifier::String(..) = identifier.0 {
                continue;
            }
        }

        let expected_encoding =
            scrypto_encode(&test_vector.manifest_representation_as_scrypto_value(&bech32_coder))
                .unwrap();

        // Act
        let encoded_value = test_vector.value.encode().unwrap();

        // Assert
        assert_eq!(*expected_encoding, encoded_value)
    }
}

#[test]
fn sbor_decoding_value_yields_expected_result() {
    // Arrange
    let bech32_coder = Bech32Coder::new(0xf2);

    // Testing that the Value -> AstValue conversion matches that obtained from parsing the manifest
    for test_vector in VALUE_AST_CONVERSIONS_TEST_VECTORS.iter() {
        // This test will fail (as expected) for buckets and proofs with string identifiers. So,
        // we skip those tests
        if let Value::Bucket { ref identifier } = test_vector.value {
            if let Identifier::String(..) = identifier.0 {
                continue;
            }
        } else if let Value::Proof { ref identifier } = test_vector.value {
            if let Identifier::String(..) = identifier.0 {
                continue;
            }
        } else if let Value::Bytes { .. } = test_vector.value {
            // TODO: Remove this. Currently we ignore this test because converting bytes to a
            // Scrypto value yields an Array<u8>. Converting an Array<u8> back to Value yields a
            // Array<u8>. So, converting back does not currently mean the same thing in manifest
            // land, but means the same thing in SBOR land.
            continue;
        }

        let expected_value = &test_vector.value;
        let encoded_value =
            scrypto_encode(&test_vector.manifest_representation_as_scrypto_value(&bech32_coder))
                .unwrap();

        // Act
        let value =
            Value::decode(&encoded_value, 0xf2).expect("Failed to SBOR decode trusted value");

        // Assert
        assert_eq!(*expected_value, value)
    }
}

#[test]
fn validation_of_values_produces_expected_validation_response() {
    // Arrange
    let network_id = 0xf2;

    for test_vector in VALUE_VALIDATION_TEST_VECTORS.iter() {
        let expected_validation_result = &test_vector.validation_result;

        // Act
        let validation_result = test_vector.value.validate((network_id, Some(test_vector.value.kind())));

        // Assert
        assert_eq!(*expected_validation_result, validation_result);
    }

    for test_vector in JSON_CONVERSION_TEST_VECTORS.iter() {
        // Act
        let validation_result = test_vector.value.validate((network_id, Some(test_vector.value.kind())));

        // Assert
        assert_eq!(validation_result, Ok(()))
    }
}

struct ValueJsonRepresentationTestVector {
    value: Value,
    json_representation: String,
}

impl ValueJsonRepresentationTestVector {
    fn new<S: AsRef<str>>(value: Value, json_representation: S) -> Self {
        let json_representation: &str = json_representation.as_ref();
        let json_representation: String = json_representation.into();
        Self {
            value,
            json_representation,
        }
    }
}

struct ValueAstConversionsTestVector {
    value: Value,
    manifest_representation: String,
}

impl ValueAstConversionsTestVector {
    fn new<S: AsRef<str>>(value: Value, manifest_representation: S) -> Self {
        let manifest_representation: &str = manifest_representation.as_ref();
        let manifest_representation: String = manifest_representation.into();
        Self {
            manifest_representation,
            value,
        }
    }

    fn manifest_representation_as_ast_value(&self) -> radix_transaction::manifest::ast::Value {
        radix_transaction::manifest::parser::Parser::new(
            tokenize(&self.manifest_representation).expect("Failed to tokenize trusted value"),
        )
        .parse_value()
        .expect("Failed to parse trusted value to ast value")
    }

    fn manifest_representation_as_scrypto_value(&self, bech32_coder: &Bech32Coder) -> ScryptoValue {
        let mut blobs = IndexMap::<Hash, Vec<u8>>::new();
        if let Value::Blob { ref hash } = self.value {
            blobs.insert(hash.0, Vec::new());
        };

        let ast_value = self.manifest_representation_as_ast_value();
        generate_value(
            &ast_value,
            None,
            &mut NameResolver::new(),
            &bech32_coder.decoder,
            &blobs,
        )
        .expect("Failed to generate scrypto value from ast_value")
    }
}

struct ValueValidationTestVector {
    value: Value,
    validation_result: Result<(), Error>,
}

impl ValueValidationTestVector {
    fn new(value: Value, validation_result: Result<(), Error>) -> Self {
        Self {
            value,
            validation_result,
        }
    }
}

lazy_static! {
    static ref JSON_CONVERSION_TEST_VECTORS: Vec<ValueJsonRepresentationTestVector> = vec![
        // ================
        // Primitive Types
        // ================

        // Unit and Boolean
        ValueJsonRepresentationTestVector::new(Value::Unit, r#"{"type": "Unit"}"#),
        ValueJsonRepresentationTestVector::new(
            Value::Bool { value: true },
            r#"{"type": "Bool", "value": true}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::Bool { value: false },
            r#"{"type": "Bool", "value": false}"#,
        ),
        // Unsigned Integers
        ValueJsonRepresentationTestVector::new(
            Value::U8 { value: 19 },
            r#"{"type": "U8", "value": "19"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::U16 { value: 19 },
            r#"{"type": "U16", "value": "19"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::U32 { value: 19 },
            r#"{"type": "U32", "value": "19"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::U64 { value: 19 },
            r#"{"type": "U64", "value": "19"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::U128 { value: 19 },
            r#"{"type": "U128", "value": "19"}"#,
        ),
        // Signed Integers
        ValueJsonRepresentationTestVector::new(
            Value::I8 { value: 19 },
            r#"{"type": "I8", "value": "19"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::I16 { value: 19 },
            r#"{"type": "I16", "value": "19"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::I32 { value: 19 },
            r#"{"type": "I32", "value": "19"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::I64 { value: 19 },
            r#"{"type": "I64", "value": "19"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::I128 { value: 19 },
            r#"{"type": "I128", "value": "19"}"#,
        ),
        // String
        ValueJsonRepresentationTestVector::new(
            Value::String {
                value: "P2P Cash System".into(),
            },
            r#"{"type": "String", "value": "P2P Cash System"}"#,
        ),
        // Enums and Enum Aliases (Option & Result)
        ValueJsonRepresentationTestVector::new(
            Value::Enum {
                variant: "Create".into(),
                fields: Some(vec![Value::String {
                    value: "Component".into(),
                }]),
            },
            r#"{"type": "Enum", "variant": "Create", "fields": [{"type": "String", "value": "Component"}]}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::Option {
                value: Box::new(Some(Value::String {
                    value: "Component".into(),
                })),
            },
            r#"{"type": "Option", "variant": "Some", "field": {"type": "String", "value": "Component"}}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::Option {
                value: Box::new(None),
            },
            r#"{"type": "Option", "variant": "None"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::Result {
                value: Box::new(Ok(Value::String {
                    value: "Component".into(),
                })),
            },
            r#"{"type": "Result", "variant": "Ok", "field": {"type": "String", "value": "Component"}}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::Result {
                value: Box::new(Err(Value::String {
                    value: "Component".into(),
                })),
            },
            r#"{"type": "Result", "variant": "Err", "field": {"type": "String", "value": "Component"}}"#,
        ),
        // =================
        // Collection Types
        // =================
        ValueJsonRepresentationTestVector::new(
            Value::Array {
                element_type: ValueKind::String,
                elements: vec![Value::String {
                    value: "World, Hello!".into(),
                }],
            },
            r#"{"type": "Array", "element_type": "String", "elements": [{"type": "String", "value": "World, Hello!"}]}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::Tuple {
                elements: vec![Value::I64 { value: 19 }, Value::I8 { value: 19 }],
            },
            r#"{"type": "Tuple", "elements": [{"type": "I64", "value": "19"}, {"type": "I8", "value": "19"}]}"#,
        ),
        // =========================
        // Node Identifier Wrappers
        // =========================
        ValueJsonRepresentationTestVector::new(
            Value::KeyValueStore {
                identifier:
                    "000000000000000000000000000000000000000000000000000000000000000000000005"
                        .parse()
                        .unwrap(),
            },
            r#"{"type": "KeyValueStore", "identifier": "000000000000000000000000000000000000000000000000000000000000000000000005"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::Component {
                identifier:
                    "000000000000000000000000000000000000000000000000000000000000000000000005"
                        .parse()
                        .unwrap(),
            },
            r#"{"type": "Component", "identifier": "000000000000000000000000000000000000000000000000000000000000000000000005"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::Vault {
                identifier:
                    "000000000000000000000000000000000000000000000000000000000000000000000005"
                        .parse()
                        .unwrap(),
            },
            r#"{"type": "Vault", "identifier": "000000000000000000000000000000000000000000000000000000000000000000000005"}"#,
        ),
        // ============================
        // Decimal And Precise Decimal
        // ============================
        ValueJsonRepresentationTestVector::new(
            Value::Decimal {
                value: "1923319912.102221313".parse().unwrap(),
            },
            r#"{"type": "Decimal", "value": "1923319912.102221313"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::PreciseDecimal {
                value: "1923319912.102221313".parse().unwrap(),
            },
            r#"{"type": "PreciseDecimal", "value": "1923319912.102221313"}"#,
        ),
        // ==============
        // Address Types
        // ==============
        ValueJsonRepresentationTestVector::new(
            Value::ComponentAddress {
                address: NetworkAwareComponentAddress {
                    network_id: 0xf2,
                    address: scrypto::prelude::ComponentAddress::Normal([0; 26]),
                },
            },
            r#"{"type": "ComponentAddress", "address": "component_sim1qgqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq8ecz5v"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::ComponentAddress {
                address: NetworkAwareComponentAddress {
                    network_id: 0xf2,
                    address: scrypto::prelude::ComponentAddress::Account([0; 26]),
                },
            },
            r#"{"type": "ComponentAddress", "address": "account_sim1qvqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqg5cu7q"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::ResourceAddress {
                address: NetworkAwareResourceAddress {
                    network_id: 0xf2,
                    address: scrypto::prelude::ResourceAddress::Normal([0; 26]),
                },
            },
            r#"{"type": "ResourceAddress", "address": "resource_sim1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqz8qety"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::PackageAddress {
                address: NetworkAwarePackageAddress {
                    network_id: 0xf2,
                    address: scrypto::prelude::PackageAddress::Normal([0; 26]),
                },
            },
            r#"{"type": "PackageAddress", "address": "package_sim1qyqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqxrmwtq"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::SystemAddress {
                address: NetworkAwareSystemAddress {
                    network_id: 0xf2,
                    address: scrypto::prelude::SystemAddress::EpochManager([0; 26]),
                },
            },
            r#"{"type": "SystemAddress", "address": "system_sim1qsqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqsglvqq"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::SystemAddress {
                address: NetworkAwareSystemAddress {
                    network_id: 0xf2,
                    address: scrypto::prelude::SystemAddress::Clock([0; 26]),
                },
            },
            r#"{"type": "SystemAddress", "address": "system_sim1q5qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqz4jjwj"}"#,
        ),
        // ==============
        // Cryptographic
        // ==============
        ValueJsonRepresentationTestVector::new(
            Value::Hash { value: "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824".parse().unwrap() },
            r#"{"type": "Hash", "value": "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::EcdsaSecp256k1PublicKey { public_key: "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798".parse().unwrap() },
            r#"{"type": "EcdsaSecp256k1PublicKey", "public_key": "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::EddsaEd25519PublicKey { public_key: "4cb5abf6ad79fbf5abbccafcc269d85cd2651ed4b885b5869f241aedf0a5ba29".parse().unwrap() },
            r#"{"type": "EddsaEd25519PublicKey", "public_key": "4cb5abf6ad79fbf5abbccafcc269d85cd2651ed4b885b5869f241aedf0a5ba29"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::EcdsaSecp256k1Signature { signature: "0079224ea514206706298d8d620f660828f7987068d6d02757e6f3cbbf4a51ab133395db69db1bc9b2726dd99e34efc252d8258dcb003ebaba42be349f50f7765e".parse().unwrap() },
            r#"{"type": "EcdsaSecp256k1Signature", "signature": "0079224ea514206706298d8d620f660828f7987068d6d02757e6f3cbbf4a51ab133395db69db1bc9b2726dd99e34efc252d8258dcb003ebaba42be349f50f7765e"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::EddsaEd25519Signature { signature: "ce993adc51111309a041faa65cbcf1154d21ed0ecdc2d54070bc90b9deb744aa8605b3f686fa178fba21070b4a4678e54eee3486a881e0e328251cd37966de09".parse().unwrap() },
            r#"{"type": "EddsaEd25519Signature", "signature": "ce993adc51111309a041faa65cbcf1154d21ed0ecdc2d54070bc90b9deb744aa8605b3f686fa178fba21070b4a4678e54eee3486a881e0e328251cd37966de09"}"#,
        ),

        // ===================
        // Buckets and Proofs
        // ===================
        ValueJsonRepresentationTestVector::new(
            Value::Bucket { identifier: BucketId(Identifier::String("xrd_bucket".into())) },
            r#"{"type": "Bucket", "identifier": "xrd_bucket"}"#
        ),
        ValueJsonRepresentationTestVector::new(
            Value::Bucket { identifier: BucketId(Identifier::U32(28)) },
            r#"{"type": "Bucket", "identifier": 28}"#
        ),
        ValueJsonRepresentationTestVector::new(
            Value::Proof { identifier: ProofId(Identifier::String("xrd_proof".into())) },
            r#"{"type": "Proof", "identifier": "xrd_proof"}"#
        ),
        ValueJsonRepresentationTestVector::new(
            Value::Proof { identifier: ProofId(Identifier::U32(28)) },
            r#"{"type": "Proof", "identifier": 28}"#
        ),

        // ==========================
        // Non Fungible Id & Address
        // ==========================

        ValueJsonRepresentationTestVector::new(
            Value::NonFungibleId { value: NonFungibleId::U32(1144418947) },
            r#"{"type": "NonFungibleId", "variant": "U32", "value": "1144418947"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::NonFungibleId { value: NonFungibleId::U64(114441894733333) },
            r#"{"type": "NonFungibleId", "variant": "U64", "value": "114441894733333"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::NonFungibleId { value: NonFungibleId::UUID(11444189334733333) },
            r#"{"type": "NonFungibleId", "variant": "UUID", "value": "11444189334733333"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::NonFungibleId { value: NonFungibleId::String("hello_world".into()) },
            r#"{"type": "NonFungibleId", "variant": "String", "value": "hello_world"}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::NonFungibleId { value: NonFungibleId::Bytes(vec![0x10, 0xa2, 0x31, 0x01]) },
            r#"{"type": "NonFungibleId", "variant": "Bytes", "value": "10a23101"}"#,
        ),

        ValueJsonRepresentationTestVector::new(
            Value::NonFungibleAddress {
                address: NonFungibleAddress {
                    resource_address: NetworkAwareResourceAddress {
                            network_id: 0xf2,
                            address: scrypto::prelude::ResourceAddress::Normal([0; 26]),
                        },
                    non_fungible_id: NonFungibleId::U32(1144418947)
                }
            },
            r#"{"type": "NonFungibleAddress", "resource_address": {"type": "ResourceAddress", "address": "resource_sim1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqz8qety"}, "non_fungible_id": {"type": "NonFungibleId", "variant": "U32", "value": "1144418947"}}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::NonFungibleAddress {
                address: NonFungibleAddress {
                    resource_address: NetworkAwareResourceAddress {
                            network_id: 0xf2,
                            address: scrypto::prelude::ResourceAddress::Normal([0; 26]),
                        },
                    non_fungible_id: NonFungibleId::U64(114441894733333)
                }
            },
            r#"{"type": "NonFungibleAddress", "resource_address": {"type": "ResourceAddress", "address": "resource_sim1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqz8qety"}, "non_fungible_id": {"type": "NonFungibleId", "variant": "U64", "value": "114441894733333"}}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::NonFungibleAddress {
                address: NonFungibleAddress {
                    resource_address: NetworkAwareResourceAddress {
                            network_id: 0xf2,
                            address: scrypto::prelude::ResourceAddress::Normal([0; 26]),
                        },
                    non_fungible_id: NonFungibleId::UUID(11444189334733333)
                }
            },
            r#"{"type": "NonFungibleAddress", "resource_address": {"type": "ResourceAddress", "address": "resource_sim1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqz8qety"}, "non_fungible_id": {"type": "NonFungibleId", "variant": "UUID", "value": "11444189334733333"}}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::NonFungibleAddress {
                address: NonFungibleAddress {
                    resource_address: NetworkAwareResourceAddress {
                            network_id: 0xf2,
                            address: scrypto::prelude::ResourceAddress::Normal([0; 26]),
                        },
                    non_fungible_id: NonFungibleId::String("hello_world".into())
                }
            },
            r#"{"type": "NonFungibleAddress", "resource_address": {"type": "ResourceAddress", "address": "resource_sim1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqz8qety"}, "non_fungible_id": {"type": "NonFungibleId", "variant": "String", "value": "hello_world"}}"#,
        ),
        ValueJsonRepresentationTestVector::new(
            Value::NonFungibleAddress {
                address: NonFungibleAddress {
                    resource_address: NetworkAwareResourceAddress {
                            network_id: 0xf2,
                            address: scrypto::prelude::ResourceAddress::Normal([0; 26]),
                        },
                    non_fungible_id: NonFungibleId::Bytes(vec![0x10, 0xa2, 0x31, 0x01])
                }
            },
            r#"{"type": "NonFungibleAddress", "resource_address": {"type": "ResourceAddress", "address": "resource_sim1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqz8qety"}, "non_fungible_id": {"type": "NonFungibleId", "variant": "Bytes", "value": "10a23101"}}"#,
        ),

        // =================
        // Other Misc Types
        // =================
        ValueJsonRepresentationTestVector::new(
            Value::Blob { hash: Blob("2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824".parse().unwrap()) },
            r#"{"type": "Blob", "hash": "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"}"#
        ),
        ValueJsonRepresentationTestVector::new(
            Value::Expression { value: Expression::entire_auth_zone() },
            r#"{"type": "Expression", "value": "ENTIRE_AUTH_ZONE"}"#
        ),
        ValueJsonRepresentationTestVector::new(
            Value::Expression { value: Expression::entire_worktop() },
            r#"{"type": "Expression", "value": "ENTIRE_WORKTOP"}"#
        ),
        ValueJsonRepresentationTestVector::new(
            Value::Bytes { value: vec![0x12, 0x19, 0x12, 0x20, 0x8] },
            r#"{"type": "Bytes", "value": "1219122008"}"#
        ),
    ];

    static ref VALUE_AST_CONVERSIONS_TEST_VECTORS: Vec<ValueAstConversionsTestVector> = vec![
        // ================
        // Primitive Types
        // ================

        // Unit and Boolean
        ValueAstConversionsTestVector::new(
            Value::Unit,
            r#"()"#
        ),
        ValueAstConversionsTestVector::new(
            Value::Bool { value: true },
            r#"true"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::Bool { value: false },
            r#"false"#,
        ),
        // Unsigned Integers
        ValueAstConversionsTestVector::new(
            Value::U8 { value: 19 },
            "19u8"
        ),
        ValueAstConversionsTestVector::new(
            Value::U16 { value: 19 },
            "19u16"
        ),
        ValueAstConversionsTestVector::new(
            Value::U32 { value: 19 },
            "19u32"
        ),
        ValueAstConversionsTestVector::new(
            Value::U64 { value: 19 },
            "19u64"
        ),
        ValueAstConversionsTestVector::new(
            Value::U128 { value: 19 },
            "19u128"
        ),
        // Signed Integers
        ValueAstConversionsTestVector::new(
            Value::I8 { value: 19 },
            "19i8"
        ),
        ValueAstConversionsTestVector::new(
            Value::I16 { value: 19 },
            "19i16"
        ),
        ValueAstConversionsTestVector::new(
            Value::I32 { value: 19 },
            "19i32"
        ),
        ValueAstConversionsTestVector::new(
            Value::I64 { value: 19 },
            "19i64"
        ),
        ValueAstConversionsTestVector::new(
            Value::I128 { value: 19 },
            "19i128"
        ),
        // String
        ValueAstConversionsTestVector::new(
            Value::String {
                value: "P2P Cash System".into(),
            },
            r#""P2P Cash System""#,
        ),
        // Enums and Enum Aliases (Option & Result)
        ValueAstConversionsTestVector::new(
            Value::Enum {
                variant: "Create".into(),
                fields: Some(vec![Value::String {
                    value: "Component".into(),
                }]),
            },
            r#"Enum("Create", "Component")"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::Option {
                value: Box::new(Some(Value::String {
                    value: "Component".into(),
                })),
            },
            r#"Some("Component")"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::Option {
                value: Box::new(None),
            },
            r#"None"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::Result {
                value: Box::new(Ok(Value::String {
                    value: "Component".into(),
                })),
            },
            r#"Ok("Component")"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::Result {
                value: Box::new(Err(Value::String {
                    value: "Component".into(),
                })),
            },
            r#"Err("Component")"#,
        ),
        // =================
        // Collection Types
        // =================
        ValueAstConversionsTestVector::new(
            Value::Array {
                element_type: ValueKind::String,
                elements: vec![Value::String {
                    value: "World, Hello!".into(),
                }],
            },
            r#"Array<String>("World, Hello!")"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::Tuple {
                elements: vec![Value::I64 { value: 19 }, Value::I8 { value: 19 }],
            },
            "Tuple(19i64, 19i8)"
        ),
        // =========================
        // Node Identifier Wrappers
        // =========================
        ValueAstConversionsTestVector::new(
            Value::KeyValueStore {
                identifier:
                    "000000000000000000000000000000000000000000000000000000000000000000000005"
                        .parse()
                        .unwrap(),
            },
            r#"KeyValueStore("000000000000000000000000000000000000000000000000000000000000000000000005")"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::Component {
                identifier:
                    "000000000000000000000000000000000000000000000000000000000000000000000005"
                        .parse()
                        .unwrap(),
            },
            r#"Component("000000000000000000000000000000000000000000000000000000000000000000000005")"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::Vault {
                identifier:
                    "000000000000000000000000000000000000000000000000000000000000000000000005"
                        .parse()
                        .unwrap(),
            },
            r#"Vault("000000000000000000000000000000000000000000000000000000000000000000000005")"#,
        ),
        // ============================
        // Decimal And Precise Decimal
        // ============================
        ValueAstConversionsTestVector::new(
            Value::Decimal {
                value: "1923319912.102221313".parse().unwrap(),
            },
            r#"Decimal("1923319912.102221313")"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::PreciseDecimal {
                value: "1923319912.102221313".parse().unwrap(),
            },
            r#"PreciseDecimal("1923319912.102221313")"#,
        ),
        // ==============
        // Address Types
        // ==============
        ValueAstConversionsTestVector::new(
            Value::ComponentAddress {
                address: NetworkAwareComponentAddress {
                    network_id: 0xf2,
                    address: scrypto::prelude::ComponentAddress::Normal([0; 26]),
                },
            },
            r#"ComponentAddress("component_sim1qgqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq8ecz5v")"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::ResourceAddress {
                address: NetworkAwareResourceAddress {
                    network_id: 0xf2,
                    address: scrypto::prelude::ResourceAddress::Normal([0; 26]),
                },
            },
            r#"ResourceAddress("resource_sim1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqz8qety")"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::PackageAddress {
                address: NetworkAwarePackageAddress {
                    network_id: 0xf2,
                    address: scrypto::prelude::PackageAddress::Normal([0; 26]),
                },
            },
            r#"PackageAddress("package_sim1qyqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqxrmwtq")"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::SystemAddress {
                address: NetworkAwareSystemAddress {
                    network_id: 0xf2,
                    address: scrypto::prelude::SystemAddress::EpochManager([0; 26]),
                },
            },
            r#"SystemAddress("system_sim1qsqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqsglvqq")"#,
        ),
        // ==============
        // Cryptographic
        // ==============
        ValueAstConversionsTestVector::new(
            Value::Hash { value: "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824".parse().unwrap() },
            r#"Hash("2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824")"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::EcdsaSecp256k1PublicKey { public_key: "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798".parse().unwrap() },
            r#"EcdsaSecp256k1PublicKey("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::EddsaEd25519PublicKey { public_key: "4cb5abf6ad79fbf5abbccafcc269d85cd2651ed4b885b5869f241aedf0a5ba29".parse().unwrap() },
            r#"EddsaEd25519PublicKey("4cb5abf6ad79fbf5abbccafcc269d85cd2651ed4b885b5869f241aedf0a5ba29")"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::EcdsaSecp256k1Signature { signature: "0079224ea514206706298d8d620f660828f7987068d6d02757e6f3cbbf4a51ab133395db69db1bc9b2726dd99e34efc252d8258dcb003ebaba42be349f50f7765e".parse().unwrap() },
            r#"EcdsaSecp256k1Signature("0079224ea514206706298d8d620f660828f7987068d6d02757e6f3cbbf4a51ab133395db69db1bc9b2726dd99e34efc252d8258dcb003ebaba42be349f50f7765e")"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::EddsaEd25519Signature { signature: "ce993adc51111309a041faa65cbcf1154d21ed0ecdc2d54070bc90b9deb744aa8605b3f686fa178fba21070b4a4678e54eee3486a881e0e328251cd37966de09".parse().unwrap() },
            r#"EddsaEd25519Signature("ce993adc51111309a041faa65cbcf1154d21ed0ecdc2d54070bc90b9deb744aa8605b3f686fa178fba21070b4a4678e54eee3486a881e0e328251cd37966de09")"#,
        ),

        // ===================
        // Buckets and Proofs
        // ===================
        ValueAstConversionsTestVector::new(
            Value::Bucket { identifier: BucketId(Identifier::String("xrd_bucket".into())) },
            r#"Bucket("xrd_bucket")"#
        ),
        ValueAstConversionsTestVector::new(
            Value::Bucket { identifier: BucketId(Identifier::U32(28)) },
            r#"Bucket(28u32)"#
        ),
        ValueAstConversionsTestVector::new(
            Value::Proof { identifier: ProofId(Identifier::String("xrd_proof".into())) },
            r#"Proof("xrd_proof")"#
        ),
        ValueAstConversionsTestVector::new(
            Value::Proof { identifier: ProofId(Identifier::U32(28)) },
            r#"Proof(28u32)"#
        ),

        // ==========================
        // Non Fungible Id & Address
        // ==========================
        ValueAstConversionsTestVector::new(
            Value::NonFungibleId { value: NonFungibleId::U32(1144418947) },
            r#"NonFungibleId(1144418947u32)"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::NonFungibleId { value: NonFungibleId::U64(114441894733333) },
            r#"NonFungibleId(114441894733333u64)"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::NonFungibleId { value: NonFungibleId::UUID(11444189334733333) },
            r#"NonFungibleId(11444189334733333u128)"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::NonFungibleId { value: NonFungibleId::String("hello_world".into()) },
            r#"NonFungibleId("hello_world")"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::NonFungibleId { value: NonFungibleId::Bytes(vec![0x10, 0xa2, 0x31, 0x01]) },
            r#"NonFungibleId(Bytes("10a23101"))"#,
        ),

        ValueAstConversionsTestVector::new(
            Value::NonFungibleAddress {
                address: NonFungibleAddress {
                    resource_address: NetworkAwareResourceAddress {
                            network_id: 0xf2,
                            address: scrypto::prelude::ResourceAddress::Normal([0; 26]),
                        },
                    non_fungible_id: NonFungibleId::U32(1144418947)
                }
            },
            r#"NonFungibleAddress("resource_sim1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqz8qety", 1144418947u32)"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::NonFungibleAddress {
                address: NonFungibleAddress {
                    resource_address: NetworkAwareResourceAddress {
                            network_id: 0xf2,
                            address: scrypto::prelude::ResourceAddress::Normal([0; 26]),
                        },
                    non_fungible_id: NonFungibleId::U64(114441894733333)
                }
            },
            r#"NonFungibleAddress("resource_sim1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqz8qety", 114441894733333u64)"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::NonFungibleAddress {
                address: NonFungibleAddress {
                    resource_address: NetworkAwareResourceAddress {
                            network_id: 0xf2,
                            address: scrypto::prelude::ResourceAddress::Normal([0; 26]),
                        },
                    non_fungible_id: NonFungibleId::UUID(11444189334733333)
                }
            },
            r#"NonFungibleAddress("resource_sim1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqz8qety", 11444189334733333u128)"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::NonFungibleAddress {
                address: NonFungibleAddress {
                    resource_address: NetworkAwareResourceAddress {
                            network_id: 0xf2,
                            address: scrypto::prelude::ResourceAddress::Normal([0; 26]),
                        },
                    non_fungible_id: NonFungibleId::String("hello_world".into())
                }
            },
            r#"NonFungibleAddress("resource_sim1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqz8qety", "hello_world")"#,
        ),
        ValueAstConversionsTestVector::new(
            Value::NonFungibleAddress {
                address: NonFungibleAddress {
                    resource_address: NetworkAwareResourceAddress {
                            network_id: 0xf2,
                            address: scrypto::prelude::ResourceAddress::Normal([0; 26]),
                        },
                    non_fungible_id: NonFungibleId::Bytes(vec![0x10, 0xa2, 0x31, 0x01])
                }
            },
            r#"NonFungibleAddress("resource_sim1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqz8qety", Bytes("10a23101"))"#,
        ),

        // =================
        // Other Misc Types
        // =================
        ValueAstConversionsTestVector::new(
            Value::Blob { hash: Blob("2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824".parse().unwrap()) },
            r#"Blob("2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824")"#
        ),
        ValueAstConversionsTestVector::new(
            Value::Expression { value: Expression::entire_auth_zone() },
            r#"Expression("ENTIRE_AUTH_ZONE")"#
        ),
        ValueAstConversionsTestVector::new(
            Value::Expression { value: Expression::entire_worktop() },
            r#"Expression("ENTIRE_WORKTOP")"#
        ),
        ValueAstConversionsTestVector::new(
            Value::Bytes { value: vec![0x12, 0x19, 0x12, 0x20, 0x8] },
            r#"Bytes("1219122008")"#
        ),
    ];

    static ref VALUE_VALIDATION_TEST_VECTORS: Vec<ValueValidationTestVector> = vec![
        // ====================================
        // Address Network Mismatch Validation
        // ====================================
        ValueValidationTestVector::new(
            Value::ResourceAddress { 
                address: NetworkAwareResourceAddress { 
                    network_id: 0x10, 
                    address: scrypto::prelude::ResourceAddress::Normal([0; 26]) 
                } 
            },
            Err(Error::NetworkMismatchError { expected: 0xf2, found: 0x10 })
        ),
        ValueValidationTestVector::new(
            Value::ComponentAddress { 
                address: NetworkAwareComponentAddress { 
                    network_id: 0x10, 
                    address: scrypto::prelude::ComponentAddress::Normal([0; 26]) 
                } 
            },
            Err(Error::NetworkMismatchError { expected: 0xf2, found: 0x10 })
        ),
        ValueValidationTestVector::new(
            Value::SystemAddress { 
                address: NetworkAwareSystemAddress { 
                    network_id: 0x10, 
                    address: scrypto::prelude::SystemAddress::EpochManager([0; 26]) 
                } 
            },
            Err(Error::NetworkMismatchError { expected: 0xf2, found: 0x10 })
        ),
        ValueValidationTestVector::new(
            Value::PackageAddress { 
                address: NetworkAwarePackageAddress { 
                    network_id: 0x10, 
                    address: scrypto::prelude::PackageAddress::Normal([0; 26]) 
                } 
            },
            Err(Error::NetworkMismatchError { expected: 0xf2, found: 0x10 })
        ),
        
        ValueValidationTestVector::new(
            Value::Array { element_type: ValueKind::Array, elements: vec![
                Value::Array { element_type: ValueKind::Tuple, elements: vec![
                    Value::Tuple { elements: vec![
                        Value::Array { element_type: ValueKind::Tuple, elements: vec![
                            Value::Tuple { elements: vec![
                                Value::PackageAddress { 
                                    address: NetworkAwarePackageAddress { 
                                        network_id: 0x10, 
                                        address: scrypto::prelude::PackageAddress::Normal([0; 26]) 
                                    } 
                                }
                            ] }
                        ] }
                    ] }
                ] }
            ] },
            Err(Error::NetworkMismatchError { expected: 0xf2, found: 0x10 })
        ),
        // ============================
        // Collection Types Validation
        // ============================
        ValueValidationTestVector::new(
            Value::Array {
                element_type: ValueKind::Decimal,
                elements: vec![
                    Value::Decimal { value: dec!("20") },
                    Value::Decimal { value: dec!("100") },
                    Value::Decimal {
                        value: dec!("192.31"),
                    },
                ],
            },
            Ok(())
        ),
        ValueValidationTestVector::new(
            Value::Array {
                element_type: ValueKind::Decimal,
                elements: vec![
                    Value::Decimal { value: dec!("20") },
                    Value::Decimal { value: dec!("100") },
                    Value::Decimal {
                        value: dec!("192.31"),
                    },
                    Value::PreciseDecimal {
                        value: pdec!("192.31"),
                    },
                ],
            },
            Err(Error::InvalidType { 
                expected_types: vec![ValueKind::Decimal], 
                actual_type: ValueKind::PreciseDecimal 
            })
        ),
        ValueValidationTestVector::new(
            Value::Tuple {
                elements: vec![
                    Value::Decimal { value: dec!("10") },
                    Value::PreciseDecimal { value: pdec!("10") },
                    Value::String {
                        value: "Hello World!".into(),
                    },
                    Value::Tuple {
                        elements: vec![
                            Value::Decimal { value: dec!("10") },
                            Value::PreciseDecimal { value: pdec!("10") },
                            Value::String {
                                value: "Hello World!".into(),
                            },
                            Value::Tuple {
                                elements: vec![
                                    Value::Decimal { value: dec!("10") },
                                    Value::PreciseDecimal { value: pdec!("10") },
                                    Value::String {
                                        value: "Hello World!".into(),
                                    },
                                    Value::Tuple {
                                        elements: vec![
                                            Value::Decimal { value: dec!("10") },
                                            Value::PreciseDecimal { value: pdec!("10") },
                                            Value::String {
                                                value: "Hello World!".into(),
                                            },
                                            Value::Array {
                                                element_type: ValueKind::Decimal,
                                                elements: vec![
                                                    Value::Decimal { value: dec!("20") },
                                                    Value::Decimal { value: dec!("100") },
                                                    Value::Decimal {
                                                        value: dec!("192.31"),
                                                    },
                                                    Value::PreciseDecimal {
                                                        value: pdec!("192.31"),
                                                    },
                                                ],
                                            },
                                        ],
                                    },
                                ],
                            },
                        ],
                    },
                ],
            },
            Err(Error::InvalidType { 
                expected_types: vec![ValueKind::Decimal], 
                actual_type: ValueKind::PreciseDecimal 
            })
        ),
    ];
}
