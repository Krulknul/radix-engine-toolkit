// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

mod test_vector;

use radix_engine_toolkit::model::address::Bech32Coder;
use radix_engine_toolkit::model::value::ast::ManifestAstValue;
pub use test_vector::*;

#[test]
fn serialized_values_match_expected() {
    // Checking that the serialization of values matches
    for test_vector in VALUE_CONVERSION_TEST_VECTORS.iter() {
        // Act
        let expected_serialized_value: serde_json::Value =
            serde_json::from_str(&test_vector.json_representation)
                .expect("Failed to deserialize trusted value");
        let serialized_value =
            serde_json::to_value(&test_vector.value).expect("Failed to serialize trusted value");

        // Assert
        assert_eq!(expected_serialized_value, serialized_value,);
    }
}

#[test]
fn deserialized_values_match_expected() {
    // Checking that the deserialization of values matches
    for test_vector in VALUE_CONVERSION_TEST_VECTORS.iter() {
        // Act
        let expected_value = &test_vector.value;
        let deserialized_value = serde_json::from_str(&test_vector.json_representation)
            .expect("Deserialization failed!");

        // Assert
        assert_eq!(*expected_value, deserialized_value)
    }
}

/// # Background
///
/// There are methods on the [ManifestAstValue] model to convert a [ManifestAstValue] to a
/// [radix_transaction::manifest::ast::Value]. This conversion requires some domain-specific
/// knowledge as to what the abstract syntax tree looks like.
///
/// As an example for a `ResourceAddress("some_address")` in the manifest we know that this is an
/// `AstManifestAstValue::ResourceAddress` with a `AstManifestAstValue::String` inside of it.
/// Because of the domain-knowledge requirement for this conversion, the transaction compiler could
/// have a change made to it which changes the expected structure of the AST. There would likely be
/// no compile-time errors as the AST uses an unstructured value model.
///
/// # Purpose
///
/// The purpose of this test is to check that the conversion of a [ManifestAstValue] to a
/// [radix_transaction::manifest::ast::Value] matches the abstract syntax tree that is generated by
/// the transaction compiler for an equivalent manifest string value.
#[test]
fn value_ast_conversions_match_that_produced_by_transaction_compiler() {
    // Arrange
    let bech32_coder = Bech32Coder::new(0xf2);

    // Testing that the ManifestAstValue -> AstManifestAstValue conversion matches that obtained
    // from parsing the manifest
    for test_vector in VALUE_CONVERSION_TEST_VECTORS.iter() {
        let expected_ast_value = test_vector.manifest_representation_as_ast_value();

        // Act
        let ast_value = test_vector
            .value
            .to_ast_value(&bech32_coder)
            .expect("ManifestAstValue -> AstManifestAstValue conversion of trusted value failed");

        // Assert
        assert_eq!(expected_ast_value, ast_value)
    }
}

#[test]
fn no_information_is_lost_when_converting_value_to_ast_value_and_back() {
    // Arrange
    let bech32_coder = Bech32Coder::new(0xf2);

    // Testing that the ManifestAstValue -> AstManifestAstValue conversion matches that obtained
    // from parsing the manifest
    for test_vector in VALUE_CONVERSION_TEST_VECTORS.iter() {
        let expected_value = &test_vector.value;

        // Act
        let ast_value = ManifestAstValue::from_ast_value(
            &test_vector.value.to_ast_value(&bech32_coder).expect(
                "ManifestAstValue -> AstManifestAstValue conversion of trusted value failed",
            ),
            &bech32_coder,
        )
        .expect("AstManifestAstValue -> ManifestAstValue for a trusted value failed");

        // Assert
        assert_eq!(*expected_value, ast_value)
    }
}
