{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "CompileNotarizedTransactionRequest",
  "description": "This function does the opposite of the compile_signed_transaction_intent function. This function takes in a compiled signed transaction intent and decompiles it into its transaction intent and signatures.",
  "examples": [
    {
      "notary_signature": {
        "curve": "EcdsaSecp256k1",
        "signature": "017c36e8850679465e3beb4d8d945ec1875adb715cf62c2112025064b0a77a6ca818444970c69eafd2ed2ee1f50443498064aa477773a6dda5f49bfb84e2c4b834"
      },
      "signed_intent": {
        "intent": {
          "header": {
            "cost_unit_limit": "100000000",
            "end_epoch_exclusive": "105",
            "network_id": "1",
            "nonce": "5144",
            "notary_as_signatory": false,
            "notary_public_key": {
              "curve": "EcdsaSecp256k1",
              "public_key": "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
            },
            "start_epoch_inclusive": "100",
            "tip_percentage": "12",
            "version": "1"
          },
          "manifest": {
            "blobs": [],
            "instructions": {
              "type": "Parsed",
              "value": [
                {
                  "instruction": "DROP_ALL_PROOFS"
                }
              ]
            }
          }
        },
        "intent_signatures": [
          {
            "curve": "EcdsaSecp256k1",
            "signature": "008db363f3dfda37dfc9e7d45eb72c2405939124b3b962df506fa9cca0017be0092e1341b79694228c4f53c80e790ef9258aafbf5051769a126ddf588016ad282f"
          },
          {
            "curve": "EcdsaSecp256k1",
            "signature": "0174adbe3362c446ea2368ee1986864edc18f3eefc8b9ea0162756f04ffed310450a327cb3f8873070fc607844acec45b46490b4892fc4110c920ae28251b79100"
          },
          {
            "curve": "EcdsaSecp256k1",
            "signature": "01f55560f0fd9c1a90fca4a01c0e6cb613840ecd0a07fec7401e5e51b93f44df15586ec4a3d33a1811a6238e397e9964a1126ff32378dc5626c5126499ba3aac44"
          },
          {
            "curve": "EcdsaSecp256k1",
            "signature": "003fbca8a171f60a9a30a93fce9e846f130fee2a5989b7a93212877bf38f0afbb82ba7c9b718882bbf99a97f74fca1fe86ab4e6d85238873b29e851c193a48222e"
          },
          {
            "curve": "EddsaEd25519",
            "public_key": "7422b9887598068e32c4448a949adb290d0f4e35b9e01b0ee5f1a1e600fe2674",
            "signature": "0903d71eb96aa704338365d3ae15c0e8ca08d29aa1828a0439ecd0f0b64ba3fbee4f44c0bd694d08be51ebbb7d07c61961875894938b827627e5a77367b7320d"
          },
          {
            "curve": "EddsaEd25519",
            "public_key": "f381626e41e7027ea431bfe3009e94bdd25a746beec468948d6c3c7c5dc9a54b",
            "signature": "fce6e33719e6bf51f0ebe35cfe1ba26ce167063da7c7eaf48ecde64e3eb21bfcc2752c793c36a04493f52798bfcaaca66af70d889655067b1b5f3014f6cc7b0b"
          },
          {
            "curve": "EddsaEd25519",
            "public_key": "fd50b8e3b144ea244fbf7737f550bc8dd0c2650bbc1aada833ca17ff8dbf329b",
            "signature": "0a57400709fa697cc26268e959f29b1bc1d5fb6ed9b6a75381ca610cb9208f3a51ea72eced28e8e0636693a27e5019435827624e599aad30bfca4abbdae58b09"
          },
          {
            "curve": "EddsaEd25519",
            "public_key": "fde4fba030ad002f7c2f7d4c331f49d13fb0ec747eceebec634f1ff4cbca9def",
            "signature": "b3e149d3ce05f5e0e692e449095c8c0afbf0e51bd226ce087dd6f927c351240481440518695ed9521af29abac1e4fd59bf58ed251c0522dd55eda773d2b83504"
          }
        ]
      }
    }
  ],
  "type": "object",
  "required": [
    "notary_signature",
    "signed_intent"
  ],
  "properties": {
    "signed_intent": {
      "description": "The signed transaction intent of the transaction.",
      "allOf": [
        {
          "$ref": "#/definitions/SignedTransactionIntent"
        }
      ]
    },
    "notary_signature": {
      "description": "The signature of the notary on the signed transaction intent.",
      "allOf": [
        {
          "$ref": "#/definitions/Signature"
        }
      ]
    }
  },
  "definitions": {
    "SignedTransactionIntent": {
      "description": "A signed transaction intent which is made up of the intent as well as the intent signatures.",
      "examples": [
        {
          "intent": {
            "header": {
              "cost_unit_limit": "100000000",
              "end_epoch_exclusive": "105",
              "network_id": "1",
              "nonce": "5144",
              "notary_as_signatory": false,
              "notary_public_key": {
                "curve": "EcdsaSecp256k1",
                "public_key": "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
              },
              "start_epoch_inclusive": "100",
              "tip_percentage": "12",
              "version": "1"
            },
            "manifest": {
              "blobs": [],
              "instructions": {
                "type": "Parsed",
                "value": [
                  {
                    "instruction": "DROP_ALL_PROOFS"
                  }
                ]
              }
            }
          },
          "intent_signatures": [
            {
              "curve": "EcdsaSecp256k1",
              "signature": "008db363f3dfda37dfc9e7d45eb72c2405939124b3b962df506fa9cca0017be0092e1341b79694228c4f53c80e790ef9258aafbf5051769a126ddf588016ad282f"
            },
            {
              "curve": "EcdsaSecp256k1",
              "signature": "0174adbe3362c446ea2368ee1986864edc18f3eefc8b9ea0162756f04ffed310450a327cb3f8873070fc607844acec45b46490b4892fc4110c920ae28251b79100"
            },
            {
              "curve": "EcdsaSecp256k1",
              "signature": "01f55560f0fd9c1a90fca4a01c0e6cb613840ecd0a07fec7401e5e51b93f44df15586ec4a3d33a1811a6238e397e9964a1126ff32378dc5626c5126499ba3aac44"
            },
            {
              "curve": "EcdsaSecp256k1",
              "signature": "003fbca8a171f60a9a30a93fce9e846f130fee2a5989b7a93212877bf38f0afbb82ba7c9b718882bbf99a97f74fca1fe86ab4e6d85238873b29e851c193a48222e"
            },
            {
              "curve": "EddsaEd25519",
              "public_key": "7422b9887598068e32c4448a949adb290d0f4e35b9e01b0ee5f1a1e600fe2674",
              "signature": "0903d71eb96aa704338365d3ae15c0e8ca08d29aa1828a0439ecd0f0b64ba3fbee4f44c0bd694d08be51ebbb7d07c61961875894938b827627e5a77367b7320d"
            },
            {
              "curve": "EddsaEd25519",
              "public_key": "f381626e41e7027ea431bfe3009e94bdd25a746beec468948d6c3c7c5dc9a54b",
              "signature": "fce6e33719e6bf51f0ebe35cfe1ba26ce167063da7c7eaf48ecde64e3eb21bfcc2752c793c36a04493f52798bfcaaca66af70d889655067b1b5f3014f6cc7b0b"
            },
            {
              "curve": "EddsaEd25519",
              "public_key": "fd50b8e3b144ea244fbf7737f550bc8dd0c2650bbc1aada833ca17ff8dbf329b",
              "signature": "0a57400709fa697cc26268e959f29b1bc1d5fb6ed9b6a75381ca610cb9208f3a51ea72eced28e8e0636693a27e5019435827624e599aad30bfca4abbdae58b09"
            },
            {
              "curve": "EddsaEd25519",
              "public_key": "fde4fba030ad002f7c2f7d4c331f49d13fb0ec747eceebec634f1ff4cbca9def",
              "signature": "b3e149d3ce05f5e0e692e449095c8c0afbf0e51bd226ce087dd6f927c351240481440518695ed9521af29abac1e4fd59bf58ed251c0522dd55eda773d2b83504"
            }
          ]
        }
      ],
      "type": "object",
      "required": [
        "intent",
        "intent_signatures"
      ],
      "properties": {
        "intent": {
          "description": "The intent of the transaction.",
          "allOf": [
            {
              "$ref": "#/definitions/TransactionIntent"
            }
          ]
        },
        "intent_signatures": {
          "description": "A vector of transaction intent signatures.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/SignatureWithPublicKey"
          }
        }
      }
    },
    "TransactionIntent": {
      "description": "A transaction intent which is made of the header containing the transaction metadata and a manifest consisting of the instructions and blobs.",
      "examples": [
        {
          "header": {
            "cost_unit_limit": "100000000",
            "end_epoch_exclusive": "105",
            "network_id": "1",
            "nonce": "5144",
            "notary_as_signatory": false,
            "notary_public_key": {
              "curve": "EcdsaSecp256k1",
              "public_key": "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
            },
            "start_epoch_inclusive": "100",
            "tip_percentage": "12",
            "version": "1"
          },
          "manifest": {
            "blobs": [],
            "instructions": {
              "type": "String",
              "value": "DROP_ALL_PROOFS;"
            }
          }
        }
      ],
      "type": "object",
      "required": [
        "header",
        "manifest"
      ],
      "properties": {
        "header": {
          "description": "A transaction header of the transaction metadata.",
          "allOf": [
            {
              "$ref": "#/definitions/TransactionHeader"
            }
          ]
        },
        "manifest": {
          "description": "A transaction manifest of the transaction instructions and blobs.",
          "allOf": [
            {
              "$ref": "#/definitions/TransactionManifest"
            }
          ]
        }
      }
    },
    "TransactionHeader": {
      "description": "A transaction header containing metadata and other transaction information.",
      "examples": [
        {
          "cost_unit_limit": "100000000",
          "end_epoch_exclusive": "105",
          "network_id": "1",
          "nonce": "5144",
          "notary_as_signatory": false,
          "notary_public_key": {
            "curve": "EcdsaSecp256k1",
            "public_key": "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
          },
          "start_epoch_inclusive": "100",
          "tip_percentage": "12",
          "version": "1"
        },
        {
          "cost_unit_limit": "100000000",
          "end_epoch_exclusive": "105",
          "network_id": "1",
          "nonce": "5144",
          "notary_as_signatory": false,
          "notary_public_key": {
            "curve": "EddsaEd25519",
            "public_key": "4cb5abf6ad79fbf5abbccafcc269d85cd2651ed4b885b5869f241aedf0a5ba29"
          },
          "start_epoch_inclusive": "100",
          "tip_percentage": "12",
          "version": "1"
        }
      ],
      "type": "object",
      "required": [
        "cost_unit_limit",
        "end_epoch_exclusive",
        "network_id",
        "nonce",
        "notary_as_signatory",
        "notary_public_key",
        "start_epoch_inclusive",
        "tip_percentage",
        "version"
      ],
      "properties": {
        "version": {
          "description": "An 8 bit unsigned integer serialized as a string which represents the transaction version. Currently, this value is always 1.",
          "type": "string"
        },
        "network_id": {
          "description": "An 8 bit unsigned integer serialized as a string which represents the id of the network that this transaction is meant for.",
          "type": "string"
        },
        "start_epoch_inclusive": {
          "description": "A 64 bit unsigned integer serialized as a string which represents the start of the epoch window in which this transaction executes. This value is inclusive.",
          "type": "string"
        },
        "end_epoch_exclusive": {
          "description": "A 64 bit unsigned integer serialized as a string which represents the end of the epoch window in which this transaction executes. This value is exclusive.",
          "type": "string"
        },
        "nonce": {
          "description": "A 64 bit unsigned integer serialized as a string which represents a random nonce used for this transaction.",
          "type": "string"
        },
        "notary_public_key": {
          "description": "The public key of the entity that will be notarizing this transaction.",
          "allOf": [
            {
              "$ref": "#/definitions/PublicKey"
            }
          ]
        },
        "notary_as_signatory": {
          "description": "When `true` the notary's signature is also treated as an intent signature and therefore a virtual badge of the signature is added to the auth zone when the transaction auth zone at the beginning of the transaction.",
          "type": "boolean"
        },
        "cost_unit_limit": {
          "description": "A 32 bit unsigned integer serialized as a string which represents the limit or maximum amount of cost units that the transaction is allowed to use.",
          "type": "string"
        },
        "tip_percentage": {
          "description": "A 16 bit unsigned integer serialized as a string which represents the percentage of tips given to validators for this transaction.",
          "type": "string"
        }
      }
    },
    "PublicKey": {
      "description": "A discriminated union of the possible public keys used by Scrypto and the Radix Engine.",
      "oneOf": [
        {
          "description": "A byte array of 33 bytes which are serialized as a 66 character long hex-encoded string representing a public key from the ECDSA Secp256k1 elliptic curve.",
          "examples": [
            {
              "curve": "EcdsaSecp256k1",
              "public_key": "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
            }
          ],
          "type": "object",
          "required": [
            "curve",
            "public_key"
          ],
          "properties": {
            "curve": {
              "type": "string",
              "enum": [
                "EcdsaSecp256k1"
              ]
            },
            "public_key": {
              "type": "string",
              "maxLength": 66,
              "minLength": 66,
              "pattern": "[0-9a-fA-F]+"
            }
          }
        },
        {
          "description": "A byte array of 32 bytes which are serialized as a 64 character long hex-encoded string representing a public key from the EDDSA Ed25519 edwards curve.",
          "examples": [
            {
              "curve": "EddsaEd25519",
              "public_key": "4cb5abf6ad79fbf5abbccafcc269d85cd2651ed4b885b5869f241aedf0a5ba29"
            }
          ],
          "type": "object",
          "required": [
            "curve",
            "public_key"
          ],
          "properties": {
            "curve": {
              "type": "string",
              "enum": [
                "EddsaEd25519"
              ]
            },
            "public_key": {
              "type": "string",
              "maxLength": 66,
              "minLength": 66,
              "pattern": "[0-9a-fA-F]+"
            }
          }
        }
      ]
    },
    "TransactionManifest": {
      "description": "A transaction intent consisting of instructions as well as blobs",
      "examples": [
        {
          "blobs": [],
          "instructions": {
            "type": "String",
            "value": "DROP_ALL_PROOFS;"
          }
        }
      ],
      "type": "object",
      "required": [
        "blobs",
        "instructions"
      ],
      "properties": {
        "instructions": {
          "description": "The transaction manifest instructions to be executed in the transaction.",
          "allOf": [
            {
              "$ref": "#/definitions/InstructionList"
            }
          ]
        },
        "blobs": {
          "description": "An array of byte arrays which is serialized as an array of hex strings which represents the blobs included in the transaction.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "InstructionList": {
      "description": "A discriminated union of possible representations of manifest instructions. Currently, two representations are supported: a string representation which is the same as that seen in the local simulator, resim, and pretty much everywhere, as well as a parsed format which is a vector of instructions where each instruction is represented through the `Instruction` model.",
      "oneOf": [
        {
          "examples": [
            {
              "type": "String",
              "value": "DROP_ALL_PROOFS;"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "String"
              ]
            },
            "value": {
              "type": "string"
            }
          }
        },
        {
          "examples": [
            {
              "type": "Parsed",
              "value": [
                {
                  "instruction": "DROP_ALL_PROOFS"
                }
              ]
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Parsed"
              ]
            },
            "value": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Instruction"
              }
            }
          }
        }
      ]
    },
    "Instruction": {
      "description": "The Instruction model defines the structure that transaction manifest instructions follow during communication with the Radix Engine Toolkit",
      "oneOf": [
        {
          "description": "An instruction to call a function with the given list of arguments on the given package address and blueprint name.",
          "examples": [
            {
              "arguments": [
                {
                  "type": "Decimal",
                  "value": "1"
                }
              ],
              "blueprint_name": {
                "type": "String",
                "value": "Faucet"
              },
              "function_name": {
                "type": "String",
                "value": "new"
              },
              "instruction": "CALL_FUNCTION",
              "package_address": {
                "address": "package_rdx1qyqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpqqzrhqe8",
                "type": "Address"
              }
            },
            {
              "arguments": [
                {
                  "type": "Decimal",
                  "value": "1"
                }
              ],
              "blueprint_name": {
                "type": "String",
                "value": "Faucet"
              },
              "function_name": {
                "type": "String",
                "value": "new"
              },
              "instruction": "CALL_FUNCTION",
              "package_address": {
                "address": "package_rdx1qyqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpqqzrhqe8",
                "type": "Address"
              }
            },
            {
              "arguments": [
                {
                  "type": "Decimal",
                  "value": "1"
                }
              ],
              "blueprint_name": {
                "type": "String",
                "value": "Faucet"
              },
              "function_name": {
                "type": "String",
                "value": "new"
              },
              "instruction": "CALL_FUNCTION",
              "package_address": {
                "address": "package_rdx1qyqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpqqzrhqe8",
                "type": "Address"
              }
            },
            {
              "arguments": [
                {
                  "type": "Decimal",
                  "value": "1"
                }
              ],
              "blueprint_name": {
                "type": "String",
                "value": "Faucet"
              },
              "function_name": {
                "type": "String",
                "value": "new"
              },
              "instruction": "CALL_FUNCTION",
              "package_address": {
                "address": "package_rdx1qyqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpqqzrhqe8",
                "type": "Address"
              }
            }
          ],
          "type": "object",
          "required": [
            "blueprint_name",
            "function_name",
            "instruction",
            "package_address"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "CALL_FUNCTION"
              ]
            },
            "package_address": {
              "description": "The address of the package containing the blueprint that contains the desired function. This package address is serialized as the `PackageAddress` variant of the `ManifestAstValue` model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "blueprint_name": {
              "description": "A string of the name of the blueprint containing the desired function. This field is serialized as a `String` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "function_name": {
              "description": "A string of the name of the function to call. This field is serialized as a `String` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "arguments": {
              "description": "An optional array of `ManifestAstValue` arguments to call the function with. If this array is empty or is not provided, then the function is called with no arguments.",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "$ref": "#/definitions/ManifestAstValue"
              }
            }
          }
        },
        {
          "description": "An instruction to call a method with a given name on a given component address with the given list of arguments.",
          "examples": [
            {
              "arguments": [
                {
                  "type": "Decimal",
                  "value": "1"
                }
              ],
              "component_address": {
                "address": "component_rdx1qtkryz5scup945usk39qjc2yjh6l5zsyuh8t7v5pk0tsrdcazt",
                "type": "Address"
              },
              "instruction": "CALL_METHOD",
              "method_name": {
                "type": "String",
                "value": "free"
              }
            },
            {
              "arguments": [
                {
                  "type": "Decimal",
                  "value": "1"
                }
              ],
              "component_address": {
                "address": "component_rdx1qtkryz5scup945usk39qjc2yjh6l5zsyuh8t7v5pk0tsrdcazt",
                "type": "Address"
              },
              "instruction": "CALL_METHOD",
              "method_name": {
                "type": "String",
                "value": "free"
              }
            },
            {
              "arguments": null,
              "component_address": {
                "address": "component_rdx1qtkryz5scup945usk39qjc2yjh6l5zsyuh8t7v5pk0tsrdcazt",
                "type": "Address"
              },
              "instruction": "CALL_METHOD",
              "method_name": {
                "type": "String",
                "value": "free"
              }
            },
            {
              "arguments": null,
              "component_address": {
                "address": "component_rdx1qtkryz5scup945usk39qjc2yjh6l5zsyuh8t7v5pk0tsrdcazt",
                "type": "Address"
              },
              "instruction": "CALL_METHOD",
              "method_name": {
                "type": "String",
                "value": "free"
              }
            }
          ],
          "type": "object",
          "required": [
            "component_address",
            "instruction",
            "method_name"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "CALL_METHOD"
              ]
            },
            "component_address": {
              "description": "The address of the component which contains the method to be invoked. This field is serialized as a `ComponentAddress` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "method_name": {
              "description": "A string of the name of the method to call. his field is serialized as a `String` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "arguments": {
              "description": "An optional array of `ManifestAstValue` arguments to call the method with. If this array is empty or is not provided, then the method is called with no arguments.",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "$ref": "#/definitions/ManifestAstValue"
              }
            }
          }
        },
        {
          "description": "An instruction to take the entire amount of a given resource address from the worktop and put it in a bucket.",
          "examples": [
            {
              "instruction": "TAKE_FROM_WORKTOP",
              "into_bucket": {
                "identifier": {
                  "type": "String",
                  "value": "ident"
                },
                "type": "Bucket"
              },
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqy99qqm",
                "type": "Address"
              }
            },
            {
              "instruction": "TAKE_FROM_WORKTOP",
              "into_bucket": {
                "identifier": {
                  "type": "String",
                  "value": "ident"
                },
                "type": "Bucket"
              },
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqy99qqm",
                "type": "Address"
              }
            }
          ],
          "type": "object",
          "required": [
            "instruction",
            "into_bucket",
            "resource_address"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "TAKE_FROM_WORKTOP"
              ]
            },
            "resource_address": {
              "description": "The address of the resource to take from the worktop. This field is serialized as a `ResourceAddress` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "into_bucket": {
              "description": "A bucket to put the taken resources into. This field is serialized as a `Bucket` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to take the an amount of a given resource address from the worktop and put it in a bucket.",
          "examples": [
            {
              "amount": {
                "type": "Decimal",
                "value": "1"
              },
              "instruction": "TAKE_FROM_WORKTOP_BY_AMOUNT",
              "into_bucket": {
                "identifier": {
                  "type": "String",
                  "value": "ident"
                },
                "type": "Bucket"
              },
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqy99qqm",
                "type": "Address"
              }
            },
            {
              "amount": {
                "type": "Decimal",
                "value": "1"
              },
              "instruction": "TAKE_FROM_WORKTOP_BY_AMOUNT",
              "into_bucket": {
                "identifier": {
                  "type": "String",
                  "value": "ident"
                },
                "type": "Bucket"
              },
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqy99qqm",
                "type": "Address"
              }
            }
          ],
          "type": "object",
          "required": [
            "amount",
            "instruction",
            "into_bucket",
            "resource_address"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "TAKE_FROM_WORKTOP_BY_AMOUNT"
              ]
            },
            "resource_address": {
              "description": "The address of the resource to take from the worktop. This field is serialized as a `ResourceAddress` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "amount": {
              "description": "The amount of the resource to take from the worktop. This field is serialized as a `Decimal` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "into_bucket": {
              "description": "A bucket to put the taken resources into. This field is serialized as a `Bucket` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to take the a set of non-fungible ids of a given resource address from the worktop and put it in a bucket.",
          "examples": [
            {
              "ids": [
                {
                  "type": "NonFungibleLocalId",
                  "value": {
                    "type": "Integer",
                    "value": "1"
                  }
                }
              ],
              "instruction": "TAKE_FROM_WORKTOP_BY_IDS",
              "into_bucket": {
                "identifier": {
                  "type": "String",
                  "value": "ident"
                },
                "type": "Bucket"
              },
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqy99qqm",
                "type": "Address"
              }
            },
            {
              "ids": [
                {
                  "type": "NonFungibleLocalId",
                  "value": {
                    "type": "Integer",
                    "value": "1"
                  }
                }
              ],
              "instruction": "TAKE_FROM_WORKTOP_BY_IDS",
              "into_bucket": {
                "identifier": {
                  "type": "String",
                  "value": "ident"
                },
                "type": "Bucket"
              },
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqy99qqm",
                "type": "Address"
              }
            }
          ],
          "type": "object",
          "required": [
            "ids",
            "instruction",
            "into_bucket",
            "resource_address"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "TAKE_FROM_WORKTOP_BY_IDS"
              ]
            },
            "resource_address": {
              "description": "The address of the resource to take from the worktop. This field is serialized as a `ResourceAddress` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "ids": {
              "description": "The non-fungible ids to take from the worktop. This is a set (serialized as a JSON array) of `NonFungibleLocalId`s from the ManifestAstValue model.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/NonFungibleLocalId"
              },
              "uniqueItems": true
            },
            "into_bucket": {
              "description": "A bucket to put the taken resources into. This field is serialized as a `Bucket` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "Returns a bucket of tokens to the worktop.",
          "examples": [
            {
              "bucket": {
                "identifier": {
                  "type": "String",
                  "value": "ident"
                },
                "type": "Bucket"
              },
              "instruction": "RETURN_TO_WORKTOP"
            }
          ],
          "type": "object",
          "required": [
            "bucket",
            "instruction"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "RETURN_TO_WORKTOP"
              ]
            },
            "bucket": {
              "description": "The bucket to return to the worktop.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to assert that a given resource exists in the worktop.",
          "examples": [
            {
              "instruction": "ASSERT_WORKTOP_CONTAINS",
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqy99qqm",
                "type": "Address"
              }
            },
            {
              "instruction": "ASSERT_WORKTOP_CONTAINS",
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqy99qqm",
                "type": "Address"
              }
            }
          ],
          "type": "object",
          "required": [
            "instruction",
            "resource_address"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "ASSERT_WORKTOP_CONTAINS"
              ]
            },
            "resource_address": {
              "description": "The address of the resource to perform the assertion on. This field is serialized as a `ResourceAddress` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to assert that a specific amount of a specific resource address exists in the worktop.",
          "examples": [
            {
              "amount": {
                "type": "Decimal",
                "value": "1"
              },
              "instruction": "ASSERT_WORKTOP_CONTAINS_BY_AMOUNT",
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqy99qqm",
                "type": "Address"
              }
            },
            {
              "amount": {
                "type": "Decimal",
                "value": "1"
              },
              "instruction": "ASSERT_WORKTOP_CONTAINS_BY_AMOUNT",
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqy99qqm",
                "type": "Address"
              }
            }
          ],
          "type": "object",
          "required": [
            "amount",
            "instruction",
            "resource_address"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "ASSERT_WORKTOP_CONTAINS_BY_AMOUNT"
              ]
            },
            "resource_address": {
              "description": "The address of the resource to perform the assertion on. This field is serialized as a `ResourceAddress` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "amount": {
              "description": "The amount of the resource to assert their existence in the worktop. This field is serialized as a `Decimal` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to assert that a set ids of a specific resource address exists in the worktop.",
          "examples": [
            {
              "ids": [
                {
                  "type": "NonFungibleLocalId",
                  "value": {
                    "type": "Integer",
                    "value": "1"
                  }
                }
              ],
              "instruction": "ASSERT_WORKTOP_CONTAINS_BY_IDS",
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqy99qqm",
                "type": "Address"
              }
            },
            {
              "ids": [
                {
                  "type": "NonFungibleLocalId",
                  "value": {
                    "type": "Integer",
                    "value": "1"
                  }
                }
              ],
              "instruction": "ASSERT_WORKTOP_CONTAINS_BY_IDS",
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqy99qqm",
                "type": "Address"
              }
            }
          ],
          "type": "object",
          "required": [
            "ids",
            "instruction",
            "resource_address"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "ASSERT_WORKTOP_CONTAINS_BY_IDS"
              ]
            },
            "resource_address": {
              "description": "The address of the resource to perform the assertion on. This field is serialized as a `ResourceAddress` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "ids": {
              "description": "The non-fungible ids of the resource to assert their existence in the worktop. This is a set (serialized as a JSON array) of `NonFungibleLocalId`s from the ManifestAstValue model.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/NonFungibleLocalId"
              },
              "uniqueItems": true
            }
          }
        },
        {
          "description": "An instruction which pops a proof from the AuthZone stack and into an identifiable proof",
          "examples": [
            {
              "instruction": "POP_FROM_AUTH_ZONE",
              "into_proof": {
                "identifier": {
                  "type": "String",
                  "value": "ident"
                },
                "type": "Proof"
              }
            }
          ],
          "type": "object",
          "required": [
            "instruction",
            "into_proof"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "POP_FROM_AUTH_ZONE"
              ]
            },
            "into_proof": {
              "description": "The proof to put the popped proof into. This is serialized as a `Proof` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction that pushes a proof to the auth zone stack.",
          "examples": [
            {
              "instruction": "PUSH_TO_AUTH_ZONE",
              "proof": {
                "identifier": {
                  "type": "String",
                  "value": "ident"
                },
                "type": "Proof"
              }
            }
          ],
          "type": "object",
          "required": [
            "instruction",
            "proof"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "PUSH_TO_AUTH_ZONE"
              ]
            },
            "proof": {
              "description": "The proof to push to the auth zone stack. This is serialized as a `Proof` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction which clears the auth zone stack by dropping all of the proofs in that stack.",
          "examples": [
            {
              "instruction": "CLEAR_AUTH_ZONE"
            }
          ],
          "type": "object",
          "required": [
            "instruction"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "CLEAR_AUTH_ZONE"
              ]
            }
          }
        },
        {
          "description": "An instruction to create a proof of the entire amount of a given resource address from the auth zone.",
          "examples": [
            {
              "instruction": "CREATE_PROOF_FROM_AUTH_ZONE",
              "into_proof": {
                "identifier": {
                  "type": "String",
                  "value": "ident"
                },
                "type": "Proof"
              },
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqy99qqm",
                "type": "Address"
              }
            },
            {
              "instruction": "CREATE_PROOF_FROM_AUTH_ZONE",
              "into_proof": {
                "identifier": {
                  "type": "String",
                  "value": "ident"
                },
                "type": "Proof"
              },
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqy99qqm",
                "type": "Address"
              }
            }
          ],
          "type": "object",
          "required": [
            "instruction",
            "into_proof",
            "resource_address"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "CREATE_PROOF_FROM_AUTH_ZONE"
              ]
            },
            "resource_address": {
              "description": "The address of the resource to create a proof of. This field is serialized as a `ResourceAddress` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "into_proof": {
              "description": "A proof to put the resource proof into. This field is serialized as a `Proof` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to create a proof of the an amount of a given resource address from the auth zone.",
          "examples": [
            {
              "amount": {
                "type": "Decimal",
                "value": "1"
              },
              "instruction": "CREATE_PROOF_FROM_AUTH_ZONE_BY_AMOUNT",
              "into_proof": {
                "identifier": {
                  "type": "String",
                  "value": "ident"
                },
                "type": "Proof"
              },
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqy99qqm",
                "type": "Address"
              }
            },
            {
              "amount": {
                "type": "Decimal",
                "value": "1"
              },
              "instruction": "CREATE_PROOF_FROM_AUTH_ZONE_BY_AMOUNT",
              "into_proof": {
                "identifier": {
                  "type": "String",
                  "value": "ident"
                },
                "type": "Proof"
              },
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqy99qqm",
                "type": "Address"
              }
            }
          ],
          "type": "object",
          "required": [
            "amount",
            "instruction",
            "into_proof",
            "resource_address"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "CREATE_PROOF_FROM_AUTH_ZONE_BY_AMOUNT"
              ]
            },
            "resource_address": {
              "description": "The address of the resource to create a proof of. This field is serialized as a `ResourceAddress` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "amount": {
              "description": "The amount of the resource to create a proof of. This field is serialized as a `Decimal` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "into_proof": {
              "description": "A proof to put the resource proof into. This field is serialized as a `Proof` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to create a proof of the a set of non-fungible ids of a given resource address from the auth zone.",
          "examples": [
            {
              "ids": [
                {
                  "type": "NonFungibleLocalId",
                  "value": {
                    "type": "Integer",
                    "value": "1"
                  }
                }
              ],
              "instruction": "CREATE_PROOF_FROM_AUTH_ZONE_BY_IDS",
              "into_proof": {
                "identifier": {
                  "type": "String",
                  "value": "ident"
                },
                "type": "Proof"
              },
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqy99qqm",
                "type": "Address"
              }
            },
            {
              "ids": [
                {
                  "type": "NonFungibleLocalId",
                  "value": {
                    "type": "Integer",
                    "value": "1"
                  }
                }
              ],
              "instruction": "CREATE_PROOF_FROM_AUTH_ZONE_BY_IDS",
              "into_proof": {
                "identifier": {
                  "type": "String",
                  "value": "ident"
                },
                "type": "Proof"
              },
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqy99qqm",
                "type": "Address"
              }
            }
          ],
          "type": "object",
          "required": [
            "ids",
            "instruction",
            "into_proof",
            "resource_address"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "CREATE_PROOF_FROM_AUTH_ZONE_BY_IDS"
              ]
            },
            "resource_address": {
              "description": "The address of the resource to create a proof of. This field is serialized as a `ResourceAddress` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "ids": {
              "description": "The non-fungible ids to create a proof of. This is a set (serialized as a JSON array) of `NonFungibleLocalId`s from the ManifestAstValue model.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/NonFungibleLocalId"
              },
              "uniqueItems": true
            },
            "into_proof": {
              "description": "A proof to put the resource proof into. This field is serialized as a `Proof` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to create a proof given a bucket of some resources",
          "examples": [
            {
              "bucket": {
                "identifier": {
                  "type": "String",
                  "value": "bucket"
                },
                "type": "Bucket"
              },
              "instruction": "CREATE_PROOF_FROM_BUCKET",
              "into_proof": {
                "identifier": {
                  "type": "String",
                  "value": "Proof"
                },
                "type": "Proof"
              }
            }
          ],
          "type": "object",
          "required": [
            "bucket",
            "instruction",
            "into_proof"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "CREATE_PROOF_FROM_BUCKET"
              ]
            },
            "bucket": {
              "description": "The bucket of resources to create a proof from. This field is serialized as a `Bucket` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "into_proof": {
              "description": "The proof variable that the proof should go to. This field is serialized as a `Proof` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to clone a proof creating a second proof identical to the original",
          "examples": [
            {
              "instruction": "CLONE_PROOF",
              "into_proof": {
                "identifier": {
                  "type": "String",
                  "value": "ident2"
                },
                "type": "Proof"
              },
              "proof": {
                "identifier": {
                  "type": "String",
                  "value": "ident"
                },
                "type": "Proof"
              }
            }
          ],
          "type": "object",
          "required": [
            "instruction",
            "into_proof",
            "proof"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "CLONE_PROOF"
              ]
            },
            "proof": {
              "description": "The original proof, or the proof to be cloned. This field is serialized as a `Proof` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "into_proof": {
              "description": "The proof variable that the proof should go to. This field is serialized as a `Proof` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to drop a proof.",
          "examples": [
            {
              "bucket": {
                "identifier": {
                  "type": "String",
                  "value": "ident"
                },
                "type": "Bucket"
              },
              "instruction": "BURN_RESOURCE"
            }
          ],
          "type": "object",
          "required": [
            "instruction",
            "proof"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "DROP_PROOF"
              ]
            },
            "proof": {
              "description": "The proof to drop. This field is serialized as a `Proof` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to drop all proofs currently present in the transaction context.",
          "examples": [
            {
              "instruction": "DROP_ALL_PROOFS"
            }
          ],
          "type": "object",
          "required": [
            "instruction"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "DROP_ALL_PROOFS"
              ]
            }
          }
        },
        {
          "description": "An instruction to publish a package and set it's associated royalty configs, metadata, and access rules.",
          "examples": [
            {
              "access_rules": {
                "elements": [
                  {
                    "entries": [],
                    "key_value_kind": "Tuple",
                    "type": "Map",
                    "value_value_kind": "Enum"
                  },
                  {
                    "entries": [],
                    "key_value_kind": "String",
                    "type": "Map",
                    "value_value_kind": "Enum"
                  },
                  {
                    "type": "Enum",
                    "variant": {
                      "discriminator": "0",
                      "type": "U8"
                    }
                  },
                  {
                    "entries": [],
                    "key_value_kind": "Tuple",
                    "type": "Map",
                    "value_value_kind": "Enum"
                  },
                  {
                    "entries": [],
                    "key_value_kind": "String",
                    "type": "Map",
                    "value_value_kind": "Enum"
                  },
                  {
                    "type": "Enum",
                    "variant": {
                      "discriminator": "0",
                      "type": "U8"
                    }
                  }
                ],
                "type": "Tuple"
              },
              "code": {
                "hash": "01ba4719c80b6fe911b091a7c05124b64eeece964e09c058ef8f9805daca546b",
                "type": "Blob"
              },
              "instruction": "PUBLISH_PACKAGE",
              "metadata": {
                "entries": [],
                "key_value_kind": "String",
                "type": "Map",
                "value_value_kind": "String"
              },
              "royalty_config": {
                "entries": [],
                "key_value_kind": "String",
                "type": "Map",
                "value_value_kind": "Tuple"
              },
              "schema": {
                "hash": "01ba4719c80b6fe911b091a7c05124b64eeece964e09c058ef8f9805daca546b",
                "type": "Blob"
              }
            }
          ],
          "type": "object",
          "required": [
            "access_rules",
            "code",
            "instruction",
            "metadata",
            "royalty_config",
            "schema"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "PUBLISH_PACKAGE"
              ]
            },
            "code": {
              "description": "The blob of the package code. This field is serialized as a `Blob` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "schema": {
              "description": "The blob of the package ABI. This field is serialized as a `Blob` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "royalty_config": {
              "description": "The configurations of the royalty for the package. The underlying type of this is a Map where the key is a string of the blueprint name and the value is a `RoyaltyConfig`. This is serialized as an `Map` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "metadata": {
              "description": "The metadata to use for the package. The underlying type of this is a string-string Map of the metadata. This is serialized as an `Map` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "access_rules": {
              "description": "The access rules to use for the package. This is serialized as a `Tuple` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to burn a bucket of tokens.",
          "examples": [
            {
              "instruction": "DROP_ALL_PROOFS"
            }
          ],
          "type": "object",
          "required": [
            "bucket",
            "instruction"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "BURN_RESOURCE"
              ]
            },
            "bucket": {
              "description": "The bucket of tokens to burn.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction ot recall resources from a known vault.",
          "examples": [
            {
              "amount": {
                "type": "Decimal",
                "value": "1"
              },
              "instruction": "RECALL_RESOURCE",
              "vault_id": {
                "type": "Bytes",
                "value": "a9d55474c4fe9b04a5f39dc8164b9a9c22dae66a34e1417162c327912cc492"
              }
            }
          ],
          "type": "object",
          "required": [
            "amount",
            "instruction",
            "vault_id"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "RECALL_RESOURCE"
              ]
            },
            "vault_id": {
              "description": "The id of the vault of the tokens to recall. This field is serialized as an `Own` from the value model and is expected to be an `Own::Vault`.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "amount": {
              "description": "The amount of tokens to recall from the vault. This field is serialized as a `Decimal` field from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to set the metadata on an entity.",
          "examples": [
            {
              "entity_address": {
                "address": "component_rdx1qtkryz5scup945usk39qjc2yjh6l5zsyuh8t7v5pk0tsrdcazt",
                "type": "Address"
              },
              "instruction": "SET_METADATA",
              "key": {
                "type": "String",
                "value": "name"
              },
              "value": {
                "fields": [
                  {
                    "fields": [
                      {
                        "type": "String",
                        "value": "deadbeef"
                      }
                    ],
                    "type": "Enum",
                    "variant": {
                      "discriminator": "0",
                      "type": "U8"
                    }
                  }
                ],
                "type": "Enum",
                "variant": {
                  "discriminator": "0",
                  "type": "U8"
                }
              }
            }
          ],
          "type": "object",
          "required": [
            "entity_address",
            "instruction",
            "key",
            "value"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "SET_METADATA"
              ]
            },
            "entity_address": {
              "description": "The address of the entity to set metadata on. This is a discriminated union of types where it can either be a `ResourceAddress`, `ComponentAddress`, `PackageAddress` or a `ComponentAddress`.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "key": {
              "description": "A string of the key to set the metadata for. This field is serialized as a `String` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "value": {
              "description": "A string of the value to set the metadata for. This field is serialized as a `String` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to set the metadata on an entity.",
          "examples": [
            {
              "entity_address": {
                "address": "component_rdx1qtkryz5scup945usk39qjc2yjh6l5zsyuh8t7v5pk0tsrdcazt",
                "type": "Address"
              },
              "instruction": "REMOVE_METADATA",
              "key": {
                "type": "String",
                "value": "name"
              }
            }
          ],
          "type": "object",
          "required": [
            "entity_address",
            "instruction",
            "key"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "REMOVE_METADATA"
              ]
            },
            "entity_address": {
              "description": "The address of the entity to set metadata on. This is a discriminated union of types where it can either be a `ResourceAddress`, `ComponentAddress`, `PackageAddress` or a `ComponentAddress`.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "key": {
              "description": "A string of the key to remove the metadata for. This field is serialized as a `String` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to modify the royalties of a package.",
          "examples": [
            {
              "instruction": "SET_PACKAGE_ROYALTY_CONFIG",
              "package_address": {
                "address": "package_rdx1qyqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpqqzrhqe8",
                "type": "Address"
              },
              "royalty_config": {
                "entries": [],
                "key_value_kind": "String",
                "type": "Map",
                "value_value_kind": "Tuple"
              }
            }
          ],
          "type": "object",
          "required": [
            "instruction",
            "package_address",
            "royalty_config"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "SET_PACKAGE_ROYALTY_CONFIG"
              ]
            },
            "package_address": {
              "description": "The address of the package to set the royalty on. This is serialized as a `PackageAddress` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "royalty_config": {
              "description": "The configurations of the royalty for the package. The underlying type of this is a Map where the key is a string of the blueprint name and the value is a `RoyaltyConfig`. This is serialized as an `Map` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to modify the royalties on a component",
          "examples": [
            {
              "component_address": {
                "address": "component_rdx1qtkryz5scup945usk39qjc2yjh6l5zsyuh8t7v5pk0tsrdcazt",
                "type": "Address"
              },
              "instruction": "SET_COMPONENT_ROYALTY_CONFIG",
              "royalty_config": {
                "elements": [
                  {
                    "entries": [],
                    "key_value_kind": "String",
                    "type": "Map",
                    "value_value_kind": "U32"
                  },
                  {
                    "type": "U32",
                    "value": "1"
                  }
                ],
                "type": "Tuple"
              }
            }
          ],
          "type": "object",
          "required": [
            "component_address",
            "instruction",
            "royalty_config"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "SET_COMPONENT_ROYALTY_CONFIG"
              ]
            },
            "component_address": {
              "description": "The component address of the component to modify royalties for. This field is serialized as a `ComponentAddress` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "royalty_config": {
              "description": "The royalty config to set on the component. This is an `Enum` from the `ManifestAstValue` model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to claim royalties of a package",
          "examples": [
            {
              "instruction": "CLAIM_PACKAGE_ROYALTY",
              "package_address": {
                "address": "package_rdx1qyqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpqqzrhqe8",
                "type": "Address"
              }
            }
          ],
          "type": "object",
          "required": [
            "instruction",
            "package_address"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "CLAIM_PACKAGE_ROYALTY"
              ]
            },
            "package_address": {
              "description": "The package address of the package to claim royalties for. This field is serialized as a `PackageAddress` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to claim royalties of a component",
          "examples": [
            {
              "component_address": {
                "address": "component_rdx1qtkryz5scup945usk39qjc2yjh6l5zsyuh8t7v5pk0tsrdcazt",
                "type": "Address"
              },
              "instruction": "CLAIM_COMPONENT_ROYALTY"
            }
          ],
          "type": "object",
          "required": [
            "component_address",
            "instruction"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "CLAIM_COMPONENT_ROYALTY"
              ]
            },
            "component_address": {
              "description": "The component address of the component to claim royalties for. This field is serialized as a `ComponentAddress` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to modify the access rules of a method that an entity has.",
          "examples": [
            {
              "entity_address": {
                "address": "component_rdx1qtkryz5scup945usk39qjc2yjh6l5zsyuh8t7v5pk0tsrdcazt",
                "type": "Address"
              },
              "instruction": "SET_METHOD_ACCESS_RULE",
              "key": {
                "elements": [
                  {
                    "type": "Enum",
                    "variant": {
                      "discriminator": "0",
                      "type": "U8"
                    }
                  },
                  {
                    "type": "String",
                    "value": "free"
                  }
                ],
                "type": "Tuple"
              },
              "rule": {
                "type": "Enum",
                "variant": {
                  "discriminator": "0",
                  "type": "U8"
                }
              }
            }
          ],
          "type": "object",
          "required": [
            "entity_address",
            "instruction",
            "key",
            "rule"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "SET_METHOD_ACCESS_RULE"
              ]
            },
            "entity_address": {
              "description": "The entity address of the entity to modify the access rules for.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "key": {
              "description": "The method key for the method to set the access rule of. This field is serialized as an `Enum` from the ManifestAstValue model",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "rule": {
              "description": "The new access rule to set in-place of the old one. This field is serialized as an `Enum` from the ManifestAstValue model",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to mint fungible resources",
          "examples": [
            {
              "amount": {
                "type": "Decimal",
                "value": "1"
              },
              "instruction": "MINT_FUNGIBLE",
              "resource_address": {
                "address": "resource_sim1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqz8qety",
                "type": "Address"
              }
            }
          ],
          "type": "object",
          "required": [
            "amount",
            "instruction",
            "resource_address"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "MINT_FUNGIBLE"
              ]
            },
            "resource_address": {
              "description": "The address of the resource to mint tokens of. This field is serialized as a `ResourceAddress` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "amount": {
              "description": "The amount of fungible tokens to mint of this resource. This field is serialized as a `Decimal` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to mint non-fungibles of a resource",
          "examples": [
            {
              "entries": {
                "entries": [],
                "key_value_kind": "NonFungibleLocalId",
                "type": "Map",
                "value_value_kind": "Tuple"
              },
              "instruction": "MINT_NON_FUNGIBLE",
              "resource_address": {
                "address": "resource_sim1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqz8qety",
                "type": "Address"
              }
            }
          ],
          "type": "object",
          "required": [
            "entries",
            "instruction",
            "resource_address"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "MINT_NON_FUNGIBLE"
              ]
            },
            "resource_address": {
              "description": "The address of the resource to mint tokens of. This field is serialized as a `ResourceAddress` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "entries": {
              "description": "The non-fungible tokens to mint. The underlying type of this is a map which maps a `NonFungibleLocalId` to a tuple of two `ManifestAstValue` elements where each element is a struct of the immutable and mutable parts of the non-fungible data.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to mint non-fungibles of a non-fungible resource that uses UUID as the type id and perform auto incrimination of ID.",
          "examples": [
            {
              "entries": {
                "element_kind": "Tuple",
                "elements": [
                  {
                    "elements": [
                      {
                        "elements": [],
                        "type": "Tuple"
                      },
                      {
                        "elements": [],
                        "type": "Tuple"
                      }
                    ],
                    "type": "Tuple"
                  },
                  {
                    "elements": [
                      {
                        "elements": [],
                        "type": "Tuple"
                      },
                      {
                        "elements": [],
                        "type": "Tuple"
                      }
                    ],
                    "type": "Tuple"
                  }
                ],
                "type": "Array"
              },
              "instruction": "MINT_UUID_NON_FUNGIBLE",
              "resource_address": {
                "address": "resource_sim1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqz8qety",
                "type": "Address"
              }
            }
          ],
          "type": "object",
          "required": [
            "entries",
            "instruction",
            "resource_address"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "MINT_UUID_NON_FUNGIBLE"
              ]
            },
            "resource_address": {
              "description": "The address of the resource to mint tokens of. This field is serialized as a `ResourceAddress` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "entries": {
              "description": "The non-fungible tokens to mint. The underlying type is a vector of tuples of two `ManifestAstValue` elements where each element is a struct of the immutable and mutable parts of the non-fungible data.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to create a new fungible resource.",
          "examples": [
            {
              "access_rules": {
                "entries": [],
                "key_value_kind": "Enum",
                "type": "Map",
                "value_value_kind": "Tuple"
              },
              "divisibility": {
                "type": "U8",
                "value": "18"
              },
              "instruction": "CREATE_FUNGIBLE_RESOURCE",
              "metadata": {
                "entries": [],
                "key_value_kind": "String",
                "type": "Map",
                "value_value_kind": "String"
              }
            }
          ],
          "type": "object",
          "required": [
            "access_rules",
            "divisibility",
            "instruction",
            "metadata"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "CREATE_FUNGIBLE_RESOURCE"
              ]
            },
            "divisibility": {
              "description": "The divisibility of the resource. This field is serialized as a `U8` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "metadata": {
              "description": "The metadata to set on the resource. The underlying type of this is a string-string Map of the metadata. This is serialized as an `Map` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "access_rules": {
              "description": "The access rules to use for the resource. The underlying type of this is a map which maps a `ResourceMethodAuthKey` enum to a tuple of two `AccessRule`s denoting the current behavior and the mutability. This is serialized as an `Map` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to create a fungible resource with initial supply",
          "examples": [
            {
              "access_rules": {
                "entries": [],
                "key_value_kind": "Enum",
                "type": "Map",
                "value_value_kind": "Tuple"
              },
              "divisibility": {
                "type": "U8",
                "value": "18"
              },
              "initial_supply": {
                "type": "Decimal",
                "value": "1"
              },
              "instruction": "CREATE_FUNGIBLE_RESOURCE_WITH_INITIAL_SUPPLY",
              "metadata": {
                "entries": [],
                "key_value_kind": "String",
                "type": "Map",
                "value_value_kind": "String"
              }
            }
          ],
          "type": "object",
          "required": [
            "access_rules",
            "divisibility",
            "initial_supply",
            "instruction",
            "metadata"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "CREATE_FUNGIBLE_RESOURCE_WITH_INITIAL_SUPPLY"
              ]
            },
            "divisibility": {
              "description": "The divisibility of the resource. This field is serialized as a `U8` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "metadata": {
              "description": "The metadata to set on the resource. The underlying type of this is a string-string Map of the metadata. This is serialized as an `Map` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "access_rules": {
              "description": "The access rules to use for the resource. The underlying type of this is a map which maps a `ResourceMethodAuthKey` enum to a tuple of two `AccessRule`s denoting the current behavior and the mutability. This is serialized as an `Map` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "initial_supply": {
              "description": "A decimal value of the initial supply to mint during resource creation. If present, this is serialized as a `Decimal` from the value model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to create a new non-fungible resource.",
          "examples": [
            {
              "access_rules": {
                "entries": [],
                "key_value_kind": "Enum",
                "type": "Map",
                "value_value_kind": "Tuple"
              },
              "id_type": {
                "type": "Enum",
                "variant": {
                  "discriminator": "0",
                  "type": "U8"
                }
              },
              "instruction": "CREATE_NON_FUNGIBLE_RESOURCE",
              "metadata": {
                "entries": [],
                "key_value_kind": "String",
                "type": "Map",
                "value_value_kind": "String"
              }
            }
          ],
          "type": "object",
          "required": [
            "access_rules",
            "id_type",
            "instruction",
            "metadata"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "CREATE_NON_FUNGIBLE_RESOURCE"
              ]
            },
            "id_type": {
              "description": "The type of the non-fungible id to use for this resource. This field is serialized as an `Enum` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "metadata": {
              "description": "The metadata to set on the resource. The underlying type of this is a string-string Map of the metadata. This is serialized as an `Map` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "access_rules": {
              "description": "The access rules to use for the resource. The underlying type of this is a map which maps a `ResourceMethodAuthKey` enum to a tuple of two `AccessRule`s denoting the current behavior and the mutability. This is serialized as an `Map` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "An instruction to create a non-fungible resource with an initial supply",
          "type": "object",
          "required": [
            "access_rules",
            "id_type",
            "initial_supply",
            "instruction",
            "metadata"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "CREATE_NON_FUNGIBLE_RESOURCE_WITH_INITIAL_SUPPLY"
              ]
            },
            "id_type": {
              "description": "The type of the non-fungible id to use for this resource. This field is serialized as an `Enum` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "metadata": {
              "description": "The metadata to set on the resource. The underlying type of this is a string-string Map of the metadata. This is serialized as an `Map` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "access_rules": {
              "description": "The access rules to use for the resource. The underlying type of this is a map which maps a `ResourceMethodAuthKey` enum to a tuple of two `AccessRule`s denoting the current behavior and the mutability. This is serialized as an `Map` from the ManifestAstValue model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "initial_supply": {
              "description": "An optional initial supply for the non-fungible resource being created. The underlying type of this is a map which maps a `NonFungibleLocalId` to a tuple of two `ManifestAstValue` elements where each element is a struct of the immutable and mutable parts of the non-fungible data.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "Creates a new access controller native component with the passed set of rules as the current active rule set and the specified timed recovery delay in minutes.",
          "examples": [
            {
              "controlled_asset": {
                "identifier": {
                  "type": "String",
                  "value": "ident"
                },
                "type": "Bucket"
              },
              "instruction": "CREATE_ACCESS_CONTROLLER",
              "rule_set": {
                "elements": [
                  {
                    "type": "Enum",
                    "variant": {
                      "discriminator": "0",
                      "type": "U8"
                    }
                  },
                  {
                    "type": "Enum",
                    "variant": {
                      "discriminator": "0",
                      "type": "U8"
                    }
                  },
                  {
                    "type": "Enum",
                    "variant": {
                      "discriminator": "0",
                      "type": "U8"
                    }
                  }
                ],
                "type": "Tuple"
              },
              "timed_recovery_delay_in_minutes": {
                "type": "Some",
                "value": {
                  "type": "U32",
                  "value": "1"
                }
              }
            }
          ],
          "type": "object",
          "required": [
            "controlled_asset",
            "instruction",
            "rule_set",
            "timed_recovery_delay_in_minutes"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "CREATE_ACCESS_CONTROLLER"
              ]
            },
            "controlled_asset": {
              "description": "A bucket of the asset that will be controlled by the access controller. The underlying type of this is a `Bucket` from the `ManifestAstValue` model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "rule_set": {
              "description": "The set of rules to use for the access controller's primary, confirmation, and recovery roles.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "timed_recovery_delay_in_minutes": {
              "description": "The recovery delay in minutes to use for the access controller. The underlying type of this is an `Enum` or an `Option` from the `ManifestAstValue` model of an unsigned 32-bit integer of the time in minutes.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "Creates a new identity native component with the passed access rule.",
          "examples": [
            {
              "access_rule": {
                "type": "Enum",
                "variant": {
                  "discriminator": "0",
                  "type": "U8"
                }
              },
              "instruction": "CREATE_IDENTITY"
            }
          ],
          "type": "object",
          "required": [
            "access_rule",
            "instruction"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "CREATE_IDENTITY"
              ]
            },
            "access_rule": {
              "description": "The access rule to protect the identity with. The underlying type of this is an `Enum` from the `ManifestAstValue` model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "Assert that the given access rule is currently fulfilled by the proofs in the Auth Zone of the transaction",
          "examples": [
            {
              "access_rule": {
                "type": "Enum",
                "variant": {
                  "discriminator": "0",
                  "type": "U8"
                }
              },
              "instruction": "ASSERT_ACCESS_RULE"
            }
          ],
          "type": "object",
          "required": [
            "access_rule",
            "instruction"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "ASSERT_ACCESS_RULE"
              ]
            },
            "access_rule": {
              "description": "The access rule to assert. The underlying type of this is an `Enum` from the `ManifestAstValue` model which represents the access rule to assert.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "Creates a validator given the public key of the owner who controls it",
          "examples": [
            {
              "instruction": "CREATE_VALIDATOR",
              "key": {
                "type": "Bytes",
                "value": "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
              },
              "owner_access_rule": {
                "type": "Enum",
                "variant": {
                  "discriminator": "0",
                  "type": "U8"
                }
              }
            }
          ],
          "type": "object",
          "required": [
            "instruction",
            "key",
            "owner_access_rule"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "CREATE_VALIDATOR"
              ]
            },
            "key": {
              "description": "The ECDSA Secp256k1 public key of the owner of the validator. The underlying type of this is an `EcdsaSecp256k1PublicKey` from the `ManifestAstValue` model.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            },
            "owner_access_rule": {
              "description": "The access rule to protect the validator with. The underlying type of this is an `Enum` from the `ManifestAstValue` model which represents the access rule to assert.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        },
        {
          "description": "Creates a new global account component which has the withdraw rule seen in the rule.",
          "examples": [
            {
              "instruction": "CREATE_ACCOUNT",
              "withdraw_rule": {
                "type": "Enum",
                "variant": {
                  "discriminator": "0",
                  "type": "U8"
                }
              }
            }
          ],
          "type": "object",
          "required": [
            "instruction",
            "withdraw_rule"
          ],
          "properties": {
            "instruction": {
              "type": "string",
              "enum": [
                "CREATE_ACCOUNT"
              ]
            },
            "withdraw_rule": {
              "description": "The withdraw rule to associate with the account.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValue"
                }
              ]
            }
          }
        }
      ]
    },
    "ManifestAstValue": {
      "description": "A value model used to describe an algebraic sum type which is used to express transaction manifests as an abstract syntax tree. This is serialized as a discriminated union of types.",
      "examples": [
        {
          "type": "Bool",
          "value": false
        }
      ],
      "oneOf": [
        {
          "description": "A boolean value which can either be true or false",
          "examples": [
            {
              "type": "Bool",
              "value": false
            },
            {
              "type": "Bool",
              "value": true
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Bool"
              ]
            },
            "value": {
              "type": "boolean"
            }
          }
        },
        {
          "description": "An 8-bit unsigned integer which is serialized and deserialized as a string.",
          "examples": [
            {
              "type": "U8",
              "value": "1"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "U8"
              ]
            },
            "value": {
              "type": "string",
              "pattern": "[0-9]+"
            }
          }
        },
        {
          "description": "A 16-bit unsigned integer which is serialized and deserialized as a string.",
          "examples": [
            {
              "type": "U16",
              "value": "1"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "U16"
              ]
            },
            "value": {
              "type": "string",
              "pattern": "[0-9]+"
            }
          }
        },
        {
          "description": "A 32-bit unsigned integer which is serialized and deserialized as a string.",
          "examples": [
            {
              "type": "U32",
              "value": "1"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "U32"
              ]
            },
            "value": {
              "type": "string",
              "pattern": "[0-9]+"
            }
          }
        },
        {
          "description": "A 64-bit unsigned integer which is serialized and deserialized as a string.",
          "examples": [
            {
              "type": "U64",
              "value": "1"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "U64"
              ]
            },
            "value": {
              "type": "string",
              "pattern": "[0-9]+"
            }
          }
        },
        {
          "description": "A 128-bit unsigned integer which is serialized and deserialized as a string.",
          "examples": [
            {
              "type": "U128",
              "value": "1"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "U128"
              ]
            },
            "value": {
              "type": "string",
              "pattern": "[0-9]+"
            }
          }
        },
        {
          "description": "An 8-bit signed integer which is serialized and deserialized as a string.",
          "examples": [
            {
              "type": "I8",
              "value": "1"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "I8"
              ]
            },
            "value": {
              "type": "string",
              "pattern": "[0-9]+"
            }
          }
        },
        {
          "description": "A 16-bit signed integer which is serialized and deserialized as a string.",
          "examples": [
            {
              "type": "I16",
              "value": "1"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "I16"
              ]
            },
            "value": {
              "type": "string",
              "pattern": "[0-9]+"
            }
          }
        },
        {
          "description": "A 32-bit signed integer which is serialized and deserialized as a string.",
          "examples": [
            {
              "type": "I32",
              "value": "1"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "I32"
              ]
            },
            "value": {
              "type": "string",
              "pattern": "[0-9]+"
            }
          }
        },
        {
          "description": "A 64-bit signed integer which is serialized and deserialized as a string.",
          "examples": [
            {
              "type": "I64",
              "value": "1"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "I64"
              ]
            },
            "value": {
              "type": "string",
              "pattern": "[0-9]+"
            }
          }
        },
        {
          "description": "A 128-bit signed integer which is serialized and deserialized as a string.",
          "examples": [
            {
              "type": "I128",
              "value": "1"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "I128"
              ]
            },
            "value": {
              "type": "string",
              "pattern": "[0-9]+"
            }
          }
        },
        {
          "description": "A type representing a string",
          "examples": [
            {
              "type": "String",
              "value": "Scrypto"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "String"
              ]
            },
            "value": {
              "type": "string"
            }
          }
        },
        {
          "description": "A Rust-style Enum which has a variant and can optionally also have a list of values (acting in a way similar to discriminated algebraic sum types)",
          "examples": [
            {
              "type": "Enum",
              "variant": {
                "discriminator": "1",
                "type": "U8"
              }
            },
            {
              "type": "Enum",
              "variant": {
                "discriminator": "EnumName::Variant",
                "type": "String"
              }
            },
            {
              "fields": [
                {
                  "type": "U8",
                  "value": "1"
                }
              ],
              "type": "Enum",
              "variant": {
                "discriminator": "1",
                "type": "U8"
              }
            },
            {
              "fields": [
                {
                  "type": "U8",
                  "value": "1"
                }
              ],
              "type": "Enum",
              "variant": {
                "discriminator": "EnumName::Variant",
                "type": "String"
              }
            }
          ],
          "type": "object",
          "required": [
            "type",
            "variant"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Enum"
              ]
            },
            "variant": {
              "description": "The enum discriminator which is either a string or an unsigned 8-bit integer.",
              "allOf": [
                {
                  "$ref": "#/definitions/EnumDiscriminator"
                }
              ]
            },
            "fields": {
              "description": "Optional fields that the enum may have",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "$ref": "#/definitions/ManifestAstValue"
              }
            }
          }
        },
        {
          "description": "The `Some` case of Rust Options where the value is some Self",
          "examples": [
            {
              "type": "Some",
              "value": {
                "type": "U8",
                "value": "1"
              }
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Some"
              ]
            },
            "value": {
              "$ref": "#/definitions/ManifestAstValue"
            }
          }
        },
        {
          "description": "The `None` case of Rust Options where there is value",
          "examples": [
            {
              "type": "None"
            }
          ],
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "None"
              ]
            }
          }
        },
        {
          "description": "The `Ok` case of Rust Results where the value is some Self",
          "examples": [
            {
              "type": "Ok",
              "value": {
                "type": "U8",
                "value": "1"
              }
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Ok"
              ]
            },
            "value": {
              "$ref": "#/definitions/ManifestAstValue"
            }
          }
        },
        {
          "description": "The `Err` case of Rust Results where the value is some Self",
          "examples": [
            {
              "type": "Err",
              "value": {
                "type": "U8",
                "value": "1"
              }
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Err"
              ]
            },
            "value": {
              "$ref": "#/definitions/ManifestAstValue"
            }
          }
        },
        {
          "description": "An array values of a single value kind",
          "examples": [
            {
              "element_kind": "U8",
              "elements": [
                {
                  "type": "U8",
                  "value": "1"
                },
                {
                  "type": "U8",
                  "value": "2"
                },
                {
                  "type": "U8",
                  "value": "3"
                }
              ],
              "type": "Array"
            }
          ],
          "type": "object",
          "required": [
            "element_kind",
            "elements",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Array"
              ]
            },
            "element_kind": {
              "description": "The kind of elements that the array contains. An array will be validated to ensure that it contains a single element kind.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValueKind"
                }
              ]
            },
            "elements": {
              "description": "The elements of the array which may contain 0 or more elements.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/ManifestAstValue"
              }
            }
          }
        },
        {
          "description": "A key-value map of values where all keys are of a single kind and all values are of a single kind",
          "examples": [
            {
              "entries": [
                [
                  {
                    "type": "U8",
                    "value": "65"
                  },
                  {
                    "type": "String",
                    "value": "A"
                  }
                ],
                [
                  {
                    "type": "U8",
                    "value": "66"
                  },
                  {
                    "type": "String",
                    "value": "B"
                  }
                ]
              ],
              "key_value_kind": "U8",
              "type": "Map",
              "value_value_kind": "String"
            }
          ],
          "type": "object",
          "required": [
            "entries",
            "key_value_kind",
            "type",
            "value_value_kind"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Map"
              ]
            },
            "key_value_kind": {
              "description": "The kind of the keys used for the map. A map will be validated to ensure that its keys are all of a single kind.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValueKind"
                }
              ]
            },
            "value_value_kind": {
              "description": "The kind of the values used for the map. A map will be validated to ensure that its values are all of a single kind.",
              "allOf": [
                {
                  "$ref": "#/definitions/ManifestAstValueKind"
                }
              ]
            },
            "entries": {
              "description": "A vector of tuples representing the entires in the map where each tuple is made up of two elements: a key and a value.",
              "type": "array",
              "items": {
                "type": "array",
                "items": [
                  {
                    "$ref": "#/definitions/ManifestAstValue"
                  },
                  {
                    "$ref": "#/definitions/ManifestAstValue"
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            }
          }
        },
        {
          "description": "An array of elements where elements could be of different kinds.",
          "examples": [
            {
              "elements": [
                {
                  "elements": [
                    {
                      "type": "U8",
                      "value": "1"
                    },
                    {
                      "type": "String",
                      "value": "Something"
                    }
                  ],
                  "type": "Tuple"
                }
              ],
              "type": "Tuple"
            }
          ],
          "type": "object",
          "required": [
            "elements",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Tuple"
              ]
            },
            "elements": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/ManifestAstValue"
              }
            }
          }
        },
        {
          "description": "A Scrypto Decimal which has a precision of 18 decimal places and has a maximum and minimum of 57896044618658097711785492504343953926634992332820282019728.792003956564819967 and -57896044618658097711785492504343953926634992332820282019728.792003956564819968 respectively",
          "examples": [
            {
              "type": "Decimal",
              "value": "1"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Decimal"
              ]
            },
            "value": {
              "type": "string",
              "pattern": "[+-]?([0-9]*[.])?[0-9]+"
            }
          }
        },
        {
          "description": "A Scrypto PreciseDecimal which has a precision of 64 decimal places and has a maximum and minimum of 670390396497129854978701249910292306373968291029619668886178072186088201503677348840093714. 9083451713845015929093243025426876941405973284973216824503042047 and -670390396497129854978701249910292306373968291029619668886178072186088201503677348840093714.9083451713845015929093243025426876941405973284973216824503042048 respectively",
          "examples": [
            {
              "type": "PreciseDecimal",
              "value": "1"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "PreciseDecimal"
              ]
            },
            "value": {
              "type": "string",
              "pattern": "[+-]?([0-9]*[.])?[0-9]+"
            }
          }
        },
        {
          "description": "Represents a Bech32m encoded human-readable address which may be used to address a package, component, or resource. This address is serialized as a human-readable bech32m encoded string.",
          "examples": [
            {
              "address": "component_rdx1qtkryz5scup945usk39qjc2yjh6l5zsyuh8t7v5pk0tsrdcazt",
              "type": "Address"
            },
            {
              "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqy99qqm",
              "type": "Address"
            },
            {
              "address": "package_rdx1qyqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpqqzrhqe8",
              "type": "Address"
            }
          ],
          "type": "object",
          "required": [
            "address",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Address"
              ]
            },
            "address": {
              "type": "string"
            }
          }
        },
        {
          "description": "Represents a Scrypto bucket which is identified through a transient identifier which is either a string or an unsigned 32-bit integer which is serialized as a Integer.",
          "examples": [
            {
              "identifier": {
                "type": "String",
                "value": "bucket"
              },
              "type": "Bucket"
            },
            {
              "identifier": {
                "type": "U32",
                "value": "1"
              },
              "type": "Bucket"
            }
          ],
          "type": "object",
          "required": [
            "identifier",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Bucket"
              ]
            },
            "identifier": {
              "$ref": "#/definitions/BucketId"
            }
          }
        },
        {
          "description": "Represents a Scrypto proof which is identified through a transient identifier which is either a string or an unsigned 32-bit integer which is serialized as a Integer.",
          "examples": [
            {
              "identifier": {
                "type": "String",
                "value": "proof"
              },
              "type": "Proof"
            },
            {
              "identifier": {
                "type": "U32",
                "value": "1"
              },
              "type": "Proof"
            }
          ],
          "type": "object",
          "required": [
            "identifier",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Proof"
              ]
            },
            "identifier": {
              "$ref": "#/definitions/ProofId"
            }
          }
        },
        {
          "description": "Represents non-fungible ids which is a discriminated union of the different types that non-fungible ids may be.",
          "examples": [
            {
              "type": "NonFungibleLocalId",
              "value": {
                "type": "UUID",
                "value": "241008287272164729465721528295504357972"
              }
            },
            {
              "type": "NonFungibleLocalId",
              "value": {
                "type": "Integer",
                "value": "1"
              }
            },
            {
              "type": "NonFungibleLocalId",
              "value": {
                "type": "String",
                "value": "Scrypto"
              }
            },
            {
              "type": "NonFungibleLocalId",
              "value": {
                "type": "Bytes",
                "value": "01020304"
              }
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "NonFungibleLocalId"
              ]
            },
            "value": {
              "$ref": "#/definitions/NonFungibleLocalId"
            }
          }
        },
        {
          "description": "Represents a non-fungible address which may be considered as the \"global\" address of a non-fungible unit as it contains both the resource address and the non-fungible id for that unit.",
          "examples": [
            {
              "non_fungible_local_id": {
                "type": "NonFungibleLocalId",
                "value": {
                  "type": "UUID",
                  "value": "241008287272164729465721528295504357972"
                }
              },
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqs3ydc4g",
                "type": "Address"
              },
              "type": "NonFungibleGlobalId"
            },
            {
              "non_fungible_local_id": {
                "type": "NonFungibleLocalId",
                "value": {
                  "type": "Integer",
                  "value": "1"
                }
              },
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqs3ydc4g",
                "type": "Address"
              },
              "type": "NonFungibleGlobalId"
            },
            {
              "non_fungible_local_id": {
                "type": "NonFungibleLocalId",
                "value": {
                  "type": "String",
                  "value": "Scrypto"
                }
              },
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqs3ydc4g",
                "type": "Address"
              },
              "type": "NonFungibleGlobalId"
            },
            {
              "non_fungible_local_id": {
                "type": "NonFungibleLocalId",
                "value": {
                  "type": "Bytes",
                  "value": "01020304"
                }
              },
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqs3ydc4g",
                "type": "Address"
              },
              "type": "NonFungibleGlobalId"
            }
          ],
          "type": "object",
          "required": [
            "non_fungible_local_id",
            "resource_address",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "NonFungibleGlobalId"
              ]
            },
            "resource_address": {
              "$ref": "#/definitions/ManifestAstValue"
            },
            "non_fungible_local_id": {
              "$ref": "#/definitions/ManifestAstValue"
            }
          }
        },
        {
          "description": "Represents a transaction manifest expression.",
          "examples": [
            {
              "type": "Expression",
              "value": "ENTIRE_AUTH_ZONE"
            },
            {
              "type": "Expression",
              "value": "ENTIRE_WORKTOP"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Expression"
              ]
            },
            "value": {
              "$ref": "#/definitions/Expression"
            }
          }
        },
        {
          "description": "Represents the hash of a blob provided as part of a transaction manifest. This is represented as a byte array of 32 bytes which is serialized as a hex string.",
          "examples": [
            {
              "hash": "d28d2c3710601fbc097000ec73455693f4861dc0eb7c90d8821f2a13f617313e",
              "type": "Blob"
            }
          ],
          "type": "object",
          "required": [
            "hash",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Blob"
              ]
            },
            "hash": {
              "$ref": "#/definitions/Blob"
            }
          }
        },
        {
          "description": "Represents a byte array of an unknown size which is serialized as a hex string",
          "examples": [
            {
              "type": "Bytes",
              "value": "d28d2c3710601fbc097000ec73455693f4861dc0eb7c90d8821f2a13f617313e"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Bytes"
              ]
            },
            "value": {
              "type": "string"
            }
          }
        }
      ]
    },
    "EnumDiscriminator": {
      "description": "A union of the types of discriminators that enums may have. This may either be a string or an 8-bit unsigned number.",
      "examples": [
        {
          "discriminator": "EnumName::Variant",
          "type": "String"
        },
        {
          "discriminator": "1",
          "type": "U8"
        }
      ],
      "oneOf": [
        {
          "type": "object",
          "required": [
            "discriminator",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "String"
              ]
            },
            "discriminator": {
              "description": "A string discriminator of the fully qualified well-known enum name",
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "discriminator",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "U8"
              ]
            },
            "discriminator": {
              "description": "An 8-bit unsigned integer serialized as a string.",
              "type": "string",
              "pattern": "[0-9]+"
            }
          }
        }
      ]
    },
    "ManifestAstValueKind": {
      "oneOf": [
        {
          "description": "A boolean value which can either be true or false",
          "examples": [
            {
              "type": "Bool",
              "value": false
            },
            {
              "type": "Bool",
              "value": true
            }
          ],
          "type": "string",
          "enum": [
            "Bool"
          ]
        },
        {
          "description": "An 8-bit unsigned integer which is serialized and deserialized as a string.",
          "examples": [
            {
              "type": "U8",
              "value": "1"
            }
          ],
          "type": "string",
          "enum": [
            "U8"
          ]
        },
        {
          "description": "A 16-bit unsigned integer which is serialized and deserialized as a string.",
          "examples": [
            {
              "type": "U16",
              "value": "1"
            }
          ],
          "type": "string",
          "enum": [
            "U16"
          ]
        },
        {
          "description": "A 32-bit unsigned integer which is serialized and deserialized as a string.",
          "examples": [
            {
              "type": "U32",
              "value": "1"
            }
          ],
          "type": "string",
          "enum": [
            "U32"
          ]
        },
        {
          "description": "A 64-bit unsigned integer which is serialized and deserialized as a string.",
          "examples": [
            {
              "type": "U64",
              "value": "1"
            }
          ],
          "type": "string",
          "enum": [
            "U64"
          ]
        },
        {
          "description": "A 128-bit unsigned integer which is serialized and deserialized as a string.",
          "examples": [
            {
              "type": "U128",
              "value": "1"
            }
          ],
          "type": "string",
          "enum": [
            "U128"
          ]
        },
        {
          "description": "An 8-bit signed integer which is serialized and deserialized as a string.",
          "examples": [
            {
              "type": "I8",
              "value": "1"
            }
          ],
          "type": "string",
          "enum": [
            "I8"
          ]
        },
        {
          "description": "A 16-bit signed integer which is serialized and deserialized as a string.",
          "examples": [
            {
              "type": "I16",
              "value": "1"
            }
          ],
          "type": "string",
          "enum": [
            "I16"
          ]
        },
        {
          "description": "A 32-bit signed integer which is serialized and deserialized as a string.",
          "examples": [
            {
              "type": "I32",
              "value": "1"
            }
          ],
          "type": "string",
          "enum": [
            "I32"
          ]
        },
        {
          "description": "A 64-bit signed integer which is serialized and deserialized as a string.",
          "examples": [
            {
              "type": "I64",
              "value": "1"
            }
          ],
          "type": "string",
          "enum": [
            "I64"
          ]
        },
        {
          "description": "A 128-bit signed integer which is serialized and deserialized as a string.",
          "examples": [
            {
              "type": "I128",
              "value": "1"
            }
          ],
          "type": "string",
          "enum": [
            "I128"
          ]
        },
        {
          "description": "A type representing a string",
          "examples": [
            {
              "type": "String",
              "value": "Scrypto"
            }
          ],
          "type": "string",
          "enum": [
            "String"
          ]
        },
        {
          "description": "A Rust-style Enum which has a variant and can optionally also have a list of values (acting in a way similar to discriminated algebraic sum types)",
          "examples": [
            {
              "type": "Enum",
              "variant": {
                "discriminator": "1",
                "type": "U8"
              }
            },
            {
              "type": "Enum",
              "variant": {
                "discriminator": "EnumName::Variant",
                "type": "String"
              }
            },
            {
              "fields": [
                {
                  "type": "U8",
                  "value": "1"
                }
              ],
              "type": "Enum",
              "variant": {
                "discriminator": "1",
                "type": "U8"
              }
            },
            {
              "fields": [
                {
                  "type": "U8",
                  "value": "1"
                }
              ],
              "type": "Enum",
              "variant": {
                "discriminator": "EnumName::Variant",
                "type": "String"
              }
            }
          ],
          "type": "string",
          "enum": [
            "Enum"
          ]
        },
        {
          "description": "The `Some` case of Rust Options where the value is some Self",
          "examples": [
            {
              "type": "Some",
              "value": {
                "type": "U8",
                "value": "1"
              }
            }
          ],
          "type": "string",
          "enum": [
            "Some"
          ]
        },
        {
          "description": "The `None` case of Rust Options where there is value",
          "examples": [
            {
              "type": "None"
            }
          ],
          "type": "string",
          "enum": [
            "None"
          ]
        },
        {
          "description": "The `Ok` case of Rust Results where the value is some Self",
          "examples": [
            {
              "type": "Ok",
              "value": {
                "type": "U8",
                "value": "1"
              }
            }
          ],
          "type": "string",
          "enum": [
            "Ok"
          ]
        },
        {
          "description": "The `Err` case of Rust Results where the value is some Self",
          "examples": [
            {
              "type": "Err",
              "value": {
                "type": "U8",
                "value": "1"
              }
            }
          ],
          "type": "string",
          "enum": [
            "Err"
          ]
        },
        {
          "description": "An array values of a single value kind",
          "examples": [
            {
              "element_kind": "U8",
              "elements": [
                {
                  "type": "U8",
                  "value": "1"
                },
                {
                  "type": "U8",
                  "value": "2"
                },
                {
                  "type": "U8",
                  "value": "3"
                }
              ],
              "type": "Array"
            }
          ],
          "type": "string",
          "enum": [
            "Array"
          ]
        },
        {
          "description": "A key-value map of values where all keys are of a single kind and all values are of a single kind",
          "examples": [
            {
              "entries": [
                [
                  {
                    "type": "U8",
                    "value": "65"
                  },
                  {
                    "type": "String",
                    "value": "A"
                  }
                ],
                [
                  {
                    "type": "U8",
                    "value": "66"
                  },
                  {
                    "type": "String",
                    "value": "B"
                  }
                ]
              ],
              "key_value_kind": "U8",
              "type": "Map",
              "value_value_kind": "String"
            }
          ],
          "type": "string",
          "enum": [
            "Map"
          ]
        },
        {
          "description": "An array of elements where elements could be of different kinds.",
          "examples": [
            {
              "elements": [
                {
                  "elements": [
                    {
                      "type": "U8",
                      "value": "1"
                    },
                    {
                      "type": "String",
                      "value": "Something"
                    }
                  ],
                  "type": "Tuple"
                }
              ],
              "type": "Tuple"
            }
          ],
          "type": "string",
          "enum": [
            "Tuple"
          ]
        },
        {
          "description": "A Scrypto Decimal which has a precision of 18 decimal places and has a maximum and minimum of 57896044618658097711785492504343953926634992332820282019728.792003956564819967 and -57896044618658097711785492504343953926634992332820282019728.792003956564819968 respectively",
          "examples": [
            {
              "type": "Decimal",
              "value": "1"
            }
          ],
          "type": "string",
          "enum": [
            "Decimal"
          ]
        },
        {
          "description": "A Scrypto PreciseDecimal which has a precision of 64 decimal places and has a maximum and minimum of 670390396497129854978701249910292306373968291029619668886178072186088201503677348840093714. 9083451713845015929093243025426876941405973284973216824503042047 and -670390396497129854978701249910292306373968291029619668886178072186088201503677348840093714.9083451713845015929093243025426876941405973284973216824503042048 respectively",
          "examples": [
            {
              "type": "PreciseDecimal",
              "value": "1"
            }
          ],
          "type": "string",
          "enum": [
            "PreciseDecimal"
          ]
        },
        {
          "description": "Represents a Bech32m encoded human-readable address which may be used to address a package, component, or resource. This address is serialized as a human-readable bech32m encoded string.",
          "examples": [
            {
              "address": "component_rdx1qtkryz5scup945usk39qjc2yjh6l5zsyuh8t7v5pk0tsrdcazt",
              "type": "Address"
            },
            {
              "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqy99qqm",
              "type": "Address"
            },
            {
              "address": "package_rdx1qyqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpqqzrhqe8",
              "type": "Address"
            }
          ],
          "type": "string",
          "enum": [
            "Address"
          ]
        },
        {
          "description": "Represents a Scrypto bucket which is identified through a transient identifier which is either a string or an unsigned 32-bit integer which is serialized as a Integer.",
          "examples": [
            {
              "identifier": {
                "type": "String",
                "value": "bucket"
              },
              "type": "Bucket"
            },
            {
              "identifier": {
                "type": "U32",
                "value": "1"
              },
              "type": "Bucket"
            }
          ],
          "type": "string",
          "enum": [
            "Bucket"
          ]
        },
        {
          "description": "Represents a Scrypto proof which is identified through a transient identifier which is either a string or an unsigned 32-bit integer which is serialized as a Integer.",
          "examples": [
            {
              "identifier": {
                "type": "String",
                "value": "proof"
              },
              "type": "Proof"
            },
            {
              "identifier": {
                "type": "U32",
                "value": "1"
              },
              "type": "Proof"
            }
          ],
          "type": "string",
          "enum": [
            "Proof"
          ]
        },
        {
          "description": "Represents non-fungible ids which is a discriminated union of the different types that non-fungible ids may be.",
          "examples": [
            {
              "type": "NonFungibleLocalId",
              "value": {
                "type": "UUID",
                "value": "241008287272164729465721528295504357972"
              }
            },
            {
              "type": "NonFungibleLocalId",
              "value": {
                "type": "Integer",
                "value": "1"
              }
            },
            {
              "type": "NonFungibleLocalId",
              "value": {
                "type": "String",
                "value": "Scrypto"
              }
            },
            {
              "type": "NonFungibleLocalId",
              "value": {
                "type": "Bytes",
                "value": "01020304"
              }
            }
          ],
          "type": "string",
          "enum": [
            "NonFungibleLocalId"
          ]
        },
        {
          "description": "Represents a non-fungible address which may be considered as the \"global\" address of a non-fungible unit as it contains both the resource address and the non-fungible id for that unit.",
          "examples": [
            {
              "non_fungible_local_id": {
                "type": "NonFungibleLocalId",
                "value": {
                  "type": "UUID",
                  "value": "241008287272164729465721528295504357972"
                }
              },
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqs3ydc4g",
                "type": "Address"
              },
              "type": "NonFungibleGlobalId"
            },
            {
              "non_fungible_local_id": {
                "type": "NonFungibleLocalId",
                "value": {
                  "type": "Integer",
                  "value": "1"
                }
              },
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqs3ydc4g",
                "type": "Address"
              },
              "type": "NonFungibleGlobalId"
            },
            {
              "non_fungible_local_id": {
                "type": "NonFungibleLocalId",
                "value": {
                  "type": "String",
                  "value": "Scrypto"
                }
              },
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqs3ydc4g",
                "type": "Address"
              },
              "type": "NonFungibleGlobalId"
            },
            {
              "non_fungible_local_id": {
                "type": "NonFungibleLocalId",
                "value": {
                  "type": "Bytes",
                  "value": "01020304"
                }
              },
              "resource_address": {
                "address": "resource_rdx1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqs3ydc4g",
                "type": "Address"
              },
              "type": "NonFungibleGlobalId"
            }
          ],
          "type": "string",
          "enum": [
            "NonFungibleGlobalId"
          ]
        },
        {
          "description": "Represents a transaction manifest expression.",
          "examples": [
            {
              "type": "Expression",
              "value": "ENTIRE_AUTH_ZONE"
            },
            {
              "type": "Expression",
              "value": "ENTIRE_WORKTOP"
            }
          ],
          "type": "string",
          "enum": [
            "Expression"
          ]
        },
        {
          "description": "Represents the hash of a blob provided as part of a transaction manifest. This is represented as a byte array of 32 bytes which is serialized as a hex string.",
          "examples": [
            {
              "hash": "d28d2c3710601fbc097000ec73455693f4861dc0eb7c90d8821f2a13f617313e",
              "type": "Blob"
            }
          ],
          "type": "string",
          "enum": [
            "Blob"
          ]
        },
        {
          "description": "Represents a byte array of an unknown size which is serialized as a hex string",
          "examples": [
            {
              "type": "Bytes",
              "value": "d28d2c3710601fbc097000ec73455693f4861dc0eb7c90d8821f2a13f617313e"
            }
          ],
          "type": "string",
          "enum": [
            "Bytes"
          ]
        }
      ]
    },
    "BucketId": {
      "description": "Represents a BucketId which uses a transient identifier.",
      "examples": [
        {
          "type": "String",
          "value": "Scrypto"
        },
        {
          "type": "U32",
          "value": "1"
        }
      ],
      "allOf": [
        {
          "$ref": "#/definitions/TransientIdentifier"
        }
      ]
    },
    "TransientIdentifier": {
      "description": "Represents a tagged transient identifier typically used as an identifiers for Scrypto buckets and proofs. Could either be a string or an unsigned 32-bit number (which is serialized as a number and not a string)",
      "oneOf": [
        {
          "examples": [
            {
              "type": "String",
              "value": "Scrypto"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "String"
              ]
            },
            "value": {
              "description": "A string identifier",
              "type": "string"
            }
          }
        },
        {
          "examples": [
            {
              "type": "U32",
              "value": "1"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "U32"
              ]
            },
            "value": {
              "description": "A 32-bit unsigned integer which is serialized and deserialized as a string.",
              "type": "string",
              "pattern": "[0-9]+"
            }
          }
        }
      ]
    },
    "ProofId": {
      "description": "Represents a ProofId which uses a transient identifier.",
      "examples": [
        {
          "type": "String",
          "value": "Scrypto"
        },
        {
          "type": "U32",
          "value": "1"
        }
      ],
      "allOf": [
        {
          "$ref": "#/definitions/TransientIdentifier"
        }
      ]
    },
    "NonFungibleLocalId": {
      "description": "Represents non-fungible ids which is a discriminated union of the different types that non-fungible ids may be.",
      "oneOf": [
        {
          "description": "A 64 bit unsigned integer non-fungible id type which is serialized as a string",
          "examples": [
            {
              "type": "Integer",
              "value": "1"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Integer"
              ]
            },
            "value": {
              "type": "string",
              "pattern": "[0-9]+"
            }
          }
        },
        {
          "description": "A 128 bit unsigned integer UUID non-fungible id type which is serialized as a string",
          "examples": [
            {
              "type": "UUID",
              "value": "241008287272164729465721528295504357972"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "UUID"
              ]
            },
            "value": {
              "type": "string",
              "pattern": "[0-9]+"
            }
          }
        },
        {
          "description": "An byte array non-fungible id type which is serialized as a hex string. This can be between 1 and 64 bytes in length which translates to a length range of 2 and 128 when hex-encoded.",
          "examples": [
            {
              "type": "UUID",
              "value": "241008287272164729465721528295504357972"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Bytes"
              ]
            },
            "value": {
              "type": "string",
              "maxLength": 128,
              "minLength": 2,
              "pattern": "[0-9a-fA-F]+"
            }
          }
        },
        {
          "description": "A string non-fungible id. This can be between 1 and 64 characters long.",
          "examples": [
            {
              "type": "String",
              "value": "Scrypto"
            }
          ],
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "String"
              ]
            },
            "value": {
              "type": "string",
              "maxLength": 64,
              "minLength": 1
            }
          }
        }
      ]
    },
    "Expression": {
      "description": "Represents a transaction manifest expression.",
      "type": "string",
      "enum": [
        "ENTIRE_WORKTOP",
        "ENTIRE_AUTH_ZONE"
      ]
    },
    "Blob": {
      "description": "Represents the hash of a blob provided as part of a transaction manifest. This is represented as a byte array of 32 bytes which is serialized as a hex string.",
      "type": "string",
      "maxLength": 64,
      "minLength": 64,
      "pattern": "[0-9a-fA-F]+"
    },
    "SignatureWithPublicKey": {
      "description": "A discriminated union of the possible pairs of signatures and public keys used by Scrypto and the Radix Engine.",
      "oneOf": [
        {
          "description": "Cryptographic signature and public key for Ecdsa Secp256k1",
          "examples": [
            {
              "curve": "EcdsaSecp256k1",
              "signature": "007f054d0a376fb5cce93c5836531ce5d116dcdb134211650553ddeba408e53b4725b8fe89d120c41667fe457acae408025371a61b8fe05b20d2c2b9e8d81f1a53"
            }
          ],
          "type": "object",
          "required": [
            "curve",
            "signature"
          ],
          "properties": {
            "curve": {
              "type": "string",
              "enum": [
                "EcdsaSecp256k1"
              ]
            },
            "signature": {
              "description": "A byte array of 65 bytes which are serialized as a 130 character long hex-encoded string representing a signature from the ECDSA Secp256k1 elliptic curve. An important note on ECDSA Secp256k1 signatures is that the format used and accepted by Scrypto is [v, r, s] where `v` is the recovery id and is a single byte and `r` and `s` are the signature results and are 32 bytes each. In this case, only a signature is needed since the public key can be derived from the signature if the message is available.",
              "type": "string",
              "maxLength": 130,
              "minLength": 130,
              "pattern": "[0-9a-fA-F]+"
            }
          }
        },
        {
          "description": "Cryptographic signature and public key for EdDSA Ed25519",
          "examples": [
            {
              "curve": "EddsaEd25519",
              "public_key": "4cb5abf6ad79fbf5abbccafcc269d85cd2651ed4b885b5869f241aedf0a5ba29",
              "signature": "e5f1e508cc91a95a280613618a1ccb5142744b5b8a6042e232dcaadf17e41f1f0131d535ea3fa56b6ae8164586cd6b4e89e3224e994b3109ca51cae02e7dce01"
            }
          ],
          "type": "object",
          "required": [
            "curve",
            "public_key",
            "signature"
          ],
          "properties": {
            "curve": {
              "type": "string",
              "enum": [
                "EddsaEd25519"
              ]
            },
            "public_key": {
              "description": "A byte array of 32 bytes which are serialized as a 64 character long hex-encoded string representing a public key from the EDDSA Ed25519 edwards curve.",
              "type": "string",
              "maxLength": 66,
              "minLength": 66,
              "pattern": "[0-9a-fA-F]+"
            },
            "signature": {
              "description": "A byte array of 64 bytes which are serialized as a 128 character long hex-encoded string representing a signature from the EDDSA Ed25519 edwards curve.",
              "type": "string",
              "maxLength": 128,
              "minLength": 128,
              "pattern": "[0-9a-fA-F]+"
            }
          }
        }
      ]
    },
    "Signature": {
      "description": "A discriminated union of the possible cryptographic signatures used by Scrypto and the Radix Engine.",
      "oneOf": [
        {
          "description": "A byte array of 65 bytes which are serialized as a 130 character long hex-encoded string representing a signature from the ECDSA Secp256k1 elliptic curve. An important note on ECDSA Secp256k1 signatures is that the format used and accepted by Scrypto is [v, r, s] where `v` is the recovery id and is a single byte and `r` and `s` are the signature results and are 32 bytes each.",
          "examples": [
            {
              "curve": "EcdsaSecp256k1",
              "signature": "007f054d0a376fb5cce93c5836531ce5d116dcdb134211650553ddeba408e53b4725b8fe89d120c41667fe457acae408025371a61b8fe05b20d2c2b9e8d81f1a53"
            }
          ],
          "type": "object",
          "required": [
            "curve",
            "signature"
          ],
          "properties": {
            "curve": {
              "type": "string",
              "enum": [
                "EcdsaSecp256k1"
              ]
            },
            "signature": {
              "type": "string",
              "maxLength": 130,
              "minLength": 130,
              "pattern": "[0-9a-fA-F]+"
            }
          }
        },
        {
          "description": "A byte array of 64 bytes which are serialized as a 128 character long hex-encoded string representing a signature from the EDDSA Ed25519 edwards curve.",
          "examples": [
            {
              "curve": "EddsaEd25519",
              "signature": "e5f1e508cc91a95a280613618a1ccb5142744b5b8a6042e232dcaadf17e41f1f0131d535ea3fa56b6ae8164586cd6b4e89e3224e994b3109ca51cae02e7dce01"
            }
          ],
          "type": "object",
          "required": [
            "curve",
            "signature"
          ],
          "properties": {
            "curve": {
              "type": "string",
              "enum": [
                "EddsaEd25519"
              ]
            },
            "signature": {
              "type": "string",
              "maxLength": 128,
              "minLength": 128,
              "pattern": "[0-9a-fA-F]+"
            }
          }
        }
      ]
    }
  }
}